function _mergeNamespaces(_, j) { for (var $ = 0; $ < j.length; $++) { const _e = j[$]; if (typeof _e != "string" && !Array.isArray(_e)) { for (const et in _e) if (et !== "default" && !(et in _)) { const tt = Object.getOwnPropertyDescriptor(_e, et); tt && Object.defineProperty(_, et, tt.get ? tt : { enumerable: !0, get: () => _e[et] }) } } } return Object.freeze(Object.defineProperty(_, Symbol.toStringTag, { value: "Module" })) } (function () { const j = document.createElement("link").relList; if (j && j.supports && j.supports("modulepreload")) return; for (const et of document.querySelectorAll('link[rel="modulepreload"]')) _e(et); new MutationObserver(et => { for (const tt of et) if (tt.type === "childList") for (const rt of tt.addedNodes) rt.tagName === "LINK" && rt.rel === "modulepreload" && _e(rt) }).observe(document, { childList: !0, subtree: !0 }); function $(et) { const tt = {}; return et.integrity && (tt.integrity = et.integrity), et.referrerPolicy && (tt.referrerPolicy = et.referrerPolicy), et.crossOrigin === "use-credentials" ? tt.credentials = "include" : et.crossOrigin === "anonymous" ? tt.credentials = "omit" : tt.credentials = "same-origin", tt } function _e(et) { if (et.ep) return; et.ep = !0; const tt = $(et); fetch(et.href, tt) } })(); var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs(_) { return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _ } var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {}, react = { exports: {} }, react_production_min = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$5 = Symbol.for("react.element"), n$4 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$6 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$2 = Symbol.iterator; function A$2(_) { return _ === null || typeof _ != "object" ? null : (_ = z$2 && _[z$2] || _["@@iterator"], typeof _ == "function" ? _ : null) } var B$1 = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, C$1 = Object.assign, D$1 = {}; function E$1(_, j, $) { this.props = _, this.context = j, this.refs = D$1, this.updater = $ || B$1 } E$1.prototype.isReactComponent = {}; E$1.prototype.setState = function (_, j) { if (typeof _ != "object" && typeof _ != "function" && _ != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, _, j, "setState") }; E$1.prototype.forceUpdate = function (_) { this.updater.enqueueForceUpdate(this, _, "forceUpdate") }; function F() { } F.prototype = E$1.prototype; function G$1(_, j, $) { this.props = _, this.context = j, this.refs = D$1, this.updater = $ || B$1 } var H$1 = G$1.prototype = new F; H$1.constructor = G$1; C$1(H$1, E$1.prototype); H$1.isPureReactComponent = !0; var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: !0, ref: !0, __self: !0, __source: !0 }; function M$1(_, j, $) { var _e, et = {}, tt = null, rt = null; if (j != null) for (_e in j.ref !== void 0 && (rt = j.ref), j.key !== void 0 && (tt = "" + j.key), j) J.call(j, _e) && !L$1.hasOwnProperty(_e) && (et[_e] = j[_e]); var nt = arguments.length - 2; if (nt === 1) et.children = $; else if (1 < nt) { for (var it = Array(nt), st = 0; st < nt; st++)it[st] = arguments[st + 2]; et.children = it } if (_ && _.defaultProps) for (_e in nt = _.defaultProps, nt) et[_e] === void 0 && (et[_e] = nt[_e]); return { $$typeof: l$5, type: _, key: tt, ref: rt, props: et, _owner: K$1.current } } function N$1(_, j) { return { $$typeof: l$5, type: _.type, key: j, ref: _.ref, props: _.props, _owner: _._owner } } function O$1(_) { return typeof _ == "object" && _ !== null && _.$$typeof === l$5 } function escape(_) { var j = { "=": "=0", ":": "=2" }; return "$" + _.replace(/[=:]/g, function ($) { return j[$] }) } var P$1 = /\/+/g; function Q$1(_, j) { return typeof _ == "object" && _ !== null && _.key != null ? escape("" + _.key) : j.toString(36) } function R$1(_, j, $, _e, et) { var tt = typeof _; (tt === "undefined" || tt === "boolean") && (_ = null); var rt = !1; if (_ === null) rt = !0; else switch (tt) { case "string": case "number": rt = !0; break; case "object": switch (_.$$typeof) { case l$5: case n$4: rt = !0 } }if (rt) return rt = _, et = et(rt), _ = _e === "" ? "." + Q$1(rt, 0) : _e, I$1(et) ? ($ = "", _ != null && ($ = _.replace(P$1, "$&/") + "/"), R$1(et, j, $, "", function (st) { return st })) : et != null && (O$1(et) && (et = N$1(et, $ + (!et.key || rt && rt.key === et.key ? "" : ("" + et.key).replace(P$1, "$&/") + "/") + _)), j.push(et)), 1; if (rt = 0, _e = _e === "" ? "." : _e + ":", I$1(_)) for (var nt = 0; nt < _.length; nt++) { tt = _[nt]; var it = _e + Q$1(tt, nt); rt += R$1(tt, j, $, it, et) } else if (it = A$2(_), typeof it == "function") for (_ = it.call(_), nt = 0; !(tt = _.next()).done;)tt = tt.value, it = _e + Q$1(tt, nt++), rt += R$1(tt, j, $, it, et); else if (tt === "object") throw j = String(_), Error("Objects are not valid as a React child (found: " + (j === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : j) + "). If you meant to render a collection of children, use an array instead."); return rt } function S$1(_, j, $) { if (_ == null) return _; var _e = [], et = 0; return R$1(_, _e, "", "", function (tt) { return j.call($, tt, et++) }), _e } function T$1(_) { if (_._status === -1) { var j = _._result; j = j(), j.then(function ($) { (_._status === 0 || _._status === -1) && (_._status = 1, _._result = $) }, function ($) { (_._status === 0 || _._status === -1) && (_._status = 2, _._result = $) }), _._status === -1 && (_._status = 0, _._result = j) } if (_._status === 1) return _._result.default; throw _._result } var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 }; react_production_min.Children = { map: S$1, forEach: function (_, j, $) { S$1(_, function () { j.apply(this, arguments) }, $) }, count: function (_) { var j = 0; return S$1(_, function () { j++ }), j }, toArray: function (_) { return S$1(_, function (j) { return j }) || [] }, only: function (_) { if (!O$1(_)) throw Error("React.Children.only expected to receive a single React element child."); return _ } }; react_production_min.Component = E$1; react_production_min.Fragment = p$5; react_production_min.Profiler = r$2; react_production_min.PureComponent = G$1; react_production_min.StrictMode = q$3; react_production_min.Suspense = w$3; react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1; react_production_min.cloneElement = function (_, j, $) { if (_ == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + _ + "."); var _e = C$1({}, _.props), et = _.key, tt = _.ref, rt = _._owner; if (j != null) { if (j.ref !== void 0 && (tt = j.ref, rt = K$1.current), j.key !== void 0 && (et = "" + j.key), _.type && _.type.defaultProps) var nt = _.type.defaultProps; for (it in j) J.call(j, it) && !L$1.hasOwnProperty(it) && (_e[it] = j[it] === void 0 && nt !== void 0 ? nt[it] : j[it]) } var it = arguments.length - 2; if (it === 1) _e.children = $; else if (1 < it) { nt = Array(it); for (var st = 0; st < it; st++)nt[st] = arguments[st + 2]; _e.children = nt } return { $$typeof: l$5, type: _.type, key: et, ref: tt, props: _e, _owner: rt } }; react_production_min.createContext = function (_) { return _ = { $$typeof: u$2, _currentValue: _, _currentValue2: _, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, _.Provider = { $$typeof: t$2, _context: _ }, _.Consumer = _ }; react_production_min.createElement = M$1; react_production_min.createFactory = function (_) { var j = M$1.bind(null, _); return j.type = _, j }; react_production_min.createRef = function () { return { current: null } }; react_production_min.forwardRef = function (_) { return { $$typeof: v$6, render: _ } }; react_production_min.isValidElement = O$1; react_production_min.lazy = function (_) { return { $$typeof: y$2, _payload: { _status: -1, _result: _ }, _init: T$1 } }; react_production_min.memo = function (_, j) { return { $$typeof: x$1, type: _, compare: j === void 0 ? null : j } }; react_production_min.startTransition = function (_) { var j = V$1.transition; V$1.transition = {}; try { _() } finally { V$1.transition = j } }; react_production_min.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; react_production_min.useCallback = function (_, j) { return U$1.current.useCallback(_, j) }; react_production_min.useContext = function (_) { return U$1.current.useContext(_) }; react_production_min.useDebugValue = function () { }; react_production_min.useDeferredValue = function (_) { return U$1.current.useDeferredValue(_) }; react_production_min.useEffect = function (_, j) { return U$1.current.useEffect(_, j) }; react_production_min.useId = function () { return U$1.current.useId() }; react_production_min.useImperativeHandle = function (_, j, $) { return U$1.current.useImperativeHandle(_, j, $) }; react_production_min.useInsertionEffect = function (_, j) { return U$1.current.useInsertionEffect(_, j) }; react_production_min.useLayoutEffect = function (_, j) { return U$1.current.useLayoutEffect(_, j) }; react_production_min.useMemo = function (_, j) { return U$1.current.useMemo(_, j) }; react_production_min.useReducer = function (_, j, $) { return U$1.current.useReducer(_, j, $) }; react_production_min.useRef = function (_) { return U$1.current.useRef(_) }; react_production_min.useState = function (_) { return U$1.current.useState(_) }; react_production_min.useSyncExternalStore = function (_, j, $) { return U$1.current.useSyncExternalStore(_, j, $) }; react_production_min.useTransition = function () { return U$1.current.useTransition() }; react_production_min.version = "18.2.0"; react.exports = react_production_min; var reactExports = react.exports; const React$1 = getDefaultExportFromCjs(reactExports), React$2 = _mergeNamespaces({ __proto__: null, default: React$1 }, [reactExports]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f$3 = reactExports, k$2 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$3 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: !0, ref: !0, __self: !0, __source: !0 }; function q$2(_, j, $) { var _e, et = {}, tt = null, rt = null; $ !== void 0 && (tt = "" + $), j.key !== void 0 && (tt = "" + j.key), j.ref !== void 0 && (rt = j.ref); for (_e in j) m$4.call(j, _e) && !p$4.hasOwnProperty(_e) && (et[_e] = j[_e]); if (_ && _.defaultProps) for (_e in j = _.defaultProps, j) et[_e] === void 0 && (et[_e] = j[_e]); return { $$typeof: k$2, type: _, key: tt, ref: rt, props: et, _owner: n$3.current } } reactJsxRuntime_production_min.Fragment = l$4; reactJsxRuntime_production_min.jsx = q$2; reactJsxRuntime_production_min.jsxs = q$2; jsxRuntime.exports = reactJsxRuntime_production_min; var jsxRuntimeExports = jsxRuntime.exports, client = {}, reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (_) { function j(vt, Et) { var Ct = vt.length; vt.push(Et); e: for (; 0 < Ct;) { var wt = Ct - 1 >>> 1, Tt = vt[wt]; if (0 < et(Tt, Et)) vt[wt] = Et, vt[Ct] = Tt, Ct = wt; else break e } } function $(vt) { return vt.length === 0 ? null : vt[0] } function _e(vt) { if (vt.length === 0) return null; var Et = vt[0], Ct = vt.pop(); if (Ct !== Et) { vt[0] = Ct; e: for (var wt = 0, Tt = vt.length, jt = Tt >>> 1; wt < jt;) { var Ft = 2 * (wt + 1) - 1, Dt = vt[Ft], Ot = Ft + 1, Nt = vt[Ot]; if (0 > et(Dt, Ct)) Ot < Tt && 0 > et(Nt, Dt) ? (vt[wt] = Nt, vt[Ot] = Ct, wt = Ot) : (vt[wt] = Dt, vt[Ft] = Ct, wt = Ft); else if (Ot < Tt && 0 > et(Nt, Ct)) vt[wt] = Nt, vt[Ot] = Ct, wt = Ot; else break e } } return Et } function et(vt, Et) { var Ct = vt.sortIndex - Et.sortIndex; return Ct !== 0 ? Ct : vt.id - Et.id } if (typeof performance == "object" && typeof performance.now == "function") { var tt = performance; _.unstable_now = function () { return tt.now() } } else { var rt = Date, nt = rt.now(); _.unstable_now = function () { return rt.now() - nt } } var it = [], st = [], ot = 1, ft = null, at = 3, dt = !1, pt = !1, ht = !1, xt = typeof setTimeout == "function" ? setTimeout : null, ct = typeof clearTimeout == "function" ? clearTimeout : null, ut = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function lt(vt) { for (var Et = $(st); Et !== null;) { if (Et.callback === null) _e(st); else if (Et.startTime <= vt) _e(st), Et.sortIndex = Et.expirationTime, j(it, Et); else break; Et = $(st) } } function mt(vt) { if (ht = !1, lt(vt), !pt) if ($(it) !== null) pt = !0, Pt(yt); else { var Et = $(st); Et !== null && kt(mt, Et.startTime - vt) } } function yt(vt, Et) { pt = !1, ht && (ht = !1, ct(bt), bt = -1), dt = !0; var Ct = at; try { for (lt(Et), ft = $(it); ft !== null && (!(ft.expirationTime > Et) || vt && !It());) { var wt = ft.callback; if (typeof wt == "function") { ft.callback = null, at = ft.priorityLevel; var Tt = wt(ft.expirationTime <= Et); Et = _.unstable_now(), typeof Tt == "function" ? ft.callback = Tt : ft === $(it) && _e(it), lt(Et) } else _e(it); ft = $(it) } if (ft !== null) var jt = !0; else { var Ft = $(st); Ft !== null && kt(mt, Ft.startTime - Et), jt = !1 } return jt } finally { ft = null, at = Ct, dt = !1 } } var gt = !1, St = null, bt = -1, _t = 5, Mt = -1; function It() { return !(_.unstable_now() - Mt < _t) } function Rt() { if (St !== null) { var vt = _.unstable_now(); Mt = vt; var Et = !0; try { Et = St(!0, vt) } finally { Et ? Lt() : (gt = !1, St = null) } } else gt = !1 } var Lt; if (typeof ut == "function") Lt = function () { ut(Rt) }; else if (typeof MessageChannel < "u") { var Vt = new MessageChannel, At = Vt.port2; Vt.port1.onmessage = Rt, Lt = function () { At.postMessage(null) } } else Lt = function () { xt(Rt, 0) }; function Pt(vt) { St = vt, gt || (gt = !0, Lt()) } function kt(vt, Et) { bt = xt(function () { vt(_.unstable_now()) }, Et) } _.unstable_IdlePriority = 5, _.unstable_ImmediatePriority = 1, _.unstable_LowPriority = 4, _.unstable_NormalPriority = 3, _.unstable_Profiling = null, _.unstable_UserBlockingPriority = 2, _.unstable_cancelCallback = function (vt) { vt.callback = null }, _.unstable_continueExecution = function () { pt || dt || (pt = !0, Pt(yt)) }, _.unstable_forceFrameRate = function (vt) { 0 > vt || 125 < vt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : _t = 0 < vt ? Math.floor(1e3 / vt) : 5 }, _.unstable_getCurrentPriorityLevel = function () { return at }, _.unstable_getFirstCallbackNode = function () { return $(it) }, _.unstable_next = function (vt) { switch (at) { case 1: case 2: case 3: var Et = 3; break; default: Et = at }var Ct = at; at = Et; try { return vt() } finally { at = Ct } }, _.unstable_pauseExecution = function () { }, _.unstable_requestPaint = function () { }, _.unstable_runWithPriority = function (vt, Et) { switch (vt) { case 1: case 2: case 3: case 4: case 5: break; default: vt = 3 }var Ct = at; at = vt; try { return Et() } finally { at = Ct } }, _.unstable_scheduleCallback = function (vt, Et, Ct) { var wt = _.unstable_now(); switch (typeof Ct == "object" && Ct !== null ? (Ct = Ct.delay, Ct = typeof Ct == "number" && 0 < Ct ? wt + Ct : wt) : Ct = wt, vt) { case 1: var Tt = -1; break; case 2: Tt = 250; break; case 5: Tt = 1073741823; break; case 4: Tt = 1e4; break; default: Tt = 5e3 }return Tt = Ct + Tt, vt = { id: ot++, callback: Et, priorityLevel: vt, startTime: Ct, expirationTime: Tt, sortIndex: -1 }, Ct > wt ? (vt.sortIndex = Ct, j(st, vt), $(it) === null && vt === $(st) && (ht ? (ct(bt), bt = -1) : ht = !0, kt(mt, Ct - wt))) : (vt.sortIndex = Tt, j(it, vt), pt || dt || (pt = !0, Pt(yt))), vt }, _.unstable_shouldYield = It, _.unstable_wrapCallback = function (vt) { var Et = at; return function () { var Ct = at; at = Et; try { return vt.apply(this, arguments) } finally { at = Ct } } } })(scheduler_production_min); scheduler.exports = scheduler_production_min; var schedulerExports = scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa = reactExports, ca = schedulerExports; function p$3(_) { for (var j = "https://reactjs.org/docs/error-decoder.html?invariant=" + _, $ = 1; $ < arguments.length; $++)j += "&args[]=" + encodeURIComponent(arguments[$]); return "Minified React error #" + _ + "; visit " + j + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var da = new Set, ea = {}; function fa(_, j) { ha(_, j), ha(_ + "Capture", j) } function ha(_, j) { for (ea[_] = j, _ = 0; _ < j.length; _++)da.add(j[_]) } var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {}; function oa(_) { return ja.call(ma, _) ? !0 : ja.call(la, _) ? !1 : ka.test(_) ? ma[_] = !0 : (la[_] = !0, !1) } function pa(_, j, $, _e) { if ($ !== null && $.type === 0) return !1; switch (typeof j) { case "function": case "symbol": return !0; case "boolean": return _e ? !1 : $ !== null ? !$.acceptsBooleans : (_ = _.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-"); default: return !1 } } function qa(_, j, $, _e) { if (j === null || typeof j > "u" || pa(_, j, $, _e)) return !0; if (_e) return !1; if ($ !== null) switch ($.type) { case 3: return !j; case 4: return j === !1; case 5: return isNaN(j); case 6: return isNaN(j) || 1 > j }return !1 } function v$5(_, j, $, _e, et, tt, rt) { this.acceptsBooleans = j === 2 || j === 3 || j === 4, this.attributeName = _e, this.attributeNamespace = et, this.mustUseProperty = $, this.propertyName = _, this.type = j, this.sanitizeURL = tt, this.removeEmptyString = rt } var z$1 = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (_) { z$1[_] = new v$5(_, 0, !1, _, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (_) { var j = _[0]; z$1[j] = new v$5(j, 1, !1, _[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (_) { z$1[_] = new v$5(_, 2, !1, _.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (_) { z$1[_] = new v$5(_, 2, !1, _, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (_) { z$1[_] = new v$5(_, 3, !1, _.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (_) { z$1[_] = new v$5(_, 3, !0, _, null, !1, !1) });["capture", "download"].forEach(function (_) { z$1[_] = new v$5(_, 4, !1, _, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (_) { z$1[_] = new v$5(_, 6, !1, _, null, !1, !1) });["rowSpan", "start"].forEach(function (_) { z$1[_] = new v$5(_, 5, !1, _.toLowerCase(), null, !1, !1) }); var ra = /[\-:]([a-z])/g; function sa(_) { return _[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (_) { var j = _.replace(ra, sa); z$1[j] = new v$5(j, 1, !1, _, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (_) { var j = _.replace(ra, sa); z$1[j] = new v$5(j, 1, !1, _, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (_) { var j = _.replace(ra, sa); z$1[j] = new v$5(j, 1, !1, _, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (_) { z$1[_] = new v$5(_, 1, !1, _.toLowerCase(), null, !1, !1) }); z$1.xlinkHref = new v$5("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (_) { z$1[_] = new v$5(_, 1, !1, _.toLowerCase(), null, !0, !0) }); function ta(_, j, $, _e) { var et = z$1.hasOwnProperty(j) ? z$1[j] : null; (et !== null ? et.type !== 0 : _e || !(2 < j.length) || j[0] !== "o" && j[0] !== "O" || j[1] !== "n" && j[1] !== "N") && (qa(j, $, et, _e) && ($ = null), _e || et === null ? oa(j) && ($ === null ? _.removeAttribute(j) : _.setAttribute(j, "" + $)) : et.mustUseProperty ? _[et.propertyName] = $ === null ? et.type === 3 ? !1 : "" : $ : (j = et.attributeName, _e = et.attributeNamespace, $ === null ? _.removeAttribute(j) : (et = et.type, $ = et === 3 || et === 4 && $ === !0 ? "" : "" + $, _e ? _.setAttributeNS(_e, j, $) : _.setAttribute(j, $)))) } var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy"), Ia = Symbol.for("react.offscreen"), Ja = Symbol.iterator; function Ka(_) { return _ === null || typeof _ != "object" ? null : (_ = Ja && _[Ja] || _["@@iterator"], typeof _ == "function" ? _ : null) } var A$1 = Object.assign, La; function Ma(_) {
  if (La === void 0) try { throw Error() } catch ($) { var j = $.stack.trim().match(/\n( *(at )?)/); La = j && j[1] || "" } return `
`+ La + _
} var Na = !1; function Oa(_, j) {
  if (!_ || Na) return ""; Na = !0; var $ = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (j) if (j = function () { throw Error() }, Object.defineProperty(j.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(j, []) } catch (st) { var _e = st } Reflect.construct(_, [], j) } else { try { j.call() } catch (st) { _e = st } _.call(j.prototype) } else { try { throw Error() } catch (st) { _e = st } _() } } catch (st) {
    if (st && _e && typeof st.stack == "string") {
      for (var et = st.stack.split(`
`), tt = _e.stack.split(`
`), rt = et.length - 1, nt = tt.length - 1; 1 <= rt && 0 <= nt && et[rt] !== tt[nt];)nt--; for (; 1 <= rt && 0 <= nt; rt--, nt--)if (et[rt] !== tt[nt]) {
        if (rt !== 1 || nt !== 1) do if (rt--, nt--, 0 > nt || et[rt] !== tt[nt]) {
          var it = `
`+ et[rt].replace(" at new ", " at "); return _.displayName && it.includes("<anonymous>") && (it = it.replace("<anonymous>", _.displayName)), it
        } while (1 <= rt && 0 <= nt); break
      }
    }
  } finally { Na = !1, Error.prepareStackTrace = $ } return (_ = _ ? _.displayName || _.name : "") ? Ma(_) : ""
} function Pa(_) { switch (_.tag) { case 5: return Ma(_.type); case 16: return Ma("Lazy"); case 13: return Ma("Suspense"); case 19: return Ma("SuspenseList"); case 0: case 2: case 15: return _ = Oa(_.type, !1), _; case 11: return _ = Oa(_.type.render, !1), _; case 1: return _ = Oa(_.type, !0), _; default: return "" } } function Qa(_) { if (_ == null) return null; if (typeof _ == "function") return _.displayName || _.name || null; if (typeof _ == "string") return _; switch (_) { case ya: return "Fragment"; case wa: return "Portal"; case Aa: return "Profiler"; case za: return "StrictMode"; case Ea: return "Suspense"; case Fa: return "SuspenseList" }if (typeof _ == "object") switch (_.$$typeof) { case Ca: return (_.displayName || "Context") + ".Consumer"; case Ba: return (_._context.displayName || "Context") + ".Provider"; case Da: var j = _.render; return _ = _.displayName, _ || (_ = j.displayName || j.name || "", _ = _ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef"), _; case Ga: return j = _.displayName || null, j !== null ? j : Qa(_.type) || "Memo"; case Ha: j = _._payload, _ = _._init; try { return Qa(_(j)) } catch { } }return null } function Ra(_) { var j = _.type; switch (_.tag) { case 24: return "Cache"; case 9: return (j.displayName || "Context") + ".Consumer"; case 10: return (j._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return _ = j.render, _ = _.displayName || _.name || "", j.displayName || (_ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return j; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Qa(j); case 8: return j === za ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof j == "function") return j.displayName || j.name || null; if (typeof j == "string") return j }return null } function Sa(_) { switch (typeof _) { case "boolean": case "number": case "string": case "undefined": return _; case "object": return _; default: return "" } } function Ta(_) { var j = _.type; return (_ = _.nodeName) && _.toLowerCase() === "input" && (j === "checkbox" || j === "radio") } function Ua(_) { var j = Ta(_) ? "checked" : "value", $ = Object.getOwnPropertyDescriptor(_.constructor.prototype, j), _e = "" + _[j]; if (!_.hasOwnProperty(j) && typeof $ < "u" && typeof $.get == "function" && typeof $.set == "function") { var et = $.get, tt = $.set; return Object.defineProperty(_, j, { configurable: !0, get: function () { return et.call(this) }, set: function (rt) { _e = "" + rt, tt.call(this, rt) } }), Object.defineProperty(_, j, { enumerable: $.enumerable }), { getValue: function () { return _e }, setValue: function (rt) { _e = "" + rt }, stopTracking: function () { _._valueTracker = null, delete _[j] } } } } function Va(_) { _._valueTracker || (_._valueTracker = Ua(_)) } function Wa(_) { if (!_) return !1; var j = _._valueTracker; if (!j) return !0; var $ = j.getValue(), _e = ""; return _ && (_e = Ta(_) ? _.checked ? "true" : "false" : _.value), _ = _e, _ !== $ ? (j.setValue(_), !0) : !1 } function Xa(_) { if (_ = _ || (typeof document < "u" ? document : void 0), typeof _ > "u") return null; try { return _.activeElement || _.body } catch { return _.body } } function Ya(_, j) { var $ = j.checked; return A$1({}, j, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: $ ?? _._wrapperState.initialChecked }) } function Za(_, j) { var $ = j.defaultValue == null ? "" : j.defaultValue, _e = j.checked != null ? j.checked : j.defaultChecked; $ = Sa(j.value != null ? j.value : $), _._wrapperState = { initialChecked: _e, initialValue: $, controlled: j.type === "checkbox" || j.type === "radio" ? j.checked != null : j.value != null } } function ab(_, j) { j = j.checked, j != null && ta(_, "checked", j, !1) } function bb(_, j) { ab(_, j); var $ = Sa(j.value), _e = j.type; if ($ != null) _e === "number" ? ($ === 0 && _.value === "" || _.value != $) && (_.value = "" + $) : _.value !== "" + $ && (_.value = "" + $); else if (_e === "submit" || _e === "reset") { _.removeAttribute("value"); return } j.hasOwnProperty("value") ? cb(_, j.type, $) : j.hasOwnProperty("defaultValue") && cb(_, j.type, Sa(j.defaultValue)), j.checked == null && j.defaultChecked != null && (_.defaultChecked = !!j.defaultChecked) } function db(_, j, $) { if (j.hasOwnProperty("value") || j.hasOwnProperty("defaultValue")) { var _e = j.type; if (!(_e !== "submit" && _e !== "reset" || j.value !== void 0 && j.value !== null)) return; j = "" + _._wrapperState.initialValue, $ || j === _.value || (_.value = j), _.defaultValue = j } $ = _.name, $ !== "" && (_.name = ""), _.defaultChecked = !!_._wrapperState.initialChecked, $ !== "" && (_.name = $) } function cb(_, j, $) { (j !== "number" || Xa(_.ownerDocument) !== _) && ($ == null ? _.defaultValue = "" + _._wrapperState.initialValue : _.defaultValue !== "" + $ && (_.defaultValue = "" + $)) } var eb = Array.isArray; function fb(_, j, $, _e) { if (_ = _.options, j) { j = {}; for (var et = 0; et < $.length; et++)j["$" + $[et]] = !0; for ($ = 0; $ < _.length; $++)et = j.hasOwnProperty("$" + _[$].value), _[$].selected !== et && (_[$].selected = et), et && _e && (_[$].defaultSelected = !0) } else { for ($ = "" + Sa($), j = null, et = 0; et < _.length; et++) { if (_[et].value === $) { _[et].selected = !0, _e && (_[et].defaultSelected = !0); return } j !== null || _[et].disabled || (j = _[et]) } j !== null && (j.selected = !0) } } function gb(_, j) { if (j.dangerouslySetInnerHTML != null) throw Error(p$3(91)); return A$1({}, j, { value: void 0, defaultValue: void 0, children: "" + _._wrapperState.initialValue }) } function hb(_, j) { var $ = j.value; if ($ == null) { if ($ = j.children, j = j.defaultValue, $ != null) { if (j != null) throw Error(p$3(92)); if (eb($)) { if (1 < $.length) throw Error(p$3(93)); $ = $[0] } j = $ } j == null && (j = ""), $ = j } _._wrapperState = { initialValue: Sa($) } } function ib(_, j) { var $ = Sa(j.value), _e = Sa(j.defaultValue); $ != null && ($ = "" + $, $ !== _.value && (_.value = $), j.defaultValue == null && _.defaultValue !== $ && (_.defaultValue = $)), _e != null && (_.defaultValue = "" + _e) } function jb(_) { var j = _.textContent; j === _._wrapperState.initialValue && j !== "" && j !== null && (_.value = j) } function kb(_) { switch (_) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function lb(_, j) { return _ == null || _ === "http://www.w3.org/1999/xhtml" ? kb(j) : _ === "http://www.w3.org/2000/svg" && j === "foreignObject" ? "http://www.w3.org/1999/xhtml" : _ } var mb, nb = function (_) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (j, $, _e, et) { MSApp.execUnsafeLocalFunction(function () { return _(j, $, _e, et) }) } : _ }(function (_, j) { if (_.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in _) _.innerHTML = j; else { for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + j.valueOf().toString() + "</svg>", j = mb.firstChild; _.firstChild;)_.removeChild(_.firstChild); for (; j.firstChild;)_.appendChild(j.firstChild) } }); function ob(_, j) { if (j) { var $ = _.firstChild; if ($ && $ === _.lastChild && $.nodeType === 3) { $.nodeValue = j; return } } _.textContent = j } var pb = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, qb = ["Webkit", "ms", "Moz", "O"]; Object.keys(pb).forEach(function (_) { qb.forEach(function (j) { j = j + _.charAt(0).toUpperCase() + _.substring(1), pb[j] = pb[_] }) }); function rb(_, j, $) { return j == null || typeof j == "boolean" || j === "" ? "" : $ || typeof j != "number" || j === 0 || pb.hasOwnProperty(_) && pb[_] ? ("" + j).trim() : j + "px" } function sb(_, j) { _ = _.style; for (var $ in j) if (j.hasOwnProperty($)) { var _e = $.indexOf("--") === 0, et = rb($, j[$], _e); $ === "float" && ($ = "cssFloat"), _e ? _.setProperty($, et) : _[$] = et } } var tb = A$1({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ub(_, j) { if (j) { if (tb[_] && (j.children != null || j.dangerouslySetInnerHTML != null)) throw Error(p$3(137, _)); if (j.dangerouslySetInnerHTML != null) { if (j.children != null) throw Error(p$3(60)); if (typeof j.dangerouslySetInnerHTML != "object" || !("__html" in j.dangerouslySetInnerHTML)) throw Error(p$3(61)) } if (j.style != null && typeof j.style != "object") throw Error(p$3(62)) } } function vb(_, j) { if (_.indexOf("-") === -1) return typeof j.is == "string"; switch (_) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var wb = null; function xb(_) { return _ = _.target || _.srcElement || window, _.correspondingUseElement && (_ = _.correspondingUseElement), _.nodeType === 3 ? _.parentNode : _ } var yb = null, zb = null, Ab = null; function Bb(_) { if (_ = Cb(_)) { if (typeof yb != "function") throw Error(p$3(280)); var j = _.stateNode; j && (j = Db(j), yb(_.stateNode, _.type, j)) } } function Eb(_) { zb ? Ab ? Ab.push(_) : Ab = [_] : zb = _ } function Fb() { if (zb) { var _ = zb, j = Ab; if (Ab = zb = null, Bb(_), j) for (_ = 0; _ < j.length; _++)Bb(j[_]) } } function Gb(_, j) { return _(j) } function Hb() { } var Ib = !1; function Jb(_, j, $) { if (Ib) return _(j, $); Ib = !0; try { return Gb(_, j, $) } finally { Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb()) } } function Kb(_, j) { var $ = _.stateNode; if ($ === null) return null; var _e = Db($); if (_e === null) return null; $ = _e[j]; e: switch (j) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (_e = !_e.disabled) || (_ = _.type, _e = !(_ === "button" || _ === "input" || _ === "select" || _ === "textarea")), _ = !_e; break e; default: _ = !1 }if (_) return null; if ($ && typeof $ != "function") throw Error(p$3(231, j, typeof $)); return $ } var Lb = !1; if (ia) try { var Mb = {}; Object.defineProperty(Mb, "passive", { get: function () { Lb = !0 } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb) } catch { Lb = !1 } function Nb(_, j, $, _e, et, tt, rt, nt, it) { var st = Array.prototype.slice.call(arguments, 3); try { j.apply($, st) } catch (ot) { this.onError(ot) } } var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = { onError: function (_) { Ob = !0, Pb = _ } }; function Tb(_, j, $, _e, et, tt, rt, nt, it) { Ob = !1, Pb = null, Nb.apply(Sb, arguments) } function Ub(_, j, $, _e, et, tt, rt, nt, it) { if (Tb.apply(this, arguments), Ob) { if (Ob) { var st = Pb; Ob = !1, Pb = null } else throw Error(p$3(198)); Qb || (Qb = !0, Rb = st) } } function Vb(_) { var j = _, $ = _; if (_.alternate) for (; j.return;)j = j.return; else { _ = j; do j = _, j.flags & 4098 && ($ = j.return), _ = j.return; while (_) } return j.tag === 3 ? $ : null } function Wb(_) { if (_.tag === 13) { var j = _.memoizedState; if (j === null && (_ = _.alternate, _ !== null && (j = _.memoizedState)), j !== null) return j.dehydrated } return null } function Xb(_) { if (Vb(_) !== _) throw Error(p$3(188)) } function Yb(_) { var j = _.alternate; if (!j) { if (j = Vb(_), j === null) throw Error(p$3(188)); return j !== _ ? null : _ } for (var $ = _, _e = j; ;) { var et = $.return; if (et === null) break; var tt = et.alternate; if (tt === null) { if (_e = et.return, _e !== null) { $ = _e; continue } break } if (et.child === tt.child) { for (tt = et.child; tt;) { if (tt === $) return Xb(et), _; if (tt === _e) return Xb(et), j; tt = tt.sibling } throw Error(p$3(188)) } if ($.return !== _e.return) $ = et, _e = tt; else { for (var rt = !1, nt = et.child; nt;) { if (nt === $) { rt = !0, $ = et, _e = tt; break } if (nt === _e) { rt = !0, _e = et, $ = tt; break } nt = nt.sibling } if (!rt) { for (nt = tt.child; nt;) { if (nt === $) { rt = !0, $ = tt, _e = et; break } if (nt === _e) { rt = !0, _e = tt, $ = et; break } nt = nt.sibling } if (!rt) throw Error(p$3(189)) } } if ($.alternate !== _e) throw Error(p$3(190)) } if ($.tag !== 3) throw Error(p$3(188)); return $.stateNode.current === $ ? _ : j } function Zb(_) { return _ = Yb(_), _ !== null ? $b(_) : null } function $b(_) { if (_.tag === 5 || _.tag === 6) return _; for (_ = _.child; _ !== null;) { var j = $b(_); if (j !== null) return j; _ = _.sibling } return null } var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null; function mc(_) { if (lc && typeof lc.onCommitFiberRoot == "function") try { lc.onCommitFiberRoot(kc, _, void 0, (_.current.flags & 128) === 128) } catch { } } var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2; function nc(_) { return _ >>>= 0, _ === 0 ? 32 : 31 - (pc(_) / qc | 0) | 0 } var rc = 64, sc = 4194304; function tc(_) { switch (_ & -_) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return _ & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return _ & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return _ } } function uc(_, j) { var $ = _.pendingLanes; if ($ === 0) return 0; var _e = 0, et = _.suspendedLanes, tt = _.pingedLanes, rt = $ & 268435455; if (rt !== 0) { var nt = rt & ~et; nt !== 0 ? _e = tc(nt) : (tt &= rt, tt !== 0 && (_e = tc(tt))) } else rt = $ & ~et, rt !== 0 ? _e = tc(rt) : tt !== 0 && (_e = tc(tt)); if (_e === 0) return 0; if (j !== 0 && j !== _e && !(j & et) && (et = _e & -_e, tt = j & -j, et >= tt || et === 16 && (tt & 4194240) !== 0)) return j; if (_e & 4 && (_e |= $ & 16), j = _.entangledLanes, j !== 0) for (_ = _.entanglements, j &= _e; 0 < j;)$ = 31 - oc(j), et = 1 << $, _e |= _[$], j &= ~et; return _e } function vc(_, j) { switch (_) { case 1: case 2: case 4: return j + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return j + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function wc(_, j) { for (var $ = _.suspendedLanes, _e = _.pingedLanes, et = _.expirationTimes, tt = _.pendingLanes; 0 < tt;) { var rt = 31 - oc(tt), nt = 1 << rt, it = et[rt]; it === -1 ? (!(nt & $) || nt & _e) && (et[rt] = vc(nt, j)) : it <= j && (_.expiredLanes |= nt), tt &= ~nt } } function xc(_) { return _ = _.pendingLanes & -1073741825, _ !== 0 ? _ : _ & 1073741824 ? 1073741824 : 0 } function yc() { var _ = rc; return rc <<= 1, !(rc & 4194240) && (rc = 64), _ } function zc(_) { for (var j = [], $ = 0; 31 > $; $++)j.push(_); return j } function Ac(_, j, $) { _.pendingLanes |= j, j !== 536870912 && (_.suspendedLanes = 0, _.pingedLanes = 0), _ = _.eventTimes, j = 31 - oc(j), _[j] = $ } function Bc(_, j) { var $ = _.pendingLanes & ~j; _.pendingLanes = j, _.suspendedLanes = 0, _.pingedLanes = 0, _.expiredLanes &= j, _.mutableReadLanes &= j, _.entangledLanes &= j, j = _.entanglements; var _e = _.eventTimes; for (_ = _.expirationTimes; 0 < $;) { var et = 31 - oc($), tt = 1 << et; j[et] = 0, _e[et] = -1, _[et] = -1, $ &= ~tt } } function Cc(_, j) { var $ = _.entangledLanes |= j; for (_ = _.entanglements; $;) { var _e = 31 - oc($), et = 1 << _e; et & j | _[_e] & j && (_[_e] |= j), $ &= ~et } } var C = 0; function Dc(_) { return _ &= -_, 1 < _ ? 4 < _ ? _ & 268435455 ? 16 : 536870912 : 4 : 1 } var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Sc(_, j) { switch (_) { case "focusin": case "focusout": Lc = null; break; case "dragenter": case "dragleave": Mc = null; break; case "mouseover": case "mouseout": Nc = null; break; case "pointerover": case "pointerout": Oc.delete(j.pointerId); break; case "gotpointercapture": case "lostpointercapture": Pc.delete(j.pointerId) } } function Tc(_, j, $, _e, et, tt) { return _ === null || _.nativeEvent !== tt ? (_ = { blockedOn: j, domEventName: $, eventSystemFlags: _e, nativeEvent: tt, targetContainers: [et] }, j !== null && (j = Cb(j), j !== null && Fc(j)), _) : (_.eventSystemFlags |= _e, j = _.targetContainers, et !== null && j.indexOf(et) === -1 && j.push(et), _) } function Uc(_, j, $, _e, et) { switch (j) { case "focusin": return Lc = Tc(Lc, _, j, $, _e, et), !0; case "dragenter": return Mc = Tc(Mc, _, j, $, _e, et), !0; case "mouseover": return Nc = Tc(Nc, _, j, $, _e, et), !0; case "pointerover": var tt = et.pointerId; return Oc.set(tt, Tc(Oc.get(tt) || null, _, j, $, _e, et)), !0; case "gotpointercapture": return tt = et.pointerId, Pc.set(tt, Tc(Pc.get(tt) || null, _, j, $, _e, et)), !0 }return !1 } function Vc(_) { var j = Wc(_.target); if (j !== null) { var $ = Vb(j); if ($ !== null) { if (j = $.tag, j === 13) { if (j = Wb($), j !== null) { _.blockedOn = j, Ic(_.priority, function () { Gc($) }); return } } else if (j === 3 && $.stateNode.current.memoizedState.isDehydrated) { _.blockedOn = $.tag === 3 ? $.stateNode.containerInfo : null; return } } } _.blockedOn = null } function Xc(_) { if (_.blockedOn !== null) return !1; for (var j = _.targetContainers; 0 < j.length;) { var $ = Yc(_.domEventName, _.eventSystemFlags, j[0], _.nativeEvent); if ($ === null) { $ = _.nativeEvent; var _e = new $.constructor($.type, $); wb = _e, $.target.dispatchEvent(_e), wb = null } else return j = Cb($), j !== null && Fc(j), _.blockedOn = $, !1; j.shift() } return !0 } function Zc(_, j, $) { Xc(_) && $.delete(j) } function $c() { Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc) } function ad(_, j) { _.blockedOn === j && (_.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c))) } function bd(_) { function j(et) { return ad(et, _) } if (0 < Kc.length) { ad(Kc[0], _); for (var $ = 1; $ < Kc.length; $++) { var _e = Kc[$]; _e.blockedOn === _ && (_e.blockedOn = null) } } for (Lc !== null && ad(Lc, _), Mc !== null && ad(Mc, _), Nc !== null && ad(Nc, _), Oc.forEach(j), Pc.forEach(j), $ = 0; $ < Qc.length; $++)_e = Qc[$], _e.blockedOn === _ && (_e.blockedOn = null); for (; 0 < Qc.length && ($ = Qc[0], $.blockedOn === null);)Vc($), $.blockedOn === null && Qc.shift() } var cd = ua.ReactCurrentBatchConfig, dd = !0; function ed(_, j, $, _e) { var et = C, tt = cd.transition; cd.transition = null; try { C = 1, fd(_, j, $, _e) } finally { C = et, cd.transition = tt } } function gd(_, j, $, _e) { var et = C, tt = cd.transition; cd.transition = null; try { C = 4, fd(_, j, $, _e) } finally { C = et, cd.transition = tt } } function fd(_, j, $, _e) { if (dd) { var et = Yc(_, j, $, _e); if (et === null) hd(_, j, _e, id$2, $), Sc(_, _e); else if (Uc(et, _, j, $, _e)) _e.stopPropagation(); else if (Sc(_, _e), j & 4 && -1 < Rc.indexOf(_)) { for (; et !== null;) { var tt = Cb(et); if (tt !== null && Ec(tt), tt = Yc(_, j, $, _e), tt === null && hd(_, j, _e, id$2, $), tt === et) break; et = tt } et !== null && _e.stopPropagation() } else hd(_, j, _e, null, $) } } var id$2 = null; function Yc(_, j, $, _e) { if (id$2 = null, _ = xb(_e), _ = Wc(_), _ !== null) if (j = Vb(_), j === null) _ = null; else if ($ = j.tag, $ === 13) { if (_ = Wb(j), _ !== null) return _; _ = null } else if ($ === 3) { if (j.stateNode.current.memoizedState.isDehydrated) return j.tag === 3 ? j.stateNode.containerInfo : null; _ = null } else j !== _ && (_ = null); return id$2 = _, null } function jd(_) { switch (_) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (ec()) { case fc: return 1; case gc: return 4; case hc: case ic: return 16; case jc: return 536870912; default: return 16 }default: return 16 } } var kd = null, ld = null, md = null; function nd() { if (md) return md; var _, j = ld, $ = j.length, _e, et = "value" in kd ? kd.value : kd.textContent, tt = et.length; for (_ = 0; _ < $ && j[_] === et[_]; _++); var rt = $ - _; for (_e = 1; _e <= rt && j[$ - _e] === et[tt - _e]; _e++); return md = et.slice(_, 1 < _e ? 1 - _e : void 0) } function od(_) { var j = _.keyCode; return "charCode" in _ ? (_ = _.charCode, _ === 0 && j === 13 && (_ = 13)) : _ = j, _ === 10 && (_ = 13), 32 <= _ || _ === 13 ? _ : 0 } function pd() { return !0 } function qd() { return !1 } function rd(_) { function j($, _e, et, tt, rt) { this._reactName = $, this._targetInst = et, this.type = _e, this.nativeEvent = tt, this.target = rt, this.currentTarget = null; for (var nt in _) _.hasOwnProperty(nt) && ($ = _[nt], this[nt] = $ ? $(tt) : tt[nt]); return this.isDefaultPrevented = (tt.defaultPrevented != null ? tt.defaultPrevented : tt.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this } return A$1(j.prototype, { preventDefault: function () { this.defaultPrevented = !0; var $ = this.nativeEvent; $ && ($.preventDefault ? $.preventDefault() : typeof $.returnValue != "unknown" && ($.returnValue = !1), this.isDefaultPrevented = pd) }, stopPropagation: function () { var $ = this.nativeEvent; $ && ($.stopPropagation ? $.stopPropagation() : typeof $.cancelBubble != "unknown" && ($.cancelBubble = !0), this.isPropagationStopped = pd) }, persist: function () { }, isPersistent: pd }), j } var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (_) { return _.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function (_) { return _.relatedTarget === void 0 ? _.fromElement === _.srcElement ? _.toElement : _.fromElement : _.relatedTarget }, movementX: function (_) { return "movementX" in _ ? _.movementX : (_ !== yd && (yd && _.type === "mousemove" ? (wd = _.screenX - yd.screenX, xd = _.screenY - yd.screenY) : xd = wd = 0, yd = _), wd) }, movementY: function (_) { return "movementY" in _ ? _.movementY : xd } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function (_) { return "clipboardData" in _ ? _.clipboardData : window.clipboardData } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Nd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Pd(_) { var j = this.nativeEvent; return j.getModifierState ? j.getModifierState(_) : (_ = Od[_]) ? !!j[_] : !1 } function zd() { return Pd } var Qd = A$1({}, ud, { key: function (_) { if (_.key) { var j = Md[_.key] || _.key; if (j !== "Unidentified") return j } return _.type === "keypress" ? (_ = od(_), _ === 13 ? "Enter" : String.fromCharCode(_)) : _.type === "keydown" || _.type === "keyup" ? Nd[_.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function (_) { return _.type === "keypress" ? od(_) : 0 }, keyCode: function (_) { return _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0 }, which: function (_) { return _.type === "keypress" ? od(_) : _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0 } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, { deltaX: function (_) { return "deltaX" in _ ? _.deltaX : "wheelDeltaX" in _ ? -_.wheelDeltaX : 0 }, deltaY: function (_) { return "deltaY" in _ ? _.deltaY : "wheelDeltaY" in _ ? -_.wheelDeltaY : "wheelDelta" in _ ? -_.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null; ia && "documentMode" in document && (be = document.documentMode); var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = " ", fe = !1; function ge(_, j) { switch (_) { case "keyup": return $d.indexOf(j.keyCode) !== -1; case "keydown": return j.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function he(_) { return _ = _.detail, typeof _ == "object" && "data" in _ ? _.data : null } var ie = !1; function je(_, j) { switch (_) { case "compositionend": return he(j); case "keypress": return j.which !== 32 ? null : (fe = !0, ee); case "textInput": return _ = j.data, _ === ee && fe ? null : _; default: return null } } function ke(_, j) { if (ie) return _ === "compositionend" || !ae && ge(_, j) ? (_ = nd(), md = ld = kd = null, ie = !1, _) : null; switch (_) { case "paste": return null; case "keypress": if (!(j.ctrlKey || j.altKey || j.metaKey) || j.ctrlKey && j.altKey) { if (j.char && 1 < j.char.length) return j.char; if (j.which) return String.fromCharCode(j.which) } return null; case "compositionend": return de && j.locale !== "ko" ? null : j.data; default: return null } } var le = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function me(_) { var j = _ && _.nodeName && _.nodeName.toLowerCase(); return j === "input" ? !!le[_.type] : j === "textarea" } function ne(_, j, $, _e) { Eb(_e), j = oe(j, "onChange"), 0 < j.length && ($ = new td("onChange", "change", null, $, _e), _.push({ event: $, listeners: j })) } var pe = null, qe = null; function re(_) { se(_, 0) } function te(_) { var j = ue(_); if (Wa(j)) return _ } function ve(_, j) { if (_ === "change") return j } var we = !1; if (ia) { var xe; if (ia) { var ye = "oninput" in document; if (!ye) { var ze = document.createElement("div"); ze.setAttribute("oninput", "return;"), ye = typeof ze.oninput == "function" } xe = ye } else xe = !1; we = xe && (!document.documentMode || 9 < document.documentMode) } function Ae() { pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null) } function Be(_) { if (_.propertyName === "value" && te(qe)) { var j = []; ne(j, qe, _, xb(_)), Jb(re, j) } } function Ce(_, j, $) { _ === "focusin" ? (Ae(), pe = j, qe = $, pe.attachEvent("onpropertychange", Be)) : _ === "focusout" && Ae() } function De(_) { if (_ === "selectionchange" || _ === "keyup" || _ === "keydown") return te(qe) } function Ee(_, j) { if (_ === "click") return te(j) } function Fe(_, j) { if (_ === "input" || _ === "change") return te(j) } function Ge(_, j) { return _ === j && (_ !== 0 || 1 / _ === 1 / j) || _ !== _ && j !== j } var He = typeof Object.is == "function" ? Object.is : Ge; function Ie(_, j) { if (He(_, j)) return !0; if (typeof _ != "object" || _ === null || typeof j != "object" || j === null) return !1; var $ = Object.keys(_), _e = Object.keys(j); if ($.length !== _e.length) return !1; for (_e = 0; _e < $.length; _e++) { var et = $[_e]; if (!ja.call(j, et) || !He(_[et], j[et])) return !1 } return !0 } function Je(_) { for (; _ && _.firstChild;)_ = _.firstChild; return _ } function Ke(_, j) { var $ = Je(_); _ = 0; for (var _e; $;) { if ($.nodeType === 3) { if (_e = _ + $.textContent.length, _ <= j && _e >= j) return { node: $, offset: j - _ }; _ = _e } e: { for (; $;) { if ($.nextSibling) { $ = $.nextSibling; break e } $ = $.parentNode } $ = void 0 } $ = Je($) } } function Le(_, j) { return _ && j ? _ === j ? !0 : _ && _.nodeType === 3 ? !1 : j && j.nodeType === 3 ? Le(_, j.parentNode) : "contains" in _ ? _.contains(j) : _.compareDocumentPosition ? !!(_.compareDocumentPosition(j) & 16) : !1 : !1 } function Me() { for (var _ = window, j = Xa(); j instanceof _.HTMLIFrameElement;) { try { var $ = typeof j.contentWindow.location.href == "string" } catch { $ = !1 } if ($) _ = j.contentWindow; else break; j = Xa(_.document) } return j } function Ne(_) { var j = _ && _.nodeName && _.nodeName.toLowerCase(); return j && (j === "input" && (_.type === "text" || _.type === "search" || _.type === "tel" || _.type === "url" || _.type === "password") || j === "textarea" || _.contentEditable === "true") } function Oe(_) { var j = Me(), $ = _.focusedElem, _e = _.selectionRange; if (j !== $ && $ && $.ownerDocument && Le($.ownerDocument.documentElement, $)) { if (_e !== null && Ne($)) { if (j = _e.start, _ = _e.end, _ === void 0 && (_ = j), "selectionStart" in $) $.selectionStart = j, $.selectionEnd = Math.min(_, $.value.length); else if (_ = (j = $.ownerDocument || document) && j.defaultView || window, _.getSelection) { _ = _.getSelection(); var et = $.textContent.length, tt = Math.min(_e.start, et); _e = _e.end === void 0 ? tt : Math.min(_e.end, et), !_.extend && tt > _e && (et = _e, _e = tt, tt = et), et = Ke($, tt); var rt = Ke($, _e); et && rt && (_.rangeCount !== 1 || _.anchorNode !== et.node || _.anchorOffset !== et.offset || _.focusNode !== rt.node || _.focusOffset !== rt.offset) && (j = j.createRange(), j.setStart(et.node, et.offset), _.removeAllRanges(), tt > _e ? (_.addRange(j), _.extend(rt.node, rt.offset)) : (j.setEnd(rt.node, rt.offset), _.addRange(j))) } } for (j = [], _ = $; _ = _.parentNode;)_.nodeType === 1 && j.push({ element: _, left: _.scrollLeft, top: _.scrollTop }); for (typeof $.focus == "function" && $.focus(), $ = 0; $ < j.length; $++)_ = j[$], _.element.scrollLeft = _.left, _.element.scrollTop = _.top } } var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = !1; function Ue(_, j, $) { var _e = $.window === $ ? $.document : $.nodeType === 9 ? $ : $.ownerDocument; Te || Qe == null || Qe !== Xa(_e) || (_e = Qe, "selectionStart" in _e && Ne(_e) ? _e = { start: _e.selectionStart, end: _e.selectionEnd } : (_e = (_e.ownerDocument && _e.ownerDocument.defaultView || window).getSelection(), _e = { anchorNode: _e.anchorNode, anchorOffset: _e.anchorOffset, focusNode: _e.focusNode, focusOffset: _e.focusOffset }), Se && Ie(Se, _e) || (Se = _e, _e = oe(Re, "onSelect"), 0 < _e.length && (j = new td("onSelect", "select", null, j, $), _.push({ event: j, listeners: _e }), j.target = Qe))) } function Ve(_, j) { var $ = {}; return $[_.toLowerCase()] = j.toLowerCase(), $["Webkit" + _] = "webkit" + j, $["Moz" + _] = "moz" + j, $ } var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {}; ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition); function Ze(_) { if (Xe[_]) return Xe[_]; if (!We[_]) return _; var j = We[_], $; for ($ in j) if (j.hasOwnProperty($) && $ in Ye) return Xe[_] = j[$]; return _ } var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = new Map, ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ff(_, j) { df.set(_, j), fa(j, [_]) } for (var gf = 0; gf < ef.length; gf++) { var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1); ff(jf, "on" + kf) } ff($e, "onAnimationEnd"); ff(af, "onAnimationIteration"); ff(bf, "onAnimationStart"); ff("dblclick", "onDoubleClick"); ff("focusin", "onFocus"); ff("focusout", "onBlur"); ff(cf, "onTransitionEnd"); ha("onMouseEnter", ["mouseout", "mouseover"]); ha("onMouseLeave", ["mouseout", "mouseover"]); ha("onPointerEnter", ["pointerout", "pointerover"]); ha("onPointerLeave", ["pointerout", "pointerover"]); fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf)); function nf(_, j, $) { var _e = _.type || "unknown-event"; _.currentTarget = $, Ub(_e, j, void 0, _), _.currentTarget = null } function se(_, j) { j = (j & 4) !== 0; for (var $ = 0; $ < _.length; $++) { var _e = _[$], et = _e.event; _e = _e.listeners; e: { var tt = void 0; if (j) for (var rt = _e.length - 1; 0 <= rt; rt--) { var nt = _e[rt], it = nt.instance, st = nt.currentTarget; if (nt = nt.listener, it !== tt && et.isPropagationStopped()) break e; nf(et, nt, st), tt = it } else for (rt = 0; rt < _e.length; rt++) { if (nt = _e[rt], it = nt.instance, st = nt.currentTarget, nt = nt.listener, it !== tt && et.isPropagationStopped()) break e; nf(et, nt, st), tt = it } } } if (Qb) throw _ = Rb, Qb = !1, Rb = null, _ } function D(_, j) { var $ = j[of]; $ === void 0 && ($ = j[of] = new Set); var _e = _ + "__bubble"; $.has(_e) || (pf(j, _, 2, !1), $.add(_e)) } function qf(_, j, $) { var _e = 0; j && (_e |= 4), pf($, _, _e, j) } var rf = "_reactListening" + Math.random().toString(36).slice(2); function sf(_) { if (!_[rf]) { _[rf] = !0, da.forEach(function ($) { $ !== "selectionchange" && (mf.has($) || qf($, !1, _), qf($, !0, _)) }); var j = _.nodeType === 9 ? _ : _.ownerDocument; j === null || j[rf] || (j[rf] = !0, qf("selectionchange", !1, j)) } } function pf(_, j, $, _e) { switch (jd(j)) { case 1: var et = ed; break; case 4: et = gd; break; default: et = fd }$ = et.bind(null, j, $, _), et = void 0, !Lb || j !== "touchstart" && j !== "touchmove" && j !== "wheel" || (et = !0), _e ? et !== void 0 ? _.addEventListener(j, $, { capture: !0, passive: et }) : _.addEventListener(j, $, !0) : et !== void 0 ? _.addEventListener(j, $, { passive: et }) : _.addEventListener(j, $, !1) } function hd(_, j, $, _e, et) { var tt = _e; if (!(j & 1) && !(j & 2) && _e !== null) e: for (; ;) { if (_e === null) return; var rt = _e.tag; if (rt === 3 || rt === 4) { var nt = _e.stateNode.containerInfo; if (nt === et || nt.nodeType === 8 && nt.parentNode === et) break; if (rt === 4) for (rt = _e.return; rt !== null;) { var it = rt.tag; if ((it === 3 || it === 4) && (it = rt.stateNode.containerInfo, it === et || it.nodeType === 8 && it.parentNode === et)) return; rt = rt.return } for (; nt !== null;) { if (rt = Wc(nt), rt === null) return; if (it = rt.tag, it === 5 || it === 6) { _e = tt = rt; continue e } nt = nt.parentNode } } _e = _e.return } Jb(function () { var st = tt, ot = xb($), ft = []; e: { var at = df.get(_); if (at !== void 0) { var dt = td, pt = _; switch (_) { case "keypress": if (od($) === 0) break e; case "keydown": case "keyup": dt = Rd; break; case "focusin": pt = "focus", dt = Fd; break; case "focusout": pt = "blur", dt = Fd; break; case "beforeblur": case "afterblur": dt = Fd; break; case "click": if ($.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": dt = Bd; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": dt = Dd; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": dt = Vd; break; case $e: case af: case bf: dt = Hd; break; case cf: dt = Xd; break; case "scroll": dt = vd; break; case "wheel": dt = Zd; break; case "copy": case "cut": case "paste": dt = Jd; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": dt = Td }var ht = (j & 4) !== 0, xt = !ht && _ === "scroll", ct = ht ? at !== null ? at + "Capture" : null : at; ht = []; for (var ut = st, lt; ut !== null;) { lt = ut; var mt = lt.stateNode; if (lt.tag === 5 && mt !== null && (lt = mt, ct !== null && (mt = Kb(ut, ct), mt != null && ht.push(tf(ut, mt, lt)))), xt) break; ut = ut.return } 0 < ht.length && (at = new dt(at, pt, null, $, ot), ft.push({ event: at, listeners: ht })) } } if (!(j & 7)) { e: { if (at = _ === "mouseover" || _ === "pointerover", dt = _ === "mouseout" || _ === "pointerout", at && $ !== wb && (pt = $.relatedTarget || $.fromElement) && (Wc(pt) || pt[uf])) break e; if ((dt || at) && (at = ot.window === ot ? ot : (at = ot.ownerDocument) ? at.defaultView || at.parentWindow : window, dt ? (pt = $.relatedTarget || $.toElement, dt = st, pt = pt ? Wc(pt) : null, pt !== null && (xt = Vb(pt), pt !== xt || pt.tag !== 5 && pt.tag !== 6) && (pt = null)) : (dt = null, pt = st), dt !== pt)) { if (ht = Bd, mt = "onMouseLeave", ct = "onMouseEnter", ut = "mouse", (_ === "pointerout" || _ === "pointerover") && (ht = Td, mt = "onPointerLeave", ct = "onPointerEnter", ut = "pointer"), xt = dt == null ? at : ue(dt), lt = pt == null ? at : ue(pt), at = new ht(mt, ut + "leave", dt, $, ot), at.target = xt, at.relatedTarget = lt, mt = null, Wc(ot) === st && (ht = new ht(ct, ut + "enter", pt, $, ot), ht.target = lt, ht.relatedTarget = xt, mt = ht), xt = mt, dt && pt) t: { for (ht = dt, ct = pt, ut = 0, lt = ht; lt; lt = vf(lt))ut++; for (lt = 0, mt = ct; mt; mt = vf(mt))lt++; for (; 0 < ut - lt;)ht = vf(ht), ut--; for (; 0 < lt - ut;)ct = vf(ct), lt--; for (; ut--;) { if (ht === ct || ct !== null && ht === ct.alternate) break t; ht = vf(ht), ct = vf(ct) } ht = null } else ht = null; dt !== null && wf(ft, at, dt, ht, !1), pt !== null && xt !== null && wf(ft, xt, pt, ht, !0) } } e: { if (at = st ? ue(st) : window, dt = at.nodeName && at.nodeName.toLowerCase(), dt === "select" || dt === "input" && at.type === "file") var yt = ve; else if (me(at)) if (we) yt = Fe; else { yt = De; var gt = Ce } else (dt = at.nodeName) && dt.toLowerCase() === "input" && (at.type === "checkbox" || at.type === "radio") && (yt = Ee); if (yt && (yt = yt(_, st))) { ne(ft, yt, $, ot); break e } gt && gt(_, at, st), _ === "focusout" && (gt = at._wrapperState) && gt.controlled && at.type === "number" && cb(at, "number", at.value) } switch (gt = st ? ue(st) : window, _) { case "focusin": (me(gt) || gt.contentEditable === "true") && (Qe = gt, Re = st, Se = null); break; case "focusout": Se = Re = Qe = null; break; case "mousedown": Te = !0; break; case "contextmenu": case "mouseup": case "dragend": Te = !1, Ue(ft, $, ot); break; case "selectionchange": if (Pe) break; case "keydown": case "keyup": Ue(ft, $, ot) }var St; if (ae) e: { switch (_) { case "compositionstart": var bt = "onCompositionStart"; break e; case "compositionend": bt = "onCompositionEnd"; break e; case "compositionupdate": bt = "onCompositionUpdate"; break e }bt = void 0 } else ie ? ge(_, $) && (bt = "onCompositionEnd") : _ === "keydown" && $.keyCode === 229 && (bt = "onCompositionStart"); bt && (de && $.locale !== "ko" && (ie || bt !== "onCompositionStart" ? bt === "onCompositionEnd" && ie && (St = nd()) : (kd = ot, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), gt = oe(st, bt), 0 < gt.length && (bt = new Ld(bt, _, null, $, ot), ft.push({ event: bt, listeners: gt }), St ? bt.data = St : (St = he($), St !== null && (bt.data = St)))), (St = ce ? je(_, $) : ke(_, $)) && (st = oe(st, "onBeforeInput"), 0 < st.length && (ot = new Ld("onBeforeInput", "beforeinput", null, $, ot), ft.push({ event: ot, listeners: st }), ot.data = St)) } se(ft, j) }) } function tf(_, j, $) { return { instance: _, listener: j, currentTarget: $ } } function oe(_, j) { for (var $ = j + "Capture", _e = []; _ !== null;) { var et = _, tt = et.stateNode; et.tag === 5 && tt !== null && (et = tt, tt = Kb(_, $), tt != null && _e.unshift(tf(_, tt, et)), tt = Kb(_, j), tt != null && _e.push(tf(_, tt, et))), _ = _.return } return _e } function vf(_) { if (_ === null) return null; do _ = _.return; while (_ && _.tag !== 5); return _ || null } function wf(_, j, $, _e, et) { for (var tt = j._reactName, rt = []; $ !== null && $ !== _e;) { var nt = $, it = nt.alternate, st = nt.stateNode; if (it !== null && it === _e) break; nt.tag === 5 && st !== null && (nt = st, et ? (it = Kb($, tt), it != null && rt.unshift(tf($, it, nt))) : et || (it = Kb($, tt), it != null && rt.push(tf($, it, nt)))), $ = $.return } rt.length !== 0 && _.push({ event: j, listeners: rt }) } var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g; function zf(_) {
  return (typeof _ == "string" ? _ : "" + _).replace(xf, `
`).replace(yf, "")
} function Af(_, j, $) { if (j = zf(j), zf(_) !== j && $) throw Error(p$3(425)) } function Bf() { } var Cf = null, Df = null; function Ef(_, j) { return _ === "textarea" || _ === "noscript" || typeof j.children == "string" || typeof j.children == "number" || typeof j.dangerouslySetInnerHTML == "object" && j.dangerouslySetInnerHTML !== null && j.dangerouslySetInnerHTML.__html != null } var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function (_) { return Hf.resolve(null).then(_).catch(If) } : Ff; function If(_) { setTimeout(function () { throw _ }) } function Kf(_, j) { var $ = j, _e = 0; do { var et = $.nextSibling; if (_.removeChild($), et && et.nodeType === 8) if ($ = et.data, $ === "/$") { if (_e === 0) { _.removeChild(et), bd(j); return } _e-- } else $ !== "$" && $ !== "$?" && $ !== "$!" || _e++; $ = et } while ($); bd(j) } function Lf(_) { for (; _ != null; _ = _.nextSibling) { var j = _.nodeType; if (j === 1 || j === 3) break; if (j === 8) { if (j = _.data, j === "$" || j === "$!" || j === "$?") break; if (j === "/$") return null } } return _ } function Mf(_) { _ = _.previousSibling; for (var j = 0; _;) { if (_.nodeType === 8) { var $ = _.data; if ($ === "$" || $ === "$!" || $ === "$?") { if (j === 0) return _; j-- } else $ === "/$" && j++ } _ = _.previousSibling } return null } var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf; function Wc(_) { var j = _[Of]; if (j) return j; for (var $ = _.parentNode; $;) { if (j = $[uf] || $[Of]) { if ($ = j.alternate, j.child !== null || $ !== null && $.child !== null) for (_ = Mf(_); _ !== null;) { if ($ = _[Of]) return $; _ = Mf(_) } return j } _ = $, $ = _.parentNode } return null } function Cb(_) { return _ = _[Of] || _[uf], !_ || _.tag !== 5 && _.tag !== 6 && _.tag !== 13 && _.tag !== 3 ? null : _ } function ue(_) { if (_.tag === 5 || _.tag === 6) return _.stateNode; throw Error(p$3(33)) } function Db(_) { return _[Pf] || null } var Sf = [], Tf = -1; function Uf(_) { return { current: _ } } function E(_) { 0 > Tf || (_.current = Sf[Tf], Sf[Tf] = null, Tf--) } function G(_, j) { Tf++, Sf[Tf] = _.current, _.current = j } var Vf = {}, H = Uf(Vf), Wf = Uf(!1), Xf = Vf; function Yf(_, j) { var $ = _.type.contextTypes; if (!$) return Vf; var _e = _.stateNode; if (_e && _e.__reactInternalMemoizedUnmaskedChildContext === j) return _e.__reactInternalMemoizedMaskedChildContext; var et = {}, tt; for (tt in $) et[tt] = j[tt]; return _e && (_ = _.stateNode, _.__reactInternalMemoizedUnmaskedChildContext = j, _.__reactInternalMemoizedMaskedChildContext = et), et } function Zf(_) { return _ = _.childContextTypes, _ != null } function $f() { E(Wf), E(H) } function ag(_, j, $) { if (H.current !== Vf) throw Error(p$3(168)); G(H, j), G(Wf, $) } function bg(_, j, $) { var _e = _.stateNode; if (j = j.childContextTypes, typeof _e.getChildContext != "function") return $; _e = _e.getChildContext(); for (var et in _e) if (!(et in j)) throw Error(p$3(108, Ra(_) || "Unknown", et)); return A$1({}, $, _e) } function cg(_) { return _ = (_ = _.stateNode) && _.__reactInternalMemoizedMergedChildContext || Vf, Xf = H.current, G(H, _), G(Wf, Wf.current), !0 } function dg(_, j, $) { var _e = _.stateNode; if (!_e) throw Error(p$3(169)); $ ? (_ = bg(_, j, Xf), _e.__reactInternalMemoizedMergedChildContext = _, E(Wf), E(H), G(H, _)) : E(Wf), G(Wf, $) } var eg = null, fg = !1, gg = !1; function hg(_) { eg === null ? eg = [_] : eg.push(_) } function ig(_) { fg = !0, hg(_) } function jg() { if (!gg && eg !== null) { gg = !0; var _ = 0, j = C; try { var $ = eg; for (C = 1; _ < $.length; _++) { var _e = $[_]; do _e = _e(!0); while (_e !== null) } eg = null, fg = !1 } catch (et) { throw eg !== null && (eg = eg.slice(_ + 1)), ac(fc, jg), et } finally { C = j, gg = !1 } } return null } var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = ""; function tg(_, j) { kg[lg++] = ng, kg[lg++] = mg, mg = _, ng = j } function ug(_, j, $) { og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = _; var _e = rg; _ = sg; var et = 32 - oc(_e) - 1; _e &= ~(1 << et), $ += 1; var tt = 32 - oc(j) + et; if (30 < tt) { var rt = et - et % 5; tt = (_e & (1 << rt) - 1).toString(32), _e >>= rt, et -= rt, rg = 1 << 32 - oc(j) + et | $ << et | _e, sg = tt + _ } else rg = 1 << tt | $ << et | _e, sg = _ } function vg(_) { _.return !== null && (tg(_, 1), ug(_, 1, 0)) } function wg(_) { for (; _ === mg;)mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null; for (; _ === qg;)qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null } var xg = null, yg = null, I = !1, zg = null; function Ag(_, j) { var $ = Bg(5, null, null, 0); $.elementType = "DELETED", $.stateNode = j, $.return = _, j = _.deletions, j === null ? (_.deletions = [$], _.flags |= 16) : j.push($) } function Cg(_, j) { switch (_.tag) { case 5: var $ = _.type; return j = j.nodeType !== 1 || $.toLowerCase() !== j.nodeName.toLowerCase() ? null : j, j !== null ? (_.stateNode = j, xg = _, yg = Lf(j.firstChild), !0) : !1; case 6: return j = _.pendingProps === "" || j.nodeType !== 3 ? null : j, j !== null ? (_.stateNode = j, xg = _, yg = null, !0) : !1; case 13: return j = j.nodeType !== 8 ? null : j, j !== null ? ($ = qg !== null ? { id: rg, overflow: sg } : null, _.memoizedState = { dehydrated: j, treeContext: $, retryLane: 1073741824 }, $ = Bg(18, null, null, 0), $.stateNode = j, $.return = _, _.child = $, xg = _, yg = null, !0) : !1; default: return !1 } } function Dg(_) { return (_.mode & 1) !== 0 && (_.flags & 128) === 0 } function Eg(_) { if (I) { var j = yg; if (j) { var $ = j; if (!Cg(_, j)) { if (Dg(_)) throw Error(p$3(418)); j = Lf($.nextSibling); var _e = xg; j && Cg(_, j) ? Ag(_e, $) : (_.flags = _.flags & -4097 | 2, I = !1, xg = _) } } else { if (Dg(_)) throw Error(p$3(418)); _.flags = _.flags & -4097 | 2, I = !1, xg = _ } } } function Fg(_) { for (_ = _.return; _ !== null && _.tag !== 5 && _.tag !== 3 && _.tag !== 13;)_ = _.return; xg = _ } function Gg(_) { if (_ !== xg) return !1; if (!I) return Fg(_), I = !0, !1; var j; if ((j = _.tag !== 3) && !(j = _.tag !== 5) && (j = _.type, j = j !== "head" && j !== "body" && !Ef(_.type, _.memoizedProps)), j && (j = yg)) { if (Dg(_)) throw Hg(), Error(p$3(418)); for (; j;)Ag(_, j), j = Lf(j.nextSibling) } if (Fg(_), _.tag === 13) { if (_ = _.memoizedState, _ = _ !== null ? _.dehydrated : null, !_) throw Error(p$3(317)); e: { for (_ = _.nextSibling, j = 0; _;) { if (_.nodeType === 8) { var $ = _.data; if ($ === "/$") { if (j === 0) { yg = Lf(_.nextSibling); break e } j-- } else $ !== "$" && $ !== "$!" && $ !== "$?" || j++ } _ = _.nextSibling } yg = null } } else yg = xg ? Lf(_.stateNode.nextSibling) : null; return !0 } function Hg() { for (var _ = yg; _;)_ = Lf(_.nextSibling) } function Ig() { yg = xg = null, I = !1 } function Jg(_) { zg === null ? zg = [_] : zg.push(_) } var Kg = ua.ReactCurrentBatchConfig; function Lg(_, j) { if (_ && _.defaultProps) { j = A$1({}, j), _ = _.defaultProps; for (var $ in _) j[$] === void 0 && (j[$] = _[$]); return j } return j } var Mg = Uf(null), Ng = null, Og = null, Pg = null; function Qg() { Pg = Og = Ng = null } function Rg(_) { var j = Mg.current; E(Mg), _._currentValue = j } function Sg(_, j, $) { for (; _ !== null;) { var _e = _.alternate; if ((_.childLanes & j) !== j ? (_.childLanes |= j, _e !== null && (_e.childLanes |= j)) : _e !== null && (_e.childLanes & j) !== j && (_e.childLanes |= j), _ === $) break; _ = _.return } } function Tg(_, j) { Ng = _, Pg = Og = null, _ = _.dependencies, _ !== null && _.firstContext !== null && (_.lanes & j && (Ug = !0), _.firstContext = null) } function Vg(_) { var j = _._currentValue; if (Pg !== _) if (_ = { context: _, memoizedValue: j, next: null }, Og === null) { if (Ng === null) throw Error(p$3(308)); Og = _, Ng.dependencies = { lanes: 0, firstContext: _ } } else Og = Og.next = _; return j } var Wg = null; function Xg(_) { Wg === null ? Wg = [_] : Wg.push(_) } function Yg(_, j, $, _e) { var et = j.interleaved; return et === null ? ($.next = $, Xg(j)) : ($.next = et.next, et.next = $), j.interleaved = $, Zg(_, _e) } function Zg(_, j) { _.lanes |= j; var $ = _.alternate; for ($ !== null && ($.lanes |= j), $ = _, _ = _.return; _ !== null;)_.childLanes |= j, $ = _.alternate, $ !== null && ($.childLanes |= j), $ = _, _ = _.return; return $.tag === 3 ? $.stateNode : null } var $g = !1; function ah(_) { _.updateQueue = { baseState: _.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function bh(_, j) { _ = _.updateQueue, j.updateQueue === _ && (j.updateQueue = { baseState: _.baseState, firstBaseUpdate: _.firstBaseUpdate, lastBaseUpdate: _.lastBaseUpdate, shared: _.shared, effects: _.effects }) } function ch(_, j) { return { eventTime: _, lane: j, tag: 0, payload: null, callback: null, next: null } } function dh(_, j, $) { var _e = _.updateQueue; if (_e === null) return null; if (_e = _e.shared, K & 2) { var et = _e.pending; return et === null ? j.next = j : (j.next = et.next, et.next = j), _e.pending = j, Zg(_, $) } return et = _e.interleaved, et === null ? (j.next = j, Xg(_e)) : (j.next = et.next, et.next = j), _e.interleaved = j, Zg(_, $) } function eh(_, j, $) { if (j = j.updateQueue, j !== null && (j = j.shared, ($ & 4194240) !== 0)) { var _e = j.lanes; _e &= _.pendingLanes, $ |= _e, j.lanes = $, Cc(_, $) } } function fh(_, j) { var $ = _.updateQueue, _e = _.alternate; if (_e !== null && (_e = _e.updateQueue, $ === _e)) { var et = null, tt = null; if ($ = $.firstBaseUpdate, $ !== null) { do { var rt = { eventTime: $.eventTime, lane: $.lane, tag: $.tag, payload: $.payload, callback: $.callback, next: null }; tt === null ? et = tt = rt : tt = tt.next = rt, $ = $.next } while ($ !== null); tt === null ? et = tt = j : tt = tt.next = j } else et = tt = j; $ = { baseState: _e.baseState, firstBaseUpdate: et, lastBaseUpdate: tt, shared: _e.shared, effects: _e.effects }, _.updateQueue = $; return } _ = $.lastBaseUpdate, _ === null ? $.firstBaseUpdate = j : _.next = j, $.lastBaseUpdate = j } function gh(_, j, $, _e) { var et = _.updateQueue; $g = !1; var tt = et.firstBaseUpdate, rt = et.lastBaseUpdate, nt = et.shared.pending; if (nt !== null) { et.shared.pending = null; var it = nt, st = it.next; it.next = null, rt === null ? tt = st : rt.next = st, rt = it; var ot = _.alternate; ot !== null && (ot = ot.updateQueue, nt = ot.lastBaseUpdate, nt !== rt && (nt === null ? ot.firstBaseUpdate = st : nt.next = st, ot.lastBaseUpdate = it)) } if (tt !== null) { var ft = et.baseState; rt = 0, ot = st = it = null, nt = tt; do { var at = nt.lane, dt = nt.eventTime; if ((_e & at) === at) { ot !== null && (ot = ot.next = { eventTime: dt, lane: 0, tag: nt.tag, payload: nt.payload, callback: nt.callback, next: null }); e: { var pt = _, ht = nt; switch (at = j, dt = $, ht.tag) { case 1: if (pt = ht.payload, typeof pt == "function") { ft = pt.call(dt, ft, at); break e } ft = pt; break e; case 3: pt.flags = pt.flags & -65537 | 128; case 0: if (pt = ht.payload, at = typeof pt == "function" ? pt.call(dt, ft, at) : pt, at == null) break e; ft = A$1({}, ft, at); break e; case 2: $g = !0 } } nt.callback !== null && nt.lane !== 0 && (_.flags |= 64, at = et.effects, at === null ? et.effects = [nt] : at.push(nt)) } else dt = { eventTime: dt, lane: at, tag: nt.tag, payload: nt.payload, callback: nt.callback, next: null }, ot === null ? (st = ot = dt, it = ft) : ot = ot.next = dt, rt |= at; if (nt = nt.next, nt === null) { if (nt = et.shared.pending, nt === null) break; at = nt, nt = at.next, at.next = null, et.lastBaseUpdate = at, et.shared.pending = null } } while (!0); if (ot === null && (it = ft), et.baseState = it, et.firstBaseUpdate = st, et.lastBaseUpdate = ot, j = et.shared.interleaved, j !== null) { et = j; do rt |= et.lane, et = et.next; while (et !== j) } else tt === null && (et.shared.lanes = 0); hh |= rt, _.lanes = rt, _.memoizedState = ft } } function ih(_, j, $) { if (_ = j.effects, j.effects = null, _ !== null) for (j = 0; j < _.length; j++) { var _e = _[j], et = _e.callback; if (et !== null) { if (_e.callback = null, _e = $, typeof et != "function") throw Error(p$3(191, et)); et.call(_e) } } } var jh = new aa.Component().refs; function kh(_, j, $, _e) { j = _.memoizedState, $ = $(_e, j), $ = $ == null ? j : A$1({}, j, $), _.memoizedState = $, _.lanes === 0 && (_.updateQueue.baseState = $) } var nh = { isMounted: function (_) { return (_ = _._reactInternals) ? Vb(_) === _ : !1 }, enqueueSetState: function (_, j, $) { _ = _._reactInternals; var _e = L(), et = lh(_), tt = ch(_e, et); tt.payload = j, $ != null && (tt.callback = $), j = dh(_, tt, et), j !== null && (mh(j, _, et, _e), eh(j, _, et)) }, enqueueReplaceState: function (_, j, $) { _ = _._reactInternals; var _e = L(), et = lh(_), tt = ch(_e, et); tt.tag = 1, tt.payload = j, $ != null && (tt.callback = $), j = dh(_, tt, et), j !== null && (mh(j, _, et, _e), eh(j, _, et)) }, enqueueForceUpdate: function (_, j) { _ = _._reactInternals; var $ = L(), _e = lh(_), et = ch($, _e); et.tag = 2, j != null && (et.callback = j), j = dh(_, et, _e), j !== null && (mh(j, _, _e, $), eh(j, _, _e)) } }; function oh(_, j, $, _e, et, tt, rt) { return _ = _.stateNode, typeof _.shouldComponentUpdate == "function" ? _.shouldComponentUpdate(_e, tt, rt) : j.prototype && j.prototype.isPureReactComponent ? !Ie($, _e) || !Ie(et, tt) : !0 } function ph(_, j, $) { var _e = !1, et = Vf, tt = j.contextType; return typeof tt == "object" && tt !== null ? tt = Vg(tt) : (et = Zf(j) ? Xf : H.current, _e = j.contextTypes, tt = (_e = _e != null) ? Yf(_, et) : Vf), j = new j($, tt), _.memoizedState = j.state !== null && j.state !== void 0 ? j.state : null, j.updater = nh, _.stateNode = j, j._reactInternals = _, _e && (_ = _.stateNode, _.__reactInternalMemoizedUnmaskedChildContext = et, _.__reactInternalMemoizedMaskedChildContext = tt), j } function qh(_, j, $, _e) { _ = j.state, typeof j.componentWillReceiveProps == "function" && j.componentWillReceiveProps($, _e), typeof j.UNSAFE_componentWillReceiveProps == "function" && j.UNSAFE_componentWillReceiveProps($, _e), j.state !== _ && nh.enqueueReplaceState(j, j.state, null) } function rh(_, j, $, _e) { var et = _.stateNode; et.props = $, et.state = _.memoizedState, et.refs = jh, ah(_); var tt = j.contextType; typeof tt == "object" && tt !== null ? et.context = Vg(tt) : (tt = Zf(j) ? Xf : H.current, et.context = Yf(_, tt)), et.state = _.memoizedState, tt = j.getDerivedStateFromProps, typeof tt == "function" && (kh(_, j, tt, $), et.state = _.memoizedState), typeof j.getDerivedStateFromProps == "function" || typeof et.getSnapshotBeforeUpdate == "function" || typeof et.UNSAFE_componentWillMount != "function" && typeof et.componentWillMount != "function" || (j = et.state, typeof et.componentWillMount == "function" && et.componentWillMount(), typeof et.UNSAFE_componentWillMount == "function" && et.UNSAFE_componentWillMount(), j !== et.state && nh.enqueueReplaceState(et, et.state, null), gh(_, $, et, _e), et.state = _.memoizedState), typeof et.componentDidMount == "function" && (_.flags |= 4194308) } function sh(_, j, $) { if (_ = $.ref, _ !== null && typeof _ != "function" && typeof _ != "object") { if ($._owner) { if ($ = $._owner, $) { if ($.tag !== 1) throw Error(p$3(309)); var _e = $.stateNode } if (!_e) throw Error(p$3(147, _)); var et = _e, tt = "" + _; return j !== null && j.ref !== null && typeof j.ref == "function" && j.ref._stringRef === tt ? j.ref : (j = function (rt) { var nt = et.refs; nt === jh && (nt = et.refs = {}), rt === null ? delete nt[tt] : nt[tt] = rt }, j._stringRef = tt, j) } if (typeof _ != "string") throw Error(p$3(284)); if (!$._owner) throw Error(p$3(290, _)) } return _ } function th(_, j) { throw _ = Object.prototype.toString.call(j), Error(p$3(31, _ === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : _)) } function uh(_) { var j = _._init; return j(_._payload) } function vh$1(_) { function j(ct, ut) { if (_) { var lt = ct.deletions; lt === null ? (ct.deletions = [ut], ct.flags |= 16) : lt.push(ut) } } function $(ct, ut) { if (!_) return null; for (; ut !== null;)j(ct, ut), ut = ut.sibling; return null } function _e(ct, ut) { for (ct = new Map; ut !== null;)ut.key !== null ? ct.set(ut.key, ut) : ct.set(ut.index, ut), ut = ut.sibling; return ct } function et(ct, ut) { return ct = wh(ct, ut), ct.index = 0, ct.sibling = null, ct } function tt(ct, ut, lt) { return ct.index = lt, _ ? (lt = ct.alternate, lt !== null ? (lt = lt.index, lt < ut ? (ct.flags |= 2, ut) : lt) : (ct.flags |= 2, ut)) : (ct.flags |= 1048576, ut) } function rt(ct) { return _ && ct.alternate === null && (ct.flags |= 2), ct } function nt(ct, ut, lt, mt) { return ut === null || ut.tag !== 6 ? (ut = xh(lt, ct.mode, mt), ut.return = ct, ut) : (ut = et(ut, lt), ut.return = ct, ut) } function it(ct, ut, lt, mt) { var yt = lt.type; return yt === ya ? ot(ct, ut, lt.props.children, mt, lt.key) : ut !== null && (ut.elementType === yt || typeof yt == "object" && yt !== null && yt.$$typeof === Ha && uh(yt) === ut.type) ? (mt = et(ut, lt.props), mt.ref = sh(ct, ut, lt), mt.return = ct, mt) : (mt = yh(lt.type, lt.key, lt.props, null, ct.mode, mt), mt.ref = sh(ct, ut, lt), mt.return = ct, mt) } function st(ct, ut, lt, mt) { return ut === null || ut.tag !== 4 || ut.stateNode.containerInfo !== lt.containerInfo || ut.stateNode.implementation !== lt.implementation ? (ut = zh(lt, ct.mode, mt), ut.return = ct, ut) : (ut = et(ut, lt.children || []), ut.return = ct, ut) } function ot(ct, ut, lt, mt, yt) { return ut === null || ut.tag !== 7 ? (ut = Ah(lt, ct.mode, mt, yt), ut.return = ct, ut) : (ut = et(ut, lt), ut.return = ct, ut) } function ft(ct, ut, lt) { if (typeof ut == "string" && ut !== "" || typeof ut == "number") return ut = xh("" + ut, ct.mode, lt), ut.return = ct, ut; if (typeof ut == "object" && ut !== null) { switch (ut.$$typeof) { case va: return lt = yh(ut.type, ut.key, ut.props, null, ct.mode, lt), lt.ref = sh(ct, null, ut), lt.return = ct, lt; case wa: return ut = zh(ut, ct.mode, lt), ut.return = ct, ut; case Ha: var mt = ut._init; return ft(ct, mt(ut._payload), lt) }if (eb(ut) || Ka(ut)) return ut = Ah(ut, ct.mode, lt, null), ut.return = ct, ut; th(ct, ut) } return null } function at(ct, ut, lt, mt) { var yt = ut !== null ? ut.key : null; if (typeof lt == "string" && lt !== "" || typeof lt == "number") return yt !== null ? null : nt(ct, ut, "" + lt, mt); if (typeof lt == "object" && lt !== null) { switch (lt.$$typeof) { case va: return lt.key === yt ? it(ct, ut, lt, mt) : null; case wa: return lt.key === yt ? st(ct, ut, lt, mt) : null; case Ha: return yt = lt._init, at(ct, ut, yt(lt._payload), mt) }if (eb(lt) || Ka(lt)) return yt !== null ? null : ot(ct, ut, lt, mt, null); th(ct, lt) } return null } function dt(ct, ut, lt, mt, yt) { if (typeof mt == "string" && mt !== "" || typeof mt == "number") return ct = ct.get(lt) || null, nt(ut, ct, "" + mt, yt); if (typeof mt == "object" && mt !== null) { switch (mt.$$typeof) { case va: return ct = ct.get(mt.key === null ? lt : mt.key) || null, it(ut, ct, mt, yt); case wa: return ct = ct.get(mt.key === null ? lt : mt.key) || null, st(ut, ct, mt, yt); case Ha: var gt = mt._init; return dt(ct, ut, lt, gt(mt._payload), yt) }if (eb(mt) || Ka(mt)) return ct = ct.get(lt) || null, ot(ut, ct, mt, yt, null); th(ut, mt) } return null } function pt(ct, ut, lt, mt) { for (var yt = null, gt = null, St = ut, bt = ut = 0, _t = null; St !== null && bt < lt.length; bt++) { St.index > bt ? (_t = St, St = null) : _t = St.sibling; var Mt = at(ct, St, lt[bt], mt); if (Mt === null) { St === null && (St = _t); break } _ && St && Mt.alternate === null && j(ct, St), ut = tt(Mt, ut, bt), gt === null ? yt = Mt : gt.sibling = Mt, gt = Mt, St = _t } if (bt === lt.length) return $(ct, St), I && tg(ct, bt), yt; if (St === null) { for (; bt < lt.length; bt++)St = ft(ct, lt[bt], mt), St !== null && (ut = tt(St, ut, bt), gt === null ? yt = St : gt.sibling = St, gt = St); return I && tg(ct, bt), yt } for (St = _e(ct, St); bt < lt.length; bt++)_t = dt(St, ct, bt, lt[bt], mt), _t !== null && (_ && _t.alternate !== null && St.delete(_t.key === null ? bt : _t.key), ut = tt(_t, ut, bt), gt === null ? yt = _t : gt.sibling = _t, gt = _t); return _ && St.forEach(function (It) { return j(ct, It) }), I && tg(ct, bt), yt } function ht(ct, ut, lt, mt) { var yt = Ka(lt); if (typeof yt != "function") throw Error(p$3(150)); if (lt = yt.call(lt), lt == null) throw Error(p$3(151)); for (var gt = yt = null, St = ut, bt = ut = 0, _t = null, Mt = lt.next(); St !== null && !Mt.done; bt++, Mt = lt.next()) { St.index > bt ? (_t = St, St = null) : _t = St.sibling; var It = at(ct, St, Mt.value, mt); if (It === null) { St === null && (St = _t); break } _ && St && It.alternate === null && j(ct, St), ut = tt(It, ut, bt), gt === null ? yt = It : gt.sibling = It, gt = It, St = _t } if (Mt.done) return $(ct, St), I && tg(ct, bt), yt; if (St === null) { for (; !Mt.done; bt++, Mt = lt.next())Mt = ft(ct, Mt.value, mt), Mt !== null && (ut = tt(Mt, ut, bt), gt === null ? yt = Mt : gt.sibling = Mt, gt = Mt); return I && tg(ct, bt), yt } for (St = _e(ct, St); !Mt.done; bt++, Mt = lt.next())Mt = dt(St, ct, bt, Mt.value, mt), Mt !== null && (_ && Mt.alternate !== null && St.delete(Mt.key === null ? bt : Mt.key), ut = tt(Mt, ut, bt), gt === null ? yt = Mt : gt.sibling = Mt, gt = Mt); return _ && St.forEach(function (Rt) { return j(ct, Rt) }), I && tg(ct, bt), yt } function xt(ct, ut, lt, mt) { if (typeof lt == "object" && lt !== null && lt.type === ya && lt.key === null && (lt = lt.props.children), typeof lt == "object" && lt !== null) { switch (lt.$$typeof) { case va: e: { for (var yt = lt.key, gt = ut; gt !== null;) { if (gt.key === yt) { if (yt = lt.type, yt === ya) { if (gt.tag === 7) { $(ct, gt.sibling), ut = et(gt, lt.props.children), ut.return = ct, ct = ut; break e } } else if (gt.elementType === yt || typeof yt == "object" && yt !== null && yt.$$typeof === Ha && uh(yt) === gt.type) { $(ct, gt.sibling), ut = et(gt, lt.props), ut.ref = sh(ct, gt, lt), ut.return = ct, ct = ut; break e } $(ct, gt); break } else j(ct, gt); gt = gt.sibling } lt.type === ya ? (ut = Ah(lt.props.children, ct.mode, mt, lt.key), ut.return = ct, ct = ut) : (mt = yh(lt.type, lt.key, lt.props, null, ct.mode, mt), mt.ref = sh(ct, ut, lt), mt.return = ct, ct = mt) } return rt(ct); case wa: e: { for (gt = lt.key; ut !== null;) { if (ut.key === gt) if (ut.tag === 4 && ut.stateNode.containerInfo === lt.containerInfo && ut.stateNode.implementation === lt.implementation) { $(ct, ut.sibling), ut = et(ut, lt.children || []), ut.return = ct, ct = ut; break e } else { $(ct, ut); break } else j(ct, ut); ut = ut.sibling } ut = zh(lt, ct.mode, mt), ut.return = ct, ct = ut } return rt(ct); case Ha: return gt = lt._init, xt(ct, ut, gt(lt._payload), mt) }if (eb(lt)) return pt(ct, ut, lt, mt); if (Ka(lt)) return ht(ct, ut, lt, mt); th(ct, lt) } return typeof lt == "string" && lt !== "" || typeof lt == "number" ? (lt = "" + lt, ut !== null && ut.tag === 6 ? ($(ct, ut.sibling), ut = et(ut, lt), ut.return = ct, ct = ut) : ($(ct, ut), ut = xh(lt, ct.mode, mt), ut.return = ct, ct = ut), rt(ct)) : $(ct, ut) } return xt } var Bh = vh$1(!0), Ch = vh$1(!1), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh); function Hh(_) { if (_ === Dh) throw Error(p$3(174)); return _ } function Ih(_, j) { switch (G(Gh, j), G(Fh, _), G(Eh, Dh), _ = j.nodeType, _) { case 9: case 11: j = (j = j.documentElement) ? j.namespaceURI : lb(null, ""); break; default: _ = _ === 8 ? j.parentNode : j, j = _.namespaceURI || null, _ = _.tagName, j = lb(j, _) }E(Eh), G(Eh, j) } function Jh() { E(Eh), E(Fh), E(Gh) } function Kh(_) { Hh(Gh.current); var j = Hh(Eh.current), $ = lb(j, _.type); j !== $ && (G(Fh, _), G(Eh, $)) } function Lh(_) { Fh.current === _ && (E(Eh), E(Fh)) } var M = Uf(0); function Mh(_) { for (var j = _; j !== null;) { if (j.tag === 13) { var $ = j.memoizedState; if ($ !== null && ($ = $.dehydrated, $ === null || $.data === "$?" || $.data === "$!")) return j } else if (j.tag === 19 && j.memoizedProps.revealOrder !== void 0) { if (j.flags & 128) return j } else if (j.child !== null) { j.child.return = j, j = j.child; continue } if (j === _) break; for (; j.sibling === null;) { if (j.return === null || j.return === _) return null; j = j.return } j.sibling.return = j.return, j = j.sibling } return null } var Nh = []; function Oh() { for (var _ = 0; _ < Nh.length; _++)Nh[_]._workInProgressVersionPrimary = null; Nh.length = 0 } var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = !1, Th = !1, Uh = 0, Vh = 0; function Q() { throw Error(p$3(321)) } function Wh(_, j) { if (j === null) return !1; for (var $ = 0; $ < j.length && $ < _.length; $++)if (!He(_[$], j[$])) return !1; return !0 } function Xh(_, j, $, _e, et, tt) { if (Rh = tt, N = j, j.memoizedState = null, j.updateQueue = null, j.lanes = 0, Ph.current = _ === null || _.memoizedState === null ? Yh : Zh, _ = $(_e, et), Th) { tt = 0; do { if (Th = !1, Uh = 0, 25 <= tt) throw Error(p$3(301)); tt += 1, P = O = null, j.updateQueue = null, Ph.current = $h, _ = $(_e, et) } while (Th) } if (Ph.current = ai, j = O !== null && O.next !== null, Rh = 0, P = O = N = null, Sh = !1, j) throw Error(p$3(300)); return _ } function bi() { var _ = Uh !== 0; return Uh = 0, _ } function ci() { var _ = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return P === null ? N.memoizedState = P = _ : P = P.next = _, P } function di() { if (O === null) { var _ = N.alternate; _ = _ !== null ? _.memoizedState : null } else _ = O.next; var j = P === null ? N.memoizedState : P.next; if (j !== null) P = j, O = _; else { if (_ === null) throw Error(p$3(310)); O = _, _ = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null }, P === null ? N.memoizedState = P = _ : P = P.next = _ } return P } function ei(_, j) { return typeof j == "function" ? j(_) : j } function fi(_) { var j = di(), $ = j.queue; if ($ === null) throw Error(p$3(311)); $.lastRenderedReducer = _; var _e = O, et = _e.baseQueue, tt = $.pending; if (tt !== null) { if (et !== null) { var rt = et.next; et.next = tt.next, tt.next = rt } _e.baseQueue = et = tt, $.pending = null } if (et !== null) { tt = et.next, _e = _e.baseState; var nt = rt = null, it = null, st = tt; do { var ot = st.lane; if ((Rh & ot) === ot) it !== null && (it = it.next = { lane: 0, action: st.action, hasEagerState: st.hasEagerState, eagerState: st.eagerState, next: null }), _e = st.hasEagerState ? st.eagerState : _(_e, st.action); else { var ft = { lane: ot, action: st.action, hasEagerState: st.hasEagerState, eagerState: st.eagerState, next: null }; it === null ? (nt = it = ft, rt = _e) : it = it.next = ft, N.lanes |= ot, hh |= ot } st = st.next } while (st !== null && st !== tt); it === null ? rt = _e : it.next = nt, He(_e, j.memoizedState) || (Ug = !0), j.memoizedState = _e, j.baseState = rt, j.baseQueue = it, $.lastRenderedState = _e } if (_ = $.interleaved, _ !== null) { et = _; do tt = et.lane, N.lanes |= tt, hh |= tt, et = et.next; while (et !== _) } else et === null && ($.lanes = 0); return [j.memoizedState, $.dispatch] } function gi(_) { var j = di(), $ = j.queue; if ($ === null) throw Error(p$3(311)); $.lastRenderedReducer = _; var _e = $.dispatch, et = $.pending, tt = j.memoizedState; if (et !== null) { $.pending = null; var rt = et = et.next; do tt = _(tt, rt.action), rt = rt.next; while (rt !== et); He(tt, j.memoizedState) || (Ug = !0), j.memoizedState = tt, j.baseQueue === null && (j.baseState = tt), $.lastRenderedState = tt } return [tt, _e] } function hi() { } function ii(_, j) { var $ = N, _e = di(), et = j(), tt = !He(_e.memoizedState, et); if (tt && (_e.memoizedState = et, Ug = !0), _e = _e.queue, ji(ki.bind(null, $, _e, _), [_]), _e.getSnapshot !== j || tt || P !== null && P.memoizedState.tag & 1) { if ($.flags |= 2048, li(9, mi.bind(null, $, _e, et, j), void 0, null), R === null) throw Error(p$3(349)); Rh & 30 || ni($, j, et) } return et } function ni(_, j, $) { _.flags |= 16384, _ = { getSnapshot: j, value: $ }, j = N.updateQueue, j === null ? (j = { lastEffect: null, stores: null }, N.updateQueue = j, j.stores = [_]) : ($ = j.stores, $ === null ? j.stores = [_] : $.push(_)) } function mi(_, j, $, _e) { j.value = $, j.getSnapshot = _e, oi(j) && pi(_) } function ki(_, j, $) { return $(function () { oi(j) && pi(_) }) } function oi(_) { var j = _.getSnapshot; _ = _.value; try { var $ = j(); return !He(_, $) } catch { return !0 } } function pi(_) { var j = Zg(_, 1); j !== null && mh(j, _, 1, -1) } function qi(_) { var j = ci(); return typeof _ == "function" && (_ = _()), j.memoizedState = j.baseState = _, _ = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: _ }, j.queue = _, _ = _.dispatch = ri.bind(null, N, _), [j.memoizedState, _] } function li(_, j, $, _e) { return _ = { tag: _, create: j, destroy: $, deps: _e, next: null }, j = N.updateQueue, j === null ? (j = { lastEffect: null, stores: null }, N.updateQueue = j, j.lastEffect = _.next = _) : ($ = j.lastEffect, $ === null ? j.lastEffect = _.next = _ : (_e = $.next, $.next = _, _.next = _e, j.lastEffect = _)), _ } function si() { return di().memoizedState } function ti(_, j, $, _e) { var et = ci(); N.flags |= _, et.memoizedState = li(1 | j, $, void 0, _e === void 0 ? null : _e) } function ui(_, j, $, _e) { var et = di(); _e = _e === void 0 ? null : _e; var tt = void 0; if (O !== null) { var rt = O.memoizedState; if (tt = rt.destroy, _e !== null && Wh(_e, rt.deps)) { et.memoizedState = li(j, $, tt, _e); return } } N.flags |= _, et.memoizedState = li(1 | j, $, tt, _e) } function vi(_, j) { return ti(8390656, 8, _, j) } function ji(_, j) { return ui(2048, 8, _, j) } function wi(_, j) { return ui(4, 2, _, j) } function xi(_, j) { return ui(4, 4, _, j) } function yi(_, j) { if (typeof j == "function") return _ = _(), j(_), function () { j(null) }; if (j != null) return _ = _(), j.current = _, function () { j.current = null } } function zi(_, j, $) { return $ = $ != null ? $.concat([_]) : null, ui(4, 4, yi.bind(null, j, _), $) } function Ai() { } function Bi(_, j) { var $ = di(); j = j === void 0 ? null : j; var _e = $.memoizedState; return _e !== null && j !== null && Wh(j, _e[1]) ? _e[0] : ($.memoizedState = [_, j], _) } function Ci(_, j) { var $ = di(); j = j === void 0 ? null : j; var _e = $.memoizedState; return _e !== null && j !== null && Wh(j, _e[1]) ? _e[0] : (_ = _(), $.memoizedState = [_, j], _) } function Di(_, j, $) { return Rh & 21 ? (He($, j) || ($ = yc(), N.lanes |= $, hh |= $, _.baseState = !0), j) : (_.baseState && (_.baseState = !1, Ug = !0), _.memoizedState = $) } function Ei(_, j) { var $ = C; C = $ !== 0 && 4 > $ ? $ : 4, _(!0); var _e = Qh.transition; Qh.transition = {}; try { _(!1), j() } finally { C = $, Qh.transition = _e } } function Fi() { return di().memoizedState } function Gi(_, j, $) { var _e = lh(_); if ($ = { lane: _e, action: $, hasEagerState: !1, eagerState: null, next: null }, Hi(_)) Ii(j, $); else if ($ = Yg(_, j, $, _e), $ !== null) { var et = L(); mh($, _, _e, et), Ji($, j, _e) } } function ri(_, j, $) { var _e = lh(_), et = { lane: _e, action: $, hasEagerState: !1, eagerState: null, next: null }; if (Hi(_)) Ii(j, et); else { var tt = _.alternate; if (_.lanes === 0 && (tt === null || tt.lanes === 0) && (tt = j.lastRenderedReducer, tt !== null)) try { var rt = j.lastRenderedState, nt = tt(rt, $); if (et.hasEagerState = !0, et.eagerState = nt, He(nt, rt)) { var it = j.interleaved; it === null ? (et.next = et, Xg(j)) : (et.next = it.next, it.next = et), j.interleaved = et; return } } catch { } finally { } $ = Yg(_, j, et, _e), $ !== null && (et = L(), mh($, _, _e, et), Ji($, j, _e)) } } function Hi(_) { var j = _.alternate; return _ === N || j !== null && j === N } function Ii(_, j) { Th = Sh = !0; var $ = _.pending; $ === null ? j.next = j : (j.next = $.next, $.next = j), _.pending = j } function Ji(_, j, $) { if ($ & 4194240) { var _e = j.lanes; _e &= _.pendingLanes, $ |= _e, j.lanes = $, Cc(_, $) } } var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: !1 }, Yh = { readContext: Vg, useCallback: function (_, j) { return ci().memoizedState = [_, j === void 0 ? null : j], _ }, useContext: Vg, useEffect: vi, useImperativeHandle: function (_, j, $) { return $ = $ != null ? $.concat([_]) : null, ti(4194308, 4, yi.bind(null, j, _), $) }, useLayoutEffect: function (_, j) { return ti(4194308, 4, _, j) }, useInsertionEffect: function (_, j) { return ti(4, 2, _, j) }, useMemo: function (_, j) { var $ = ci(); return j = j === void 0 ? null : j, _ = _(), $.memoizedState = [_, j], _ }, useReducer: function (_, j, $) { var _e = ci(); return j = $ !== void 0 ? $(j) : j, _e.memoizedState = _e.baseState = j, _ = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: _, lastRenderedState: j }, _e.queue = _, _ = _.dispatch = Gi.bind(null, N, _), [_e.memoizedState, _] }, useRef: function (_) { var j = ci(); return _ = { current: _ }, j.memoizedState = _ }, useState: qi, useDebugValue: Ai, useDeferredValue: function (_) { return ci().memoizedState = _ }, useTransition: function () { var _ = qi(!1), j = _[0]; return _ = Ei.bind(null, _[1]), ci().memoizedState = _, [j, _] }, useMutableSource: function () { }, useSyncExternalStore: function (_, j, $) { var _e = N, et = ci(); if (I) { if ($ === void 0) throw Error(p$3(407)); $ = $() } else { if ($ = j(), R === null) throw Error(p$3(349)); Rh & 30 || ni(_e, j, $) } et.memoizedState = $; var tt = { value: $, getSnapshot: j }; return et.queue = tt, vi(ki.bind(null, _e, tt, _), [_]), _e.flags |= 2048, li(9, mi.bind(null, _e, tt, $, j), void 0, null), $ }, useId: function () { var _ = ci(), j = R.identifierPrefix; if (I) { var $ = sg, _e = rg; $ = (_e & ~(1 << 32 - oc(_e) - 1)).toString(32) + $, j = ":" + j + "R" + $, $ = Uh++, 0 < $ && (j += "H" + $.toString(32)), j += ":" } else $ = Vh++, j = ":" + j + "r" + $.toString(32) + ":"; return _.memoizedState = j }, unstable_isNewReconciler: !1 }, Zh = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: fi, useRef: si, useState: function () { return fi(ei) }, useDebugValue: Ai, useDeferredValue: function (_) { var j = di(); return Di(j, O.memoizedState, _) }, useTransition: function () { var _ = fi(ei)[0], j = di().memoizedState; return [_, j] }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: !1 }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function () { return gi(ei) }, useDebugValue: Ai, useDeferredValue: function (_) { var j = di(); return O === null ? j.memoizedState = _ : Di(j, O.memoizedState, _) }, useTransition: function () { var _ = gi(ei)[0], j = di().memoizedState; return [_, j] }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: !1 }; function Ki(_, j) {
  try { var $ = "", _e = j; do $ += Pa(_e), _e = _e.return; while (_e); var et = $ } catch (tt) {
    et = `
Error generating stack: `+ tt.message + `
`+ tt.stack
  } return { value: _, source: j, stack: et, digest: null }
} function Li(_, j, $) { return { value: _, source: null, stack: $ ?? null, digest: j ?? null } } function Mi(_, j) { try { console.error(j.value) } catch ($) { setTimeout(function () { throw $ }) } } var Ni = typeof WeakMap == "function" ? WeakMap : Map; function Oi(_, j, $) { $ = ch(-1, $), $.tag = 3, $.payload = { element: null }; var _e = j.value; return $.callback = function () { Pi || (Pi = !0, Qi = _e), Mi(_, j) }, $ } function Ri(_, j, $) { $ = ch(-1, $), $.tag = 3; var _e = _.type.getDerivedStateFromError; if (typeof _e == "function") { var et = j.value; $.payload = function () { return _e(et) }, $.callback = function () { Mi(_, j) } } var tt = _.stateNode; return tt !== null && typeof tt.componentDidCatch == "function" && ($.callback = function () { Mi(_, j), typeof _e != "function" && (Si === null ? Si = new Set([this]) : Si.add(this)); var rt = j.stack; this.componentDidCatch(j.value, { componentStack: rt !== null ? rt : "" }) }), $ } function Ti(_, j, $) { var _e = _.pingCache; if (_e === null) { _e = _.pingCache = new Ni; var et = new Set; _e.set(j, et) } else et = _e.get(j), et === void 0 && (et = new Set, _e.set(j, et)); et.has($) || (et.add($), _ = Ui.bind(null, _, j, $), j.then(_, _)) } function Vi(_) { do { var j; if ((j = _.tag === 13) && (j = _.memoizedState, j = j !== null ? j.dehydrated !== null : !0), j) return _; _ = _.return } while (_ !== null); return null } function Wi(_, j, $, _e, et) { return _.mode & 1 ? (_.flags |= 65536, _.lanes = et, _) : (_ === j ? _.flags |= 65536 : (_.flags |= 128, $.flags |= 131072, $.flags &= -52805, $.tag === 1 && ($.alternate === null ? $.tag = 17 : (j = ch(-1, 1), j.tag = 2, dh($, j, 1))), $.lanes |= 1), _) } var Xi = ua.ReactCurrentOwner, Ug = !1; function Yi(_, j, $, _e) { j.child = _ === null ? Ch(j, null, $, _e) : Bh(j, _.child, $, _e) } function Zi(_, j, $, _e, et) { $ = $.render; var tt = j.ref; return Tg(j, et), _e = Xh(_, j, $, _e, tt, et), $ = bi(), _ !== null && !Ug ? (j.updateQueue = _.updateQueue, j.flags &= -2053, _.lanes &= ~et, $i(_, j, et)) : (I && $ && vg(j), j.flags |= 1, Yi(_, j, _e, et), j.child) } function aj(_, j, $, _e, et) { if (_ === null) { var tt = $.type; return typeof tt == "function" && !bj(tt) && tt.defaultProps === void 0 && $.compare === null && $.defaultProps === void 0 ? (j.tag = 15, j.type = tt, cj(_, j, tt, _e, et)) : (_ = yh($.type, null, _e, j, j.mode, et), _.ref = j.ref, _.return = j, j.child = _) } if (tt = _.child, !(_.lanes & et)) { var rt = tt.memoizedProps; if ($ = $.compare, $ = $ !== null ? $ : Ie, $(rt, _e) && _.ref === j.ref) return $i(_, j, et) } return j.flags |= 1, _ = wh(tt, _e), _.ref = j.ref, _.return = j, j.child = _ } function cj(_, j, $, _e, et) { if (_ !== null) { var tt = _.memoizedProps; if (Ie(tt, _e) && _.ref === j.ref) if (Ug = !1, j.pendingProps = _e = tt, (_.lanes & et) !== 0) _.flags & 131072 && (Ug = !0); else return j.lanes = _.lanes, $i(_, j, et) } return dj(_, j, $, _e, et) } function ej(_, j, $) { var _e = j.pendingProps, et = _e.children, tt = _ !== null ? _.memoizedState : null; if (_e.mode === "hidden") if (!(j.mode & 1)) j.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= $; else { if (!($ & 1073741824)) return _ = tt !== null ? tt.baseLanes | $ : $, j.lanes = j.childLanes = 1073741824, j.memoizedState = { baseLanes: _, cachePool: null, transitions: null }, j.updateQueue = null, G(fj, gj), gj |= _, null; j.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, _e = tt !== null ? tt.baseLanes : $, G(fj, gj), gj |= _e } else tt !== null ? (_e = tt.baseLanes | $, j.memoizedState = null) : _e = $, G(fj, gj), gj |= _e; return Yi(_, j, et, $), j.child } function hj(_, j) { var $ = j.ref; (_ === null && $ !== null || _ !== null && _.ref !== $) && (j.flags |= 512, j.flags |= 2097152) } function dj(_, j, $, _e, et) { var tt = Zf($) ? Xf : H.current; return tt = Yf(j, tt), Tg(j, et), $ = Xh(_, j, $, _e, tt, et), _e = bi(), _ !== null && !Ug ? (j.updateQueue = _.updateQueue, j.flags &= -2053, _.lanes &= ~et, $i(_, j, et)) : (I && _e && vg(j), j.flags |= 1, Yi(_, j, $, et), j.child) } function ij(_, j, $, _e, et) { if (Zf($)) { var tt = !0; cg(j) } else tt = !1; if (Tg(j, et), j.stateNode === null) jj(_, j), ph(j, $, _e), rh(j, $, _e, et), _e = !0; else if (_ === null) { var rt = j.stateNode, nt = j.memoizedProps; rt.props = nt; var it = rt.context, st = $.contextType; typeof st == "object" && st !== null ? st = Vg(st) : (st = Zf($) ? Xf : H.current, st = Yf(j, st)); var ot = $.getDerivedStateFromProps, ft = typeof ot == "function" || typeof rt.getSnapshotBeforeUpdate == "function"; ft || typeof rt.UNSAFE_componentWillReceiveProps != "function" && typeof rt.componentWillReceiveProps != "function" || (nt !== _e || it !== st) && qh(j, rt, _e, st), $g = !1; var at = j.memoizedState; rt.state = at, gh(j, _e, rt, et), it = j.memoizedState, nt !== _e || at !== it || Wf.current || $g ? (typeof ot == "function" && (kh(j, $, ot, _e), it = j.memoizedState), (nt = $g || oh(j, $, nt, _e, at, it, st)) ? (ft || typeof rt.UNSAFE_componentWillMount != "function" && typeof rt.componentWillMount != "function" || (typeof rt.componentWillMount == "function" && rt.componentWillMount(), typeof rt.UNSAFE_componentWillMount == "function" && rt.UNSAFE_componentWillMount()), typeof rt.componentDidMount == "function" && (j.flags |= 4194308)) : (typeof rt.componentDidMount == "function" && (j.flags |= 4194308), j.memoizedProps = _e, j.memoizedState = it), rt.props = _e, rt.state = it, rt.context = st, _e = nt) : (typeof rt.componentDidMount == "function" && (j.flags |= 4194308), _e = !1) } else { rt = j.stateNode, bh(_, j), nt = j.memoizedProps, st = j.type === j.elementType ? nt : Lg(j.type, nt), rt.props = st, ft = j.pendingProps, at = rt.context, it = $.contextType, typeof it == "object" && it !== null ? it = Vg(it) : (it = Zf($) ? Xf : H.current, it = Yf(j, it)); var dt = $.getDerivedStateFromProps; (ot = typeof dt == "function" || typeof rt.getSnapshotBeforeUpdate == "function") || typeof rt.UNSAFE_componentWillReceiveProps != "function" && typeof rt.componentWillReceiveProps != "function" || (nt !== ft || at !== it) && qh(j, rt, _e, it), $g = !1, at = j.memoizedState, rt.state = at, gh(j, _e, rt, et); var pt = j.memoizedState; nt !== ft || at !== pt || Wf.current || $g ? (typeof dt == "function" && (kh(j, $, dt, _e), pt = j.memoizedState), (st = $g || oh(j, $, st, _e, at, pt, it) || !1) ? (ot || typeof rt.UNSAFE_componentWillUpdate != "function" && typeof rt.componentWillUpdate != "function" || (typeof rt.componentWillUpdate == "function" && rt.componentWillUpdate(_e, pt, it), typeof rt.UNSAFE_componentWillUpdate == "function" && rt.UNSAFE_componentWillUpdate(_e, pt, it)), typeof rt.componentDidUpdate == "function" && (j.flags |= 4), typeof rt.getSnapshotBeforeUpdate == "function" && (j.flags |= 1024)) : (typeof rt.componentDidUpdate != "function" || nt === _.memoizedProps && at === _.memoizedState || (j.flags |= 4), typeof rt.getSnapshotBeforeUpdate != "function" || nt === _.memoizedProps && at === _.memoizedState || (j.flags |= 1024), j.memoizedProps = _e, j.memoizedState = pt), rt.props = _e, rt.state = pt, rt.context = it, _e = st) : (typeof rt.componentDidUpdate != "function" || nt === _.memoizedProps && at === _.memoizedState || (j.flags |= 4), typeof rt.getSnapshotBeforeUpdate != "function" || nt === _.memoizedProps && at === _.memoizedState || (j.flags |= 1024), _e = !1) } return kj(_, j, $, _e, tt, et) } function kj(_, j, $, _e, et, tt) { hj(_, j); var rt = (j.flags & 128) !== 0; if (!_e && !rt) return et && dg(j, $, !1), $i(_, j, tt); _e = j.stateNode, Xi.current = j; var nt = rt && typeof $.getDerivedStateFromError != "function" ? null : _e.render(); return j.flags |= 1, _ !== null && rt ? (j.child = Bh(j, _.child, null, tt), j.child = Bh(j, null, nt, tt)) : Yi(_, j, nt, tt), j.memoizedState = _e.state, et && dg(j, $, !0), j.child } function lj(_) { var j = _.stateNode; j.pendingContext ? ag(_, j.pendingContext, j.pendingContext !== j.context) : j.context && ag(_, j.context, !1), Ih(_, j.containerInfo) } function mj(_, j, $, _e, et) { return Ig(), Jg(et), j.flags |= 256, Yi(_, j, $, _e), j.child } var nj = { dehydrated: null, treeContext: null, retryLane: 0 }; function oj(_) { return { baseLanes: _, cachePool: null, transitions: null } } function pj(_, j, $) { var _e = j.pendingProps, et = M.current, tt = !1, rt = (j.flags & 128) !== 0, nt; if ((nt = rt) || (nt = _ !== null && _.memoizedState === null ? !1 : (et & 2) !== 0), nt ? (tt = !0, j.flags &= -129) : (_ === null || _.memoizedState !== null) && (et |= 1), G(M, et & 1), _ === null) return Eg(j), _ = j.memoizedState, _ !== null && (_ = _.dehydrated, _ !== null) ? (j.mode & 1 ? _.data === "$!" ? j.lanes = 8 : j.lanes = 1073741824 : j.lanes = 1, null) : (rt = _e.children, _ = _e.fallback, tt ? (_e = j.mode, tt = j.child, rt = { mode: "hidden", children: rt }, !(_e & 1) && tt !== null ? (tt.childLanes = 0, tt.pendingProps = rt) : tt = qj(rt, _e, 0, null), _ = Ah(_, _e, $, null), tt.return = j, _.return = j, tt.sibling = _, j.child = tt, j.child.memoizedState = oj($), j.memoizedState = nj, _) : rj(j, rt)); if (et = _.memoizedState, et !== null && (nt = et.dehydrated, nt !== null)) return sj(_, j, rt, _e, nt, et, $); if (tt) { tt = _e.fallback, rt = j.mode, et = _.child, nt = et.sibling; var it = { mode: "hidden", children: _e.children }; return !(rt & 1) && j.child !== et ? (_e = j.child, _e.childLanes = 0, _e.pendingProps = it, j.deletions = null) : (_e = wh(et, it), _e.subtreeFlags = et.subtreeFlags & 14680064), nt !== null ? tt = wh(nt, tt) : (tt = Ah(tt, rt, $, null), tt.flags |= 2), tt.return = j, _e.return = j, _e.sibling = tt, j.child = _e, _e = tt, tt = j.child, rt = _.child.memoizedState, rt = rt === null ? oj($) : { baseLanes: rt.baseLanes | $, cachePool: null, transitions: rt.transitions }, tt.memoizedState = rt, tt.childLanes = _.childLanes & ~$, j.memoizedState = nj, _e } return tt = _.child, _ = tt.sibling, _e = wh(tt, { mode: "visible", children: _e.children }), !(j.mode & 1) && (_e.lanes = $), _e.return = j, _e.sibling = null, _ !== null && ($ = j.deletions, $ === null ? (j.deletions = [_], j.flags |= 16) : $.push(_)), j.child = _e, j.memoizedState = null, _e } function rj(_, j) { return j = qj({ mode: "visible", children: j }, _.mode, 0, null), j.return = _, _.child = j } function tj(_, j, $, _e) { return _e !== null && Jg(_e), Bh(j, _.child, null, $), _ = rj(j, j.pendingProps.children), _.flags |= 2, j.memoizedState = null, _ } function sj(_, j, $, _e, et, tt, rt) { if ($) return j.flags & 256 ? (j.flags &= -257, _e = Li(Error(p$3(422))), tj(_, j, rt, _e)) : j.memoizedState !== null ? (j.child = _.child, j.flags |= 128, null) : (tt = _e.fallback, et = j.mode, _e = qj({ mode: "visible", children: _e.children }, et, 0, null), tt = Ah(tt, et, rt, null), tt.flags |= 2, _e.return = j, tt.return = j, _e.sibling = tt, j.child = _e, j.mode & 1 && Bh(j, _.child, null, rt), j.child.memoizedState = oj(rt), j.memoizedState = nj, tt); if (!(j.mode & 1)) return tj(_, j, rt, null); if (et.data === "$!") { if (_e = et.nextSibling && et.nextSibling.dataset, _e) var nt = _e.dgst; return _e = nt, tt = Error(p$3(419)), _e = Li(tt, _e, void 0), tj(_, j, rt, _e) } if (nt = (rt & _.childLanes) !== 0, Ug || nt) { if (_e = R, _e !== null) { switch (rt & -rt) { case 4: et = 2; break; case 16: et = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: et = 32; break; case 536870912: et = 268435456; break; default: et = 0 }et = et & (_e.suspendedLanes | rt) ? 0 : et, et !== 0 && et !== tt.retryLane && (tt.retryLane = et, Zg(_, et), mh(_e, _, et, -1)) } return uj(), _e = Li(Error(p$3(421))), tj(_, j, rt, _e) } return et.data === "$?" ? (j.flags |= 128, j.child = _.child, j = vj.bind(null, _), et._reactRetry = j, null) : (_ = tt.treeContext, yg = Lf(et.nextSibling), xg = j, I = !0, zg = null, _ !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = _.id, sg = _.overflow, qg = j), j = rj(j, _e.children), j.flags |= 4096, j) } function wj(_, j, $) { _.lanes |= j; var _e = _.alternate; _e !== null && (_e.lanes |= j), Sg(_.return, j, $) } function xj(_, j, $, _e, et) { var tt = _.memoizedState; tt === null ? _.memoizedState = { isBackwards: j, rendering: null, renderingStartTime: 0, last: _e, tail: $, tailMode: et } : (tt.isBackwards = j, tt.rendering = null, tt.renderingStartTime = 0, tt.last = _e, tt.tail = $, tt.tailMode = et) } function yj(_, j, $) { var _e = j.pendingProps, et = _e.revealOrder, tt = _e.tail; if (Yi(_, j, _e.children, $), _e = M.current, _e & 2) _e = _e & 1 | 2, j.flags |= 128; else { if (_ !== null && _.flags & 128) e: for (_ = j.child; _ !== null;) { if (_.tag === 13) _.memoizedState !== null && wj(_, $, j); else if (_.tag === 19) wj(_, $, j); else if (_.child !== null) { _.child.return = _, _ = _.child; continue } if (_ === j) break e; for (; _.sibling === null;) { if (_.return === null || _.return === j) break e; _ = _.return } _.sibling.return = _.return, _ = _.sibling } _e &= 1 } if (G(M, _e), !(j.mode & 1)) j.memoizedState = null; else switch (et) { case "forwards": for ($ = j.child, et = null; $ !== null;)_ = $.alternate, _ !== null && Mh(_) === null && (et = $), $ = $.sibling; $ = et, $ === null ? (et = j.child, j.child = null) : (et = $.sibling, $.sibling = null), xj(j, !1, et, $, tt); break; case "backwards": for ($ = null, et = j.child, j.child = null; et !== null;) { if (_ = et.alternate, _ !== null && Mh(_) === null) { j.child = et; break } _ = et.sibling, et.sibling = $, $ = et, et = _ } xj(j, !0, $, null, tt); break; case "together": xj(j, !1, null, null, void 0); break; default: j.memoizedState = null }return j.child } function jj(_, j) { !(j.mode & 1) && _ !== null && (_.alternate = null, j.alternate = null, j.flags |= 2) } function $i(_, j, $) { if (_ !== null && (j.dependencies = _.dependencies), hh |= j.lanes, !($ & j.childLanes)) return null; if (_ !== null && j.child !== _.child) throw Error(p$3(153)); if (j.child !== null) { for (_ = j.child, $ = wh(_, _.pendingProps), j.child = $, $.return = j; _.sibling !== null;)_ = _.sibling, $ = $.sibling = wh(_, _.pendingProps), $.return = j; $.sibling = null } return j.child } function zj(_, j, $) { switch (j.tag) { case 3: lj(j), Ig(); break; case 5: Kh(j); break; case 1: Zf(j.type) && cg(j); break; case 4: Ih(j, j.stateNode.containerInfo); break; case 10: var _e = j.type._context, et = j.memoizedProps.value; G(Mg, _e._currentValue), _e._currentValue = et; break; case 13: if (_e = j.memoizedState, _e !== null) return _e.dehydrated !== null ? (G(M, M.current & 1), j.flags |= 128, null) : $ & j.child.childLanes ? pj(_, j, $) : (G(M, M.current & 1), _ = $i(_, j, $), _ !== null ? _.sibling : null); G(M, M.current & 1); break; case 19: if (_e = ($ & j.childLanes) !== 0, _.flags & 128) { if (_e) return yj(_, j, $); j.flags |= 128 } if (et = j.memoizedState, et !== null && (et.rendering = null, et.tail = null, et.lastEffect = null), G(M, M.current), _e) break; return null; case 22: case 23: return j.lanes = 0, ej(_, j, $) }return $i(_, j, $) } var Aj, Bj, Cj, Dj; Aj = function (_, j) { for (var $ = j.child; $ !== null;) { if ($.tag === 5 || $.tag === 6) _.appendChild($.stateNode); else if ($.tag !== 4 && $.child !== null) { $.child.return = $, $ = $.child; continue } if ($ === j) break; for (; $.sibling === null;) { if ($.return === null || $.return === j) return; $ = $.return } $.sibling.return = $.return, $ = $.sibling } }; Bj = function () { }; Cj = function (_, j, $, _e) { var et = _.memoizedProps; if (et !== _e) { _ = j.stateNode, Hh(Eh.current); var tt = null; switch ($) { case "input": et = Ya(_, et), _e = Ya(_, _e), tt = []; break; case "select": et = A$1({}, et, { value: void 0 }), _e = A$1({}, _e, { value: void 0 }), tt = []; break; case "textarea": et = gb(_, et), _e = gb(_, _e), tt = []; break; default: typeof et.onClick != "function" && typeof _e.onClick == "function" && (_.onclick = Bf) }ub($, _e); var rt; $ = null; for (st in et) if (!_e.hasOwnProperty(st) && et.hasOwnProperty(st) && et[st] != null) if (st === "style") { var nt = et[st]; for (rt in nt) nt.hasOwnProperty(rt) && ($ || ($ = {}), $[rt] = "") } else st !== "dangerouslySetInnerHTML" && st !== "children" && st !== "suppressContentEditableWarning" && st !== "suppressHydrationWarning" && st !== "autoFocus" && (ea.hasOwnProperty(st) ? tt || (tt = []) : (tt = tt || []).push(st, null)); for (st in _e) { var it = _e[st]; if (nt = et != null ? et[st] : void 0, _e.hasOwnProperty(st) && it !== nt && (it != null || nt != null)) if (st === "style") if (nt) { for (rt in nt) !nt.hasOwnProperty(rt) || it && it.hasOwnProperty(rt) || ($ || ($ = {}), $[rt] = ""); for (rt in it) it.hasOwnProperty(rt) && nt[rt] !== it[rt] && ($ || ($ = {}), $[rt] = it[rt]) } else $ || (tt || (tt = []), tt.push(st, $)), $ = it; else st === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0, nt = nt ? nt.__html : void 0, it != null && nt !== it && (tt = tt || []).push(st, it)) : st === "children" ? typeof it != "string" && typeof it != "number" || (tt = tt || []).push(st, "" + it) : st !== "suppressContentEditableWarning" && st !== "suppressHydrationWarning" && (ea.hasOwnProperty(st) ? (it != null && st === "onScroll" && D("scroll", _), tt || nt === it || (tt = [])) : (tt = tt || []).push(st, it)) } $ && (tt = tt || []).push("style", $); var st = tt; (j.updateQueue = st) && (j.flags |= 4) } }; Dj = function (_, j, $, _e) { $ !== _e && (j.flags |= 4) }; function Ej(_, j) { if (!I) switch (_.tailMode) { case "hidden": j = _.tail; for (var $ = null; j !== null;)j.alternate !== null && ($ = j), j = j.sibling; $ === null ? _.tail = null : $.sibling = null; break; case "collapsed": $ = _.tail; for (var _e = null; $ !== null;)$.alternate !== null && (_e = $), $ = $.sibling; _e === null ? j || _.tail === null ? _.tail = null : _.tail.sibling = null : _e.sibling = null } } function S(_) { var j = _.alternate !== null && _.alternate.child === _.child, $ = 0, _e = 0; if (j) for (var et = _.child; et !== null;)$ |= et.lanes | et.childLanes, _e |= et.subtreeFlags & 14680064, _e |= et.flags & 14680064, et.return = _, et = et.sibling; else for (et = _.child; et !== null;)$ |= et.lanes | et.childLanes, _e |= et.subtreeFlags, _e |= et.flags, et.return = _, et = et.sibling; return _.subtreeFlags |= _e, _.childLanes = $, j } function Fj(_, j, $) { var _e = j.pendingProps; switch (wg(j), j.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return S(j), null; case 1: return Zf(j.type) && $f(), S(j), null; case 3: return _e = j.stateNode, Jh(), E(Wf), E(H), Oh(), _e.pendingContext && (_e.context = _e.pendingContext, _e.pendingContext = null), (_ === null || _.child === null) && (Gg(j) ? j.flags |= 4 : _ === null || _.memoizedState.isDehydrated && !(j.flags & 256) || (j.flags |= 1024, zg !== null && (Gj(zg), zg = null))), Bj(_, j), S(j), null; case 5: Lh(j); var et = Hh(Gh.current); if ($ = j.type, _ !== null && j.stateNode != null) Cj(_, j, $, _e, et), _.ref !== j.ref && (j.flags |= 512, j.flags |= 2097152); else { if (!_e) { if (j.stateNode === null) throw Error(p$3(166)); return S(j), null } if (_ = Hh(Eh.current), Gg(j)) { _e = j.stateNode, $ = j.type; var tt = j.memoizedProps; switch (_e[Of] = j, _e[Pf] = tt, _ = (j.mode & 1) !== 0, $) { case "dialog": D("cancel", _e), D("close", _e); break; case "iframe": case "object": case "embed": D("load", _e); break; case "video": case "audio": for (et = 0; et < lf.length; et++)D(lf[et], _e); break; case "source": D("error", _e); break; case "img": case "image": case "link": D("error", _e), D("load", _e); break; case "details": D("toggle", _e); break; case "input": Za(_e, tt), D("invalid", _e); break; case "select": _e._wrapperState = { wasMultiple: !!tt.multiple }, D("invalid", _e); break; case "textarea": hb(_e, tt), D("invalid", _e) }ub($, tt), et = null; for (var rt in tt) if (tt.hasOwnProperty(rt)) { var nt = tt[rt]; rt === "children" ? typeof nt == "string" ? _e.textContent !== nt && (tt.suppressHydrationWarning !== !0 && Af(_e.textContent, nt, _), et = ["children", nt]) : typeof nt == "number" && _e.textContent !== "" + nt && (tt.suppressHydrationWarning !== !0 && Af(_e.textContent, nt, _), et = ["children", "" + nt]) : ea.hasOwnProperty(rt) && nt != null && rt === "onScroll" && D("scroll", _e) } switch ($) { case "input": Va(_e), db(_e, tt, !0); break; case "textarea": Va(_e), jb(_e); break; case "select": case "option": break; default: typeof tt.onClick == "function" && (_e.onclick = Bf) }_e = et, j.updateQueue = _e, _e !== null && (j.flags |= 4) } else { rt = et.nodeType === 9 ? et : et.ownerDocument, _ === "http://www.w3.org/1999/xhtml" && (_ = kb($)), _ === "http://www.w3.org/1999/xhtml" ? $ === "script" ? (_ = rt.createElement("div"), _.innerHTML = "<script><\/script>", _ = _.removeChild(_.firstChild)) : typeof _e.is == "string" ? _ = rt.createElement($, { is: _e.is }) : (_ = rt.createElement($), $ === "select" && (rt = _, _e.multiple ? rt.multiple = !0 : _e.size && (rt.size = _e.size))) : _ = rt.createElementNS(_, $), _[Of] = j, _[Pf] = _e, Aj(_, j, !1, !1), j.stateNode = _; e: { switch (rt = vb($, _e), $) { case "dialog": D("cancel", _), D("close", _), et = _e; break; case "iframe": case "object": case "embed": D("load", _), et = _e; break; case "video": case "audio": for (et = 0; et < lf.length; et++)D(lf[et], _); et = _e; break; case "source": D("error", _), et = _e; break; case "img": case "image": case "link": D("error", _), D("load", _), et = _e; break; case "details": D("toggle", _), et = _e; break; case "input": Za(_, _e), et = Ya(_, _e), D("invalid", _); break; case "option": et = _e; break; case "select": _._wrapperState = { wasMultiple: !!_e.multiple }, et = A$1({}, _e, { value: void 0 }), D("invalid", _); break; case "textarea": hb(_, _e), et = gb(_, _e), D("invalid", _); break; default: et = _e }ub($, et), nt = et; for (tt in nt) if (nt.hasOwnProperty(tt)) { var it = nt[tt]; tt === "style" ? sb(_, it) : tt === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0, it != null && nb(_, it)) : tt === "children" ? typeof it == "string" ? ($ !== "textarea" || it !== "") && ob(_, it) : typeof it == "number" && ob(_, "" + it) : tt !== "suppressContentEditableWarning" && tt !== "suppressHydrationWarning" && tt !== "autoFocus" && (ea.hasOwnProperty(tt) ? it != null && tt === "onScroll" && D("scroll", _) : it != null && ta(_, tt, it, rt)) } switch ($) { case "input": Va(_), db(_, _e, !1); break; case "textarea": Va(_), jb(_); break; case "option": _e.value != null && _.setAttribute("value", "" + Sa(_e.value)); break; case "select": _.multiple = !!_e.multiple, tt = _e.value, tt != null ? fb(_, !!_e.multiple, tt, !1) : _e.defaultValue != null && fb(_, !!_e.multiple, _e.defaultValue, !0); break; default: typeof et.onClick == "function" && (_.onclick = Bf) }switch ($) { case "button": case "input": case "select": case "textarea": _e = !!_e.autoFocus; break e; case "img": _e = !0; break e; default: _e = !1 } } _e && (j.flags |= 4) } j.ref !== null && (j.flags |= 512, j.flags |= 2097152) } return S(j), null; case 6: if (_ && j.stateNode != null) Dj(_, j, _.memoizedProps, _e); else { if (typeof _e != "string" && j.stateNode === null) throw Error(p$3(166)); if ($ = Hh(Gh.current), Hh(Eh.current), Gg(j)) { if (_e = j.stateNode, $ = j.memoizedProps, _e[Of] = j, (tt = _e.nodeValue !== $) && (_ = xg, _ !== null)) switch (_.tag) { case 3: Af(_e.nodeValue, $, (_.mode & 1) !== 0); break; case 5: _.memoizedProps.suppressHydrationWarning !== !0 && Af(_e.nodeValue, $, (_.mode & 1) !== 0) }tt && (j.flags |= 4) } else _e = ($.nodeType === 9 ? $ : $.ownerDocument).createTextNode(_e), _e[Of] = j, j.stateNode = _e } return S(j), null; case 13: if (E(M), _e = j.memoizedState, _ === null || _.memoizedState !== null && _.memoizedState.dehydrated !== null) { if (I && yg !== null && j.mode & 1 && !(j.flags & 128)) Hg(), Ig(), j.flags |= 98560, tt = !1; else if (tt = Gg(j), _e !== null && _e.dehydrated !== null) { if (_ === null) { if (!tt) throw Error(p$3(318)); if (tt = j.memoizedState, tt = tt !== null ? tt.dehydrated : null, !tt) throw Error(p$3(317)); tt[Of] = j } else Ig(), !(j.flags & 128) && (j.memoizedState = null), j.flags |= 4; S(j), tt = !1 } else zg !== null && (Gj(zg), zg = null), tt = !0; if (!tt) return j.flags & 65536 ? j : null } return j.flags & 128 ? (j.lanes = $, j) : (_e = _e !== null, _e !== (_ !== null && _.memoizedState !== null) && _e && (j.child.flags |= 8192, j.mode & 1 && (_ === null || M.current & 1 ? T === 0 && (T = 3) : uj())), j.updateQueue !== null && (j.flags |= 4), S(j), null); case 4: return Jh(), Bj(_, j), _ === null && sf(j.stateNode.containerInfo), S(j), null; case 10: return Rg(j.type._context), S(j), null; case 17: return Zf(j.type) && $f(), S(j), null; case 19: if (E(M), tt = j.memoizedState, tt === null) return S(j), null; if (_e = (j.flags & 128) !== 0, rt = tt.rendering, rt === null) if (_e) Ej(tt, !1); else { if (T !== 0 || _ !== null && _.flags & 128) for (_ = j.child; _ !== null;) { if (rt = Mh(_), rt !== null) { for (j.flags |= 128, Ej(tt, !1), _e = rt.updateQueue, _e !== null && (j.updateQueue = _e, j.flags |= 4), j.subtreeFlags = 0, _e = $, $ = j.child; $ !== null;)tt = $, _ = _e, tt.flags &= 14680066, rt = tt.alternate, rt === null ? (tt.childLanes = 0, tt.lanes = _, tt.child = null, tt.subtreeFlags = 0, tt.memoizedProps = null, tt.memoizedState = null, tt.updateQueue = null, tt.dependencies = null, tt.stateNode = null) : (tt.childLanes = rt.childLanes, tt.lanes = rt.lanes, tt.child = rt.child, tt.subtreeFlags = 0, tt.deletions = null, tt.memoizedProps = rt.memoizedProps, tt.memoizedState = rt.memoizedState, tt.updateQueue = rt.updateQueue, tt.type = rt.type, _ = rt.dependencies, tt.dependencies = _ === null ? null : { lanes: _.lanes, firstContext: _.firstContext }), $ = $.sibling; return G(M, M.current & 1 | 2), j.child } _ = _.sibling } tt.tail !== null && B() > Hj && (j.flags |= 128, _e = !0, Ej(tt, !1), j.lanes = 4194304) } else { if (!_e) if (_ = Mh(rt), _ !== null) { if (j.flags |= 128, _e = !0, $ = _.updateQueue, $ !== null && (j.updateQueue = $, j.flags |= 4), Ej(tt, !0), tt.tail === null && tt.tailMode === "hidden" && !rt.alternate && !I) return S(j), null } else 2 * B() - tt.renderingStartTime > Hj && $ !== 1073741824 && (j.flags |= 128, _e = !0, Ej(tt, !1), j.lanes = 4194304); tt.isBackwards ? (rt.sibling = j.child, j.child = rt) : ($ = tt.last, $ !== null ? $.sibling = rt : j.child = rt, tt.last = rt) } return tt.tail !== null ? (j = tt.tail, tt.rendering = j, tt.tail = j.sibling, tt.renderingStartTime = B(), j.sibling = null, $ = M.current, G(M, _e ? $ & 1 | 2 : $ & 1), j) : (S(j), null); case 22: case 23: return Ij(), _e = j.memoizedState !== null, _ !== null && _.memoizedState !== null !== _e && (j.flags |= 8192), _e && j.mode & 1 ? gj & 1073741824 && (S(j), j.subtreeFlags & 6 && (j.flags |= 8192)) : S(j), null; case 24: return null; case 25: return null }throw Error(p$3(156, j.tag)) } function Jj(_, j) { switch (wg(j), j.tag) { case 1: return Zf(j.type) && $f(), _ = j.flags, _ & 65536 ? (j.flags = _ & -65537 | 128, j) : null; case 3: return Jh(), E(Wf), E(H), Oh(), _ = j.flags, _ & 65536 && !(_ & 128) ? (j.flags = _ & -65537 | 128, j) : null; case 5: return Lh(j), null; case 13: if (E(M), _ = j.memoizedState, _ !== null && _.dehydrated !== null) { if (j.alternate === null) throw Error(p$3(340)); Ig() } return _ = j.flags, _ & 65536 ? (j.flags = _ & -65537 | 128, j) : null; case 19: return E(M), null; case 4: return Jh(), null; case 10: return Rg(j.type._context), null; case 22: case 23: return Ij(), null; case 24: return null; default: return null } } var Kj = !1, U = !1, Lj = typeof WeakSet == "function" ? WeakSet : Set, V = null; function Mj(_, j) { var $ = _.ref; if ($ !== null) if (typeof $ == "function") try { $(null) } catch (_e) { W(_, j, _e) } else $.current = null } function Nj(_, j, $) { try { $() } catch (_e) { W(_, j, _e) } } var Oj = !1; function Pj(_, j) { if (Cf = dd, _ = Me(), Ne(_)) { if ("selectionStart" in _) var $ = { start: _.selectionStart, end: _.selectionEnd }; else e: { $ = ($ = _.ownerDocument) && $.defaultView || window; var _e = $.getSelection && $.getSelection(); if (_e && _e.rangeCount !== 0) { $ = _e.anchorNode; var et = _e.anchorOffset, tt = _e.focusNode; _e = _e.focusOffset; try { $.nodeType, tt.nodeType } catch { $ = null; break e } var rt = 0, nt = -1, it = -1, st = 0, ot = 0, ft = _, at = null; t: for (; ;) { for (var dt; ft !== $ || et !== 0 && ft.nodeType !== 3 || (nt = rt + et), ft !== tt || _e !== 0 && ft.nodeType !== 3 || (it = rt + _e), ft.nodeType === 3 && (rt += ft.nodeValue.length), (dt = ft.firstChild) !== null;)at = ft, ft = dt; for (; ;) { if (ft === _) break t; if (at === $ && ++st === et && (nt = rt), at === tt && ++ot === _e && (it = rt), (dt = ft.nextSibling) !== null) break; ft = at, at = ft.parentNode } ft = dt } $ = nt === -1 || it === -1 ? null : { start: nt, end: it } } else $ = null } $ = $ || { start: 0, end: 0 } } else $ = null; for (Df = { focusedElem: _, selectionRange: $ }, dd = !1, V = j; V !== null;)if (j = V, _ = j.child, (j.subtreeFlags & 1028) !== 0 && _ !== null) _.return = j, V = _; else for (; V !== null;) { j = V; try { var pt = j.alternate; if (j.flags & 1024) switch (j.tag) { case 0: case 11: case 15: break; case 1: if (pt !== null) { var ht = pt.memoizedProps, xt = pt.memoizedState, ct = j.stateNode, ut = ct.getSnapshotBeforeUpdate(j.elementType === j.type ? ht : Lg(j.type, ht), xt); ct.__reactInternalSnapshotBeforeUpdate = ut } break; case 3: var lt = j.stateNode.containerInfo; lt.nodeType === 1 ? lt.textContent = "" : lt.nodeType === 9 && lt.documentElement && lt.removeChild(lt.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(p$3(163)) } } catch (mt) { W(j, j.return, mt) } if (_ = j.sibling, _ !== null) { _.return = j.return, V = _; break } V = j.return } return pt = Oj, Oj = !1, pt } function Qj(_, j, $) { var _e = j.updateQueue; if (_e = _e !== null ? _e.lastEffect : null, _e !== null) { var et = _e = _e.next; do { if ((et.tag & _) === _) { var tt = et.destroy; et.destroy = void 0, tt !== void 0 && Nj(j, $, tt) } et = et.next } while (et !== _e) } } function Rj(_, j) { if (j = j.updateQueue, j = j !== null ? j.lastEffect : null, j !== null) { var $ = j = j.next; do { if (($.tag & _) === _) { var _e = $.create; $.destroy = _e() } $ = $.next } while ($ !== j) } } function Sj(_) { var j = _.ref; if (j !== null) { var $ = _.stateNode; switch (_.tag) { case 5: _ = $; break; default: _ = $ }typeof j == "function" ? j(_) : j.current = _ } } function Tj(_) { var j = _.alternate; j !== null && (_.alternate = null, Tj(j)), _.child = null, _.deletions = null, _.sibling = null, _.tag === 5 && (j = _.stateNode, j !== null && (delete j[Of], delete j[Pf], delete j[of], delete j[Qf], delete j[Rf])), _.stateNode = null, _.return = null, _.dependencies = null, _.memoizedProps = null, _.memoizedState = null, _.pendingProps = null, _.stateNode = null, _.updateQueue = null } function Uj(_) { return _.tag === 5 || _.tag === 3 || _.tag === 4 } function Vj(_) { e: for (; ;) { for (; _.sibling === null;) { if (_.return === null || Uj(_.return)) return null; _ = _.return } for (_.sibling.return = _.return, _ = _.sibling; _.tag !== 5 && _.tag !== 6 && _.tag !== 18;) { if (_.flags & 2 || _.child === null || _.tag === 4) continue e; _.child.return = _, _ = _.child } if (!(_.flags & 2)) return _.stateNode } } function Wj(_, j, $) { var _e = _.tag; if (_e === 5 || _e === 6) _ = _.stateNode, j ? $.nodeType === 8 ? $.parentNode.insertBefore(_, j) : $.insertBefore(_, j) : ($.nodeType === 8 ? (j = $.parentNode, j.insertBefore(_, $)) : (j = $, j.appendChild(_)), $ = $._reactRootContainer, $ != null || j.onclick !== null || (j.onclick = Bf)); else if (_e !== 4 && (_ = _.child, _ !== null)) for (Wj(_, j, $), _ = _.sibling; _ !== null;)Wj(_, j, $), _ = _.sibling } function Xj(_, j, $) { var _e = _.tag; if (_e === 5 || _e === 6) _ = _.stateNode, j ? $.insertBefore(_, j) : $.appendChild(_); else if (_e !== 4 && (_ = _.child, _ !== null)) for (Xj(_, j, $), _ = _.sibling; _ !== null;)Xj(_, j, $), _ = _.sibling } var X = null, Yj = !1; function Zj(_, j, $) { for ($ = $.child; $ !== null;)ak(_, j, $), $ = $.sibling } function ak(_, j, $) { if (lc && typeof lc.onCommitFiberUnmount == "function") try { lc.onCommitFiberUnmount(kc, $) } catch { } switch ($.tag) { case 5: U || Mj($, j); case 6: var _e = X, et = Yj; X = null, Zj(_, j, $), X = _e, Yj = et, X !== null && (Yj ? (_ = X, $ = $.stateNode, _.nodeType === 8 ? _.parentNode.removeChild($) : _.removeChild($)) : X.removeChild($.stateNode)); break; case 18: X !== null && (Yj ? (_ = X, $ = $.stateNode, _.nodeType === 8 ? Kf(_.parentNode, $) : _.nodeType === 1 && Kf(_, $), bd(_)) : Kf(X, $.stateNode)); break; case 4: _e = X, et = Yj, X = $.stateNode.containerInfo, Yj = !0, Zj(_, j, $), X = _e, Yj = et; break; case 0: case 11: case 14: case 15: if (!U && (_e = $.updateQueue, _e !== null && (_e = _e.lastEffect, _e !== null))) { et = _e = _e.next; do { var tt = et, rt = tt.destroy; tt = tt.tag, rt !== void 0 && (tt & 2 || tt & 4) && Nj($, j, rt), et = et.next } while (et !== _e) } Zj(_, j, $); break; case 1: if (!U && (Mj($, j), _e = $.stateNode, typeof _e.componentWillUnmount == "function")) try { _e.props = $.memoizedProps, _e.state = $.memoizedState, _e.componentWillUnmount() } catch (nt) { W($, j, nt) } Zj(_, j, $); break; case 21: Zj(_, j, $); break; case 22: $.mode & 1 ? (U = (_e = U) || $.memoizedState !== null, Zj(_, j, $), U = _e) : Zj(_, j, $); break; default: Zj(_, j, $) } } function bk(_) { var j = _.updateQueue; if (j !== null) { _.updateQueue = null; var $ = _.stateNode; $ === null && ($ = _.stateNode = new Lj), j.forEach(function (_e) { var et = ck.bind(null, _, _e); $.has(_e) || ($.add(_e), _e.then(et, et)) }) } } function dk(_, j) { var $ = j.deletions; if ($ !== null) for (var _e = 0; _e < $.length; _e++) { var et = $[_e]; try { var tt = _, rt = j, nt = rt; e: for (; nt !== null;) { switch (nt.tag) { case 5: X = nt.stateNode, Yj = !1; break e; case 3: X = nt.stateNode.containerInfo, Yj = !0; break e; case 4: X = nt.stateNode.containerInfo, Yj = !0; break e }nt = nt.return } if (X === null) throw Error(p$3(160)); ak(tt, rt, et), X = null, Yj = !1; var it = et.alternate; it !== null && (it.return = null), et.return = null } catch (st) { W(et, j, st) } } if (j.subtreeFlags & 12854) for (j = j.child; j !== null;)ek(j, _), j = j.sibling } function ek(_, j) { var $ = _.alternate, _e = _.flags; switch (_.tag) { case 0: case 11: case 14: case 15: if (dk(j, _), fk(_), _e & 4) { try { Qj(3, _, _.return), Rj(3, _) } catch (ht) { W(_, _.return, ht) } try { Qj(5, _, _.return) } catch (ht) { W(_, _.return, ht) } } break; case 1: dk(j, _), fk(_), _e & 512 && $ !== null && Mj($, $.return); break; case 5: if (dk(j, _), fk(_), _e & 512 && $ !== null && Mj($, $.return), _.flags & 32) { var et = _.stateNode; try { ob(et, "") } catch (ht) { W(_, _.return, ht) } } if (_e & 4 && (et = _.stateNode, et != null)) { var tt = _.memoizedProps, rt = $ !== null ? $.memoizedProps : tt, nt = _.type, it = _.updateQueue; if (_.updateQueue = null, it !== null) try { nt === "input" && tt.type === "radio" && tt.name != null && ab(et, tt), vb(nt, rt); var st = vb(nt, tt); for (rt = 0; rt < it.length; rt += 2) { var ot = it[rt], ft = it[rt + 1]; ot === "style" ? sb(et, ft) : ot === "dangerouslySetInnerHTML" ? nb(et, ft) : ot === "children" ? ob(et, ft) : ta(et, ot, ft, st) } switch (nt) { case "input": bb(et, tt); break; case "textarea": ib(et, tt); break; case "select": var at = et._wrapperState.wasMultiple; et._wrapperState.wasMultiple = !!tt.multiple; var dt = tt.value; dt != null ? fb(et, !!tt.multiple, dt, !1) : at !== !!tt.multiple && (tt.defaultValue != null ? fb(et, !!tt.multiple, tt.defaultValue, !0) : fb(et, !!tt.multiple, tt.multiple ? [] : "", !1)) }et[Pf] = tt } catch (ht) { W(_, _.return, ht) } } break; case 6: if (dk(j, _), fk(_), _e & 4) { if (_.stateNode === null) throw Error(p$3(162)); et = _.stateNode, tt = _.memoizedProps; try { et.nodeValue = tt } catch (ht) { W(_, _.return, ht) } } break; case 3: if (dk(j, _), fk(_), _e & 4 && $ !== null && $.memoizedState.isDehydrated) try { bd(j.containerInfo) } catch (ht) { W(_, _.return, ht) } break; case 4: dk(j, _), fk(_); break; case 13: dk(j, _), fk(_), et = _.child, et.flags & 8192 && (tt = et.memoizedState !== null, et.stateNode.isHidden = tt, !tt || et.alternate !== null && et.alternate.memoizedState !== null || (gk = B())), _e & 4 && bk(_); break; case 22: if (ot = $ !== null && $.memoizedState !== null, _.mode & 1 ? (U = (st = U) || ot, dk(j, _), U = st) : dk(j, _), fk(_), _e & 8192) { if (st = _.memoizedState !== null, (_.stateNode.isHidden = st) && !ot && _.mode & 1) for (V = _, ot = _.child; ot !== null;) { for (ft = V = ot; V !== null;) { switch (at = V, dt = at.child, at.tag) { case 0: case 11: case 14: case 15: Qj(4, at, at.return); break; case 1: Mj(at, at.return); var pt = at.stateNode; if (typeof pt.componentWillUnmount == "function") { _e = at, $ = at.return; try { j = _e, pt.props = j.memoizedProps, pt.state = j.memoizedState, pt.componentWillUnmount() } catch (ht) { W(_e, $, ht) } } break; case 5: Mj(at, at.return); break; case 22: if (at.memoizedState !== null) { hk(ft); continue } }dt !== null ? (dt.return = at, V = dt) : hk(ft) } ot = ot.sibling } e: for (ot = null, ft = _; ;) { if (ft.tag === 5) { if (ot === null) { ot = ft; try { et = ft.stateNode, st ? (tt = et.style, typeof tt.setProperty == "function" ? tt.setProperty("display", "none", "important") : tt.display = "none") : (nt = ft.stateNode, it = ft.memoizedProps.style, rt = it != null && it.hasOwnProperty("display") ? it.display : null, nt.style.display = rb("display", rt)) } catch (ht) { W(_, _.return, ht) } } } else if (ft.tag === 6) { if (ot === null) try { ft.stateNode.nodeValue = st ? "" : ft.memoizedProps } catch (ht) { W(_, _.return, ht) } } else if ((ft.tag !== 22 && ft.tag !== 23 || ft.memoizedState === null || ft === _) && ft.child !== null) { ft.child.return = ft, ft = ft.child; continue } if (ft === _) break e; for (; ft.sibling === null;) { if (ft.return === null || ft.return === _) break e; ot === ft && (ot = null), ft = ft.return } ot === ft && (ot = null), ft.sibling.return = ft.return, ft = ft.sibling } } break; case 19: dk(j, _), fk(_), _e & 4 && bk(_); break; case 21: break; default: dk(j, _), fk(_) } } function fk(_) { var j = _.flags; if (j & 2) { try { e: { for (var $ = _.return; $ !== null;) { if (Uj($)) { var _e = $; break e } $ = $.return } throw Error(p$3(160)) } switch (_e.tag) { case 5: var et = _e.stateNode; _e.flags & 32 && (ob(et, ""), _e.flags &= -33); var tt = Vj(_); Xj(_, tt, et); break; case 3: case 4: var rt = _e.stateNode.containerInfo, nt = Vj(_); Wj(_, nt, rt); break; default: throw Error(p$3(161)) } } catch (it) { W(_, _.return, it) } _.flags &= -3 } j & 4096 && (_.flags &= -4097) } function ik(_, j, $) { V = _, jk(_) } function jk(_, j, $) { for (var _e = (_.mode & 1) !== 0; V !== null;) { var et = V, tt = et.child; if (et.tag === 22 && _e) { var rt = et.memoizedState !== null || Kj; if (!rt) { var nt = et.alternate, it = nt !== null && nt.memoizedState !== null || U; nt = Kj; var st = U; if (Kj = rt, (U = it) && !st) for (V = et; V !== null;)rt = V, it = rt.child, rt.tag === 22 && rt.memoizedState !== null ? kk(et) : it !== null ? (it.return = rt, V = it) : kk(et); for (; tt !== null;)V = tt, jk(tt), tt = tt.sibling; V = et, Kj = nt, U = st } lk(_) } else et.subtreeFlags & 8772 && tt !== null ? (tt.return = et, V = tt) : lk(_) } } function lk(_) { for (; V !== null;) { var j = V; if (j.flags & 8772) { var $ = j.alternate; try { if (j.flags & 8772) switch (j.tag) { case 0: case 11: case 15: U || Rj(5, j); break; case 1: var _e = j.stateNode; if (j.flags & 4 && !U) if ($ === null) _e.componentDidMount(); else { var et = j.elementType === j.type ? $.memoizedProps : Lg(j.type, $.memoizedProps); _e.componentDidUpdate(et, $.memoizedState, _e.__reactInternalSnapshotBeforeUpdate) } var tt = j.updateQueue; tt !== null && ih(j, tt, _e); break; case 3: var rt = j.updateQueue; if (rt !== null) { if ($ = null, j.child !== null) switch (j.child.tag) { case 5: $ = j.child.stateNode; break; case 1: $ = j.child.stateNode }ih(j, rt, $) } break; case 5: var nt = j.stateNode; if ($ === null && j.flags & 4) { $ = nt; var it = j.memoizedProps; switch (j.type) { case "button": case "input": case "select": case "textarea": it.autoFocus && $.focus(); break; case "img": it.src && ($.src = it.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (j.memoizedState === null) { var st = j.alternate; if (st !== null) { var ot = st.memoizedState; if (ot !== null) { var ft = ot.dehydrated; ft !== null && bd(ft) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(p$3(163)) }U || j.flags & 512 && Sj(j) } catch (at) { W(j, j.return, at) } } if (j === _) { V = null; break } if ($ = j.sibling, $ !== null) { $.return = j.return, V = $; break } V = j.return } } function hk(_) { for (; V !== null;) { var j = V; if (j === _) { V = null; break } var $ = j.sibling; if ($ !== null) { $.return = j.return, V = $; break } V = j.return } } function kk(_) { for (; V !== null;) { var j = V; try { switch (j.tag) { case 0: case 11: case 15: var $ = j.return; try { Rj(4, j) } catch (it) { W(j, $, it) } break; case 1: var _e = j.stateNode; if (typeof _e.componentDidMount == "function") { var et = j.return; try { _e.componentDidMount() } catch (it) { W(j, et, it) } } var tt = j.return; try { Sj(j) } catch (it) { W(j, tt, it) } break; case 5: var rt = j.return; try { Sj(j) } catch (it) { W(j, rt, it) } } } catch (it) { W(j, j.return, it) } if (j === _) { V = null; break } var nt = j.sibling; if (nt !== null) { nt.return = j.return, V = nt; break } V = j.return } } var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = 1 / 0, vk = null, Pi = !1, Qi = null, Si = null, wk = !1, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0; function L() { return K & 6 ? B() : Bk !== -1 ? Bk : Bk = B() } function lh(_) { return _.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Ck === 0 && (Ck = yc()), Ck) : (_ = C, _ !== 0 || (_ = window.event, _ = _ === void 0 ? 16 : jd(_.type)), _) : 1 } function mh(_, j, $, _e) { if (50 < zk) throw zk = 0, Ak = null, Error(p$3(185)); Ac(_, $, _e), (!(K & 2) || _ !== R) && (_ === R && (!(K & 2) && (rk |= $), T === 4 && Dk(_, Z)), Ek(_, _e), $ === 1 && K === 0 && !(j.mode & 1) && (Hj = B() + 500, fg && jg())) } function Ek(_, j) { var $ = _.callbackNode; wc(_, j); var _e = uc(_, _ === R ? Z : 0); if (_e === 0) $ !== null && bc($), _.callbackNode = null, _.callbackPriority = 0; else if (j = _e & -_e, _.callbackPriority !== j) { if ($ != null && bc($), j === 1) _.tag === 0 ? ig(Fk.bind(null, _)) : hg(Fk.bind(null, _)), Jf(function () { !(K & 6) && jg() }), $ = null; else { switch (Dc(_e)) { case 1: $ = fc; break; case 4: $ = gc; break; case 16: $ = hc; break; case 536870912: $ = jc; break; default: $ = hc }$ = Gk($, Hk.bind(null, _)) } _.callbackPriority = j, _.callbackNode = $ } } function Hk(_, j) { if (Bk = -1, Ck = 0, K & 6) throw Error(p$3(327)); var $ = _.callbackNode; if (Ik() && _.callbackNode !== $) return null; var _e = uc(_, _ === R ? Z : 0); if (_e === 0) return null; if (_e & 30 || _e & _.expiredLanes || j) j = Jk(_, _e); else { j = _e; var et = K; K |= 2; var tt = Kk(); (R !== _ || Z !== j) && (vk = null, Hj = B() + 500, Lk(_, j)); do try { Mk(); break } catch (nt) { Nk(_, nt) } while (!0); Qg(), nk.current = tt, K = et, Y !== null ? j = 0 : (R = null, Z = 0, j = T) } if (j !== 0) { if (j === 2 && (et = xc(_), et !== 0 && (_e = et, j = Ok(_, et))), j === 1) throw $ = qk, Lk(_, 0), Dk(_, _e), Ek(_, B()), $; if (j === 6) Dk(_, _e); else { if (et = _.current.alternate, !(_e & 30) && !Pk(et) && (j = Jk(_, _e), j === 2 && (tt = xc(_), tt !== 0 && (_e = tt, j = Ok(_, tt))), j === 1)) throw $ = qk, Lk(_, 0), Dk(_, _e), Ek(_, B()), $; switch (_.finishedWork = et, _.finishedLanes = _e, j) { case 0: case 1: throw Error(p$3(345)); case 2: Qk(_, uk, vk); break; case 3: if (Dk(_, _e), (_e & 130023424) === _e && (j = gk + 500 - B(), 10 < j)) { if (uc(_, 0) !== 0) break; if (et = _.suspendedLanes, (et & _e) !== _e) { L(), _.pingedLanes |= _.suspendedLanes & et; break } _.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), j); break } Qk(_, uk, vk); break; case 4: if (Dk(_, _e), (_e & 4194240) === _e) break; for (j = _.eventTimes, et = -1; 0 < _e;) { var rt = 31 - oc(_e); tt = 1 << rt, rt = j[rt], rt > et && (et = rt), _e &= ~tt } if (_e = et, _e = B() - _e, _e = (120 > _e ? 120 : 480 > _e ? 480 : 1080 > _e ? 1080 : 1920 > _e ? 1920 : 3e3 > _e ? 3e3 : 4320 > _e ? 4320 : 1960 * mk(_e / 1960)) - _e, 10 < _e) { _.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), _e); break } Qk(_, uk, vk); break; case 5: Qk(_, uk, vk); break; default: throw Error(p$3(329)) } } } return Ek(_, B()), _.callbackNode === $ ? Hk.bind(null, _) : null } function Ok(_, j) { var $ = tk; return _.current.memoizedState.isDehydrated && (Lk(_, j).flags |= 256), _ = Jk(_, j), _ !== 2 && (j = uk, uk = $, j !== null && Gj(j)), _ } function Gj(_) { uk === null ? uk = _ : uk.push.apply(uk, _) } function Pk(_) { for (var j = _; ;) { if (j.flags & 16384) { var $ = j.updateQueue; if ($ !== null && ($ = $.stores, $ !== null)) for (var _e = 0; _e < $.length; _e++) { var et = $[_e], tt = et.getSnapshot; et = et.value; try { if (!He(tt(), et)) return !1 } catch { return !1 } } } if ($ = j.child, j.subtreeFlags & 16384 && $ !== null) $.return = j, j = $; else { if (j === _) break; for (; j.sibling === null;) { if (j.return === null || j.return === _) return !0; j = j.return } j.sibling.return = j.return, j = j.sibling } } return !0 } function Dk(_, j) { for (j &= ~sk, j &= ~rk, _.suspendedLanes |= j, _.pingedLanes &= ~j, _ = _.expirationTimes; 0 < j;) { var $ = 31 - oc(j), _e = 1 << $; _[$] = -1, j &= ~_e } } function Fk(_) { if (K & 6) throw Error(p$3(327)); Ik(); var j = uc(_, 0); if (!(j & 1)) return Ek(_, B()), null; var $ = Jk(_, j); if (_.tag !== 0 && $ === 2) { var _e = xc(_); _e !== 0 && (j = _e, $ = Ok(_, _e)) } if ($ === 1) throw $ = qk, Lk(_, 0), Dk(_, j), Ek(_, B()), $; if ($ === 6) throw Error(p$3(345)); return _.finishedWork = _.current.alternate, _.finishedLanes = j, Qk(_, uk, vk), Ek(_, B()), null } function Rk(_, j) { var $ = K; K |= 1; try { return _(j) } finally { K = $, K === 0 && (Hj = B() + 500, fg && jg()) } } function Sk(_) { xk !== null && xk.tag === 0 && !(K & 6) && Ik(); var j = K; K |= 1; var $ = pk.transition, _e = C; try { if (pk.transition = null, C = 1, _) return _() } finally { C = _e, pk.transition = $, K = j, !(K & 6) && jg() } } function Ij() { gj = fj.current, E(fj) } function Lk(_, j) { _.finishedWork = null, _.finishedLanes = 0; var $ = _.timeoutHandle; if ($ !== -1 && (_.timeoutHandle = -1, Gf($)), Y !== null) for ($ = Y.return; $ !== null;) { var _e = $; switch (wg(_e), _e.tag) { case 1: _e = _e.type.childContextTypes, _e != null && $f(); break; case 3: Jh(), E(Wf), E(H), Oh(); break; case 5: Lh(_e); break; case 4: Jh(); break; case 13: E(M); break; case 19: E(M); break; case 10: Rg(_e.type._context); break; case 22: case 23: Ij() }$ = $.return } if (R = _, Y = _ = wh(_.current, null), Z = gj = j, T = 0, qk = null, sk = rk = hh = 0, uk = tk = null, Wg !== null) { for (j = 0; j < Wg.length; j++)if ($ = Wg[j], _e = $.interleaved, _e !== null) { $.interleaved = null; var et = _e.next, tt = $.pending; if (tt !== null) { var rt = tt.next; tt.next = et, _e.next = rt } $.pending = _e } Wg = null } return _ } function Nk(_, j) { do { var $ = Y; try { if (Qg(), Ph.current = ai, Sh) { for (var _e = N.memoizedState; _e !== null;) { var et = _e.queue; et !== null && (et.pending = null), _e = _e.next } Sh = !1 } if (Rh = 0, P = O = N = null, Th = !1, Uh = 0, ok.current = null, $ === null || $.return === null) { T = 1, qk = j, Y = null; break } e: { var tt = _, rt = $.return, nt = $, it = j; if (j = Z, nt.flags |= 32768, it !== null && typeof it == "object" && typeof it.then == "function") { var st = it, ot = nt, ft = ot.tag; if (!(ot.mode & 1) && (ft === 0 || ft === 11 || ft === 15)) { var at = ot.alternate; at ? (ot.updateQueue = at.updateQueue, ot.memoizedState = at.memoizedState, ot.lanes = at.lanes) : (ot.updateQueue = null, ot.memoizedState = null) } var dt = Vi(rt); if (dt !== null) { dt.flags &= -257, Wi(dt, rt, nt, tt, j), dt.mode & 1 && Ti(tt, st, j), j = dt, it = st; var pt = j.updateQueue; if (pt === null) { var ht = new Set; ht.add(it), j.updateQueue = ht } else pt.add(it); break e } else { if (!(j & 1)) { Ti(tt, st, j), uj(); break e } it = Error(p$3(426)) } } else if (I && nt.mode & 1) { var xt = Vi(rt); if (xt !== null) { !(xt.flags & 65536) && (xt.flags |= 256), Wi(xt, rt, nt, tt, j), Jg(Ki(it, nt)); break e } } tt = it = Ki(it, nt), T !== 4 && (T = 2), tk === null ? tk = [tt] : tk.push(tt), tt = rt; do { switch (tt.tag) { case 3: tt.flags |= 65536, j &= -j, tt.lanes |= j; var ct = Oi(tt, it, j); fh(tt, ct); break e; case 1: nt = it; var ut = tt.type, lt = tt.stateNode; if (!(tt.flags & 128) && (typeof ut.getDerivedStateFromError == "function" || lt !== null && typeof lt.componentDidCatch == "function" && (Si === null || !Si.has(lt)))) { tt.flags |= 65536, j &= -j, tt.lanes |= j; var mt = Ri(tt, nt, j); fh(tt, mt); break e } }tt = tt.return } while (tt !== null) } Tk($) } catch (yt) { j = yt, Y === $ && $ !== null && (Y = $ = $.return); continue } break } while (!0) } function Kk() { var _ = nk.current; return nk.current = ai, _ === null ? ai : _ } function uj() { (T === 0 || T === 3 || T === 2) && (T = 4), R === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R, Z) } function Jk(_, j) { var $ = K; K |= 2; var _e = Kk(); (R !== _ || Z !== j) && (vk = null, Lk(_, j)); do try { Uk(); break } catch (et) { Nk(_, et) } while (!0); if (Qg(), K = $, nk.current = _e, Y !== null) throw Error(p$3(261)); return R = null, Z = 0, T } function Uk() { for (; Y !== null;)Vk(Y) } function Mk() { for (; Y !== null && !cc();)Vk(Y) } function Vk(_) { var j = Wk(_.alternate, _, gj); _.memoizedProps = _.pendingProps, j === null ? Tk(_) : Y = j, ok.current = null } function Tk(_) { var j = _; do { var $ = j.alternate; if (_ = j.return, j.flags & 32768) { if ($ = Jj($, j), $ !== null) { $.flags &= 32767, Y = $; return } if (_ !== null) _.flags |= 32768, _.subtreeFlags = 0, _.deletions = null; else { T = 6, Y = null; return } } else if ($ = Fj($, j, gj), $ !== null) { Y = $; return } if (j = j.sibling, j !== null) { Y = j; return } Y = j = _ } while (j !== null); T === 0 && (T = 5) } function Qk(_, j, $) { var _e = C, et = pk.transition; try { pk.transition = null, C = 1, Xk(_, j, $, _e) } finally { pk.transition = et, C = _e } return null } function Xk(_, j, $, _e) { do Ik(); while (xk !== null); if (K & 6) throw Error(p$3(327)); $ = _.finishedWork; var et = _.finishedLanes; if ($ === null) return null; if (_.finishedWork = null, _.finishedLanes = 0, $ === _.current) throw Error(p$3(177)); _.callbackNode = null, _.callbackPriority = 0; var tt = $.lanes | $.childLanes; if (Bc(_, tt), _ === R && (Y = R = null, Z = 0), !($.subtreeFlags & 2064) && !($.flags & 2064) || wk || (wk = !0, Gk(hc, function () { return Ik(), null })), tt = ($.flags & 15990) !== 0, $.subtreeFlags & 15990 || tt) { tt = pk.transition, pk.transition = null; var rt = C; C = 1; var nt = K; K |= 4, ok.current = null, Pj(_, $), ek($, _), Oe(Df), dd = !!Cf, Df = Cf = null, _.current = $, ik($), dc(), K = nt, C = rt, pk.transition = tt } else _.current = $; if (wk && (wk = !1, xk = _, yk = et), tt = _.pendingLanes, tt === 0 && (Si = null), mc($.stateNode), Ek(_, B()), j !== null) for (_e = _.onRecoverableError, $ = 0; $ < j.length; $++)et = j[$], _e(et.value, { componentStack: et.stack, digest: et.digest }); if (Pi) throw Pi = !1, _ = Qi, Qi = null, _; return yk & 1 && _.tag !== 0 && Ik(), tt = _.pendingLanes, tt & 1 ? _ === Ak ? zk++ : (zk = 0, Ak = _) : zk = 0, jg(), null } function Ik() { if (xk !== null) { var _ = Dc(yk), j = pk.transition, $ = C; try { if (pk.transition = null, C = 16 > _ ? 16 : _, xk === null) var _e = !1; else { if (_ = xk, xk = null, yk = 0, K & 6) throw Error(p$3(331)); var et = K; for (K |= 4, V = _.current; V !== null;) { var tt = V, rt = tt.child; if (V.flags & 16) { var nt = tt.deletions; if (nt !== null) { for (var it = 0; it < nt.length; it++) { var st = nt[it]; for (V = st; V !== null;) { var ot = V; switch (ot.tag) { case 0: case 11: case 15: Qj(8, ot, tt) }var ft = ot.child; if (ft !== null) ft.return = ot, V = ft; else for (; V !== null;) { ot = V; var at = ot.sibling, dt = ot.return; if (Tj(ot), ot === st) { V = null; break } if (at !== null) { at.return = dt, V = at; break } V = dt } } } var pt = tt.alternate; if (pt !== null) { var ht = pt.child; if (ht !== null) { pt.child = null; do { var xt = ht.sibling; ht.sibling = null, ht = xt } while (ht !== null) } } V = tt } } if (tt.subtreeFlags & 2064 && rt !== null) rt.return = tt, V = rt; else e: for (; V !== null;) { if (tt = V, tt.flags & 2048) switch (tt.tag) { case 0: case 11: case 15: Qj(9, tt, tt.return) }var ct = tt.sibling; if (ct !== null) { ct.return = tt.return, V = ct; break e } V = tt.return } } var ut = _.current; for (V = ut; V !== null;) { rt = V; var lt = rt.child; if (rt.subtreeFlags & 2064 && lt !== null) lt.return = rt, V = lt; else e: for (rt = ut; V !== null;) { if (nt = V, nt.flags & 2048) try { switch (nt.tag) { case 0: case 11: case 15: Rj(9, nt) } } catch (yt) { W(nt, nt.return, yt) } if (nt === rt) { V = null; break e } var mt = nt.sibling; if (mt !== null) { mt.return = nt.return, V = mt; break e } V = nt.return } } if (K = et, jg(), lc && typeof lc.onPostCommitFiberRoot == "function") try { lc.onPostCommitFiberRoot(kc, _) } catch { } _e = !0 } return _e } finally { C = $, pk.transition = j } } return !1 } function Yk(_, j, $) { j = Ki($, j), j = Oi(_, j, 1), _ = dh(_, j, 1), j = L(), _ !== null && (Ac(_, 1, j), Ek(_, j)) } function W(_, j, $) { if (_.tag === 3) Yk(_, _, $); else for (; j !== null;) { if (j.tag === 3) { Yk(j, _, $); break } else if (j.tag === 1) { var _e = j.stateNode; if (typeof j.type.getDerivedStateFromError == "function" || typeof _e.componentDidCatch == "function" && (Si === null || !Si.has(_e))) { _ = Ki($, _), _ = Ri(j, _, 1), j = dh(j, _, 1), _ = L(), j !== null && (Ac(j, 1, _), Ek(j, _)); break } } j = j.return } } function Ui(_, j, $) { var _e = _.pingCache; _e !== null && _e.delete(j), j = L(), _.pingedLanes |= _.suspendedLanes & $, R === _ && (Z & $) === $ && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - gk ? Lk(_, 0) : sk |= $), Ek(_, j) } function Zk(_, j) { j === 0 && (_.mode & 1 ? (j = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : j = 1); var $ = L(); _ = Zg(_, j), _ !== null && (Ac(_, j, $), Ek(_, $)) } function vj(_) { var j = _.memoizedState, $ = 0; j !== null && ($ = j.retryLane), Zk(_, $) } function ck(_, j) { var $ = 0; switch (_.tag) { case 13: var _e = _.stateNode, et = _.memoizedState; et !== null && ($ = et.retryLane); break; case 19: _e = _.stateNode; break; default: throw Error(p$3(314)) }_e !== null && _e.delete(j), Zk(_, $) } var Wk; Wk = function (_, j, $) { if (_ !== null) if (_.memoizedProps !== j.pendingProps || Wf.current) Ug = !0; else { if (!(_.lanes & $) && !(j.flags & 128)) return Ug = !1, zj(_, j, $); Ug = !!(_.flags & 131072) } else Ug = !1, I && j.flags & 1048576 && ug(j, ng, j.index); switch (j.lanes = 0, j.tag) { case 2: var _e = j.type; jj(_, j), _ = j.pendingProps; var et = Yf(j, H.current); Tg(j, $), et = Xh(null, j, _e, _, et, $); var tt = bi(); return j.flags |= 1, typeof et == "object" && et !== null && typeof et.render == "function" && et.$$typeof === void 0 ? (j.tag = 1, j.memoizedState = null, j.updateQueue = null, Zf(_e) ? (tt = !0, cg(j)) : tt = !1, j.memoizedState = et.state !== null && et.state !== void 0 ? et.state : null, ah(j), et.updater = nh, j.stateNode = et, et._reactInternals = j, rh(j, _e, _, $), j = kj(null, j, _e, !0, tt, $)) : (j.tag = 0, I && tt && vg(j), Yi(null, j, et, $), j = j.child), j; case 16: _e = j.elementType; e: { switch (jj(_, j), _ = j.pendingProps, et = _e._init, _e = et(_e._payload), j.type = _e, et = j.tag = $k(_e), _ = Lg(_e, _), et) { case 0: j = dj(null, j, _e, _, $); break e; case 1: j = ij(null, j, _e, _, $); break e; case 11: j = Zi(null, j, _e, _, $); break e; case 14: j = aj(null, j, _e, Lg(_e.type, _), $); break e }throw Error(p$3(306, _e, "")) } return j; case 0: return _e = j.type, et = j.pendingProps, et = j.elementType === _e ? et : Lg(_e, et), dj(_, j, _e, et, $); case 1: return _e = j.type, et = j.pendingProps, et = j.elementType === _e ? et : Lg(_e, et), ij(_, j, _e, et, $); case 3: e: { if (lj(j), _ === null) throw Error(p$3(387)); _e = j.pendingProps, tt = j.memoizedState, et = tt.element, bh(_, j), gh(j, _e, null, $); var rt = j.memoizedState; if (_e = rt.element, tt.isDehydrated) if (tt = { element: _e, isDehydrated: !1, cache: rt.cache, pendingSuspenseBoundaries: rt.pendingSuspenseBoundaries, transitions: rt.transitions }, j.updateQueue.baseState = tt, j.memoizedState = tt, j.flags & 256) { et = Ki(Error(p$3(423)), j), j = mj(_, j, _e, $, et); break e } else if (_e !== et) { et = Ki(Error(p$3(424)), j), j = mj(_, j, _e, $, et); break e } else for (yg = Lf(j.stateNode.containerInfo.firstChild), xg = j, I = !0, zg = null, $ = Ch(j, null, _e, $), j.child = $; $;)$.flags = $.flags & -3 | 4096, $ = $.sibling; else { if (Ig(), _e === et) { j = $i(_, j, $); break e } Yi(_, j, _e, $) } j = j.child } return j; case 5: return Kh(j), _ === null && Eg(j), _e = j.type, et = j.pendingProps, tt = _ !== null ? _.memoizedProps : null, rt = et.children, Ef(_e, et) ? rt = null : tt !== null && Ef(_e, tt) && (j.flags |= 32), hj(_, j), Yi(_, j, rt, $), j.child; case 6: return _ === null && Eg(j), null; case 13: return pj(_, j, $); case 4: return Ih(j, j.stateNode.containerInfo), _e = j.pendingProps, _ === null ? j.child = Bh(j, null, _e, $) : Yi(_, j, _e, $), j.child; case 11: return _e = j.type, et = j.pendingProps, et = j.elementType === _e ? et : Lg(_e, et), Zi(_, j, _e, et, $); case 7: return Yi(_, j, j.pendingProps, $), j.child; case 8: return Yi(_, j, j.pendingProps.children, $), j.child; case 12: return Yi(_, j, j.pendingProps.children, $), j.child; case 10: e: { if (_e = j.type._context, et = j.pendingProps, tt = j.memoizedProps, rt = et.value, G(Mg, _e._currentValue), _e._currentValue = rt, tt !== null) if (He(tt.value, rt)) { if (tt.children === et.children && !Wf.current) { j = $i(_, j, $); break e } } else for (tt = j.child, tt !== null && (tt.return = j); tt !== null;) { var nt = tt.dependencies; if (nt !== null) { rt = tt.child; for (var it = nt.firstContext; it !== null;) { if (it.context === _e) { if (tt.tag === 1) { it = ch(-1, $ & -$), it.tag = 2; var st = tt.updateQueue; if (st !== null) { st = st.shared; var ot = st.pending; ot === null ? it.next = it : (it.next = ot.next, ot.next = it), st.pending = it } } tt.lanes |= $, it = tt.alternate, it !== null && (it.lanes |= $), Sg(tt.return, $, j), nt.lanes |= $; break } it = it.next } } else if (tt.tag === 10) rt = tt.type === j.type ? null : tt.child; else if (tt.tag === 18) { if (rt = tt.return, rt === null) throw Error(p$3(341)); rt.lanes |= $, nt = rt.alternate, nt !== null && (nt.lanes |= $), Sg(rt, $, j), rt = tt.sibling } else rt = tt.child; if (rt !== null) rt.return = tt; else for (rt = tt; rt !== null;) { if (rt === j) { rt = null; break } if (tt = rt.sibling, tt !== null) { tt.return = rt.return, rt = tt; break } rt = rt.return } tt = rt } Yi(_, j, et.children, $), j = j.child } return j; case 9: return et = j.type, _e = j.pendingProps.children, Tg(j, $), et = Vg(et), _e = _e(et), j.flags |= 1, Yi(_, j, _e, $), j.child; case 14: return _e = j.type, et = Lg(_e, j.pendingProps), et = Lg(_e.type, et), aj(_, j, _e, et, $); case 15: return cj(_, j, j.type, j.pendingProps, $); case 17: return _e = j.type, et = j.pendingProps, et = j.elementType === _e ? et : Lg(_e, et), jj(_, j), j.tag = 1, Zf(_e) ? (_ = !0, cg(j)) : _ = !1, Tg(j, $), ph(j, _e, et), rh(j, _e, et, $), kj(null, j, _e, !0, _, $); case 19: return yj(_, j, $); case 22: return ej(_, j, $) }throw Error(p$3(156, j.tag)) }; function Gk(_, j) { return ac(_, j) } function al(_, j, $, _e) { this.tag = _, this.key = $, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = j, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = _e, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Bg(_, j, $, _e) { return new al(_, j, $, _e) } function bj(_) { return _ = _.prototype, !(!_ || !_.isReactComponent) } function $k(_) { if (typeof _ == "function") return bj(_) ? 1 : 0; if (_ != null) { if (_ = _.$$typeof, _ === Da) return 11; if (_ === Ga) return 14 } return 2 } function wh(_, j) { var $ = _.alternate; return $ === null ? ($ = Bg(_.tag, j, _.key, _.mode), $.elementType = _.elementType, $.type = _.type, $.stateNode = _.stateNode, $.alternate = _, _.alternate = $) : ($.pendingProps = j, $.type = _.type, $.flags = 0, $.subtreeFlags = 0, $.deletions = null), $.flags = _.flags & 14680064, $.childLanes = _.childLanes, $.lanes = _.lanes, $.child = _.child, $.memoizedProps = _.memoizedProps, $.memoizedState = _.memoizedState, $.updateQueue = _.updateQueue, j = _.dependencies, $.dependencies = j === null ? null : { lanes: j.lanes, firstContext: j.firstContext }, $.sibling = _.sibling, $.index = _.index, $.ref = _.ref, $ } function yh(_, j, $, _e, et, tt) { var rt = 2; if (_e = _, typeof _ == "function") bj(_) && (rt = 1); else if (typeof _ == "string") rt = 5; else e: switch (_) { case ya: return Ah($.children, et, tt, j); case za: rt = 8, et |= 8; break; case Aa: return _ = Bg(12, $, j, et | 2), _.elementType = Aa, _.lanes = tt, _; case Ea: return _ = Bg(13, $, j, et), _.elementType = Ea, _.lanes = tt, _; case Fa: return _ = Bg(19, $, j, et), _.elementType = Fa, _.lanes = tt, _; case Ia: return qj($, et, tt, j); default: if (typeof _ == "object" && _ !== null) switch (_.$$typeof) { case Ba: rt = 10; break e; case Ca: rt = 9; break e; case Da: rt = 11; break e; case Ga: rt = 14; break e; case Ha: rt = 16, _e = null; break e }throw Error(p$3(130, _ == null ? _ : typeof _, "")) }return j = Bg(rt, $, j, et), j.elementType = _, j.type = _e, j.lanes = tt, j } function Ah(_, j, $, _e) { return _ = Bg(7, _, _e, j), _.lanes = $, _ } function qj(_, j, $, _e) { return _ = Bg(22, _, _e, j), _.elementType = Ia, _.lanes = $, _.stateNode = { isHidden: !1 }, _ } function xh(_, j, $) { return _ = Bg(6, _, null, j), _.lanes = $, _ } function zh(_, j, $) { return j = Bg(4, _.children !== null ? _.children : [], _.key, j), j.lanes = $, j.stateNode = { containerInfo: _.containerInfo, pendingChildren: null, implementation: _.implementation }, j } function bl(_, j, $, _e, et) { this.tag = j, this.containerInfo = _, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = _e, this.onRecoverableError = et, this.mutableSourceEagerHydrationData = null } function cl(_, j, $, _e, et, tt, rt, nt, it) { return _ = new bl(_, j, $, nt, it), j === 1 ? (j = 1, tt === !0 && (j |= 8)) : j = 0, tt = Bg(3, null, null, j), _.current = tt, tt.stateNode = _, tt.memoizedState = { element: _e, isDehydrated: $, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ah(tt), _ } function dl(_, j, $) { var _e = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: wa, key: _e == null ? null : "" + _e, children: _, containerInfo: j, implementation: $ } } function el(_) { if (!_) return Vf; _ = _._reactInternals; e: { if (Vb(_) !== _ || _.tag !== 1) throw Error(p$3(170)); var j = _; do { switch (j.tag) { case 3: j = j.stateNode.context; break e; case 1: if (Zf(j.type)) { j = j.stateNode.__reactInternalMemoizedMergedChildContext; break e } }j = j.return } while (j !== null); throw Error(p$3(171)) } if (_.tag === 1) { var $ = _.type; if (Zf($)) return bg(_, $, j) } return j } function fl(_, j, $, _e, et, tt, rt, nt, it) { return _ = cl($, _e, !0, _, et, tt, rt, nt, it), _.context = el(null), $ = _.current, _e = L(), et = lh($), tt = ch(_e, et), tt.callback = j ?? null, dh($, tt, et), _.current.lanes = et, Ac(_, et, _e), Ek(_, _e), _ } function gl(_, j, $, _e) { var et = j.current, tt = L(), rt = lh(et); return $ = el($), j.context === null ? j.context = $ : j.pendingContext = $, j = ch(tt, rt), j.payload = { element: _ }, _e = _e === void 0 ? null : _e, _e !== null && (j.callback = _e), _ = dh(et, j, rt), _ !== null && (mh(_, et, rt, tt), eh(_, et, rt)), rt } function hl(_) { if (_ = _.current, !_.child) return null; switch (_.child.tag) { case 5: return _.child.stateNode; default: return _.child.stateNode } } function il(_, j) { if (_ = _.memoizedState, _ !== null && _.dehydrated !== null) { var $ = _.retryLane; _.retryLane = $ !== 0 && $ < j ? $ : j } } function jl(_, j) { il(_, j), (_ = _.alternate) && il(_, j) } function kl() { return null } var ll = typeof reportError == "function" ? reportError : function (_) { console.error(_) }; function ml(_) { this._internalRoot = _ } nl.prototype.render = ml.prototype.render = function (_) { var j = this._internalRoot; if (j === null) throw Error(p$3(409)); gl(_, j, null, null) }; nl.prototype.unmount = ml.prototype.unmount = function () { var _ = this._internalRoot; if (_ !== null) { this._internalRoot = null; var j = _.containerInfo; Sk(function () { gl(null, _, null, null) }), j[uf] = null } }; function nl(_) { this._internalRoot = _ } nl.prototype.unstable_scheduleHydration = function (_) { if (_) { var j = Hc(); _ = { blockedOn: null, target: _, priority: j }; for (var $ = 0; $ < Qc.length && j !== 0 && j < Qc[$].priority; $++); Qc.splice($, 0, _), $ === 0 && Vc(_) } }; function ol(_) { return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11) } function pl(_) { return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11 && (_.nodeType !== 8 || _.nodeValue !== " react-mount-point-unstable ")) } function ql() { } function rl(_, j, $, _e, et) { if (et) { if (typeof _e == "function") { var tt = _e; _e = function () { var st = hl(rt); tt.call(st) } } var rt = fl(j, _e, _, 0, null, !1, !1, "", ql); return _._reactRootContainer = rt, _[uf] = rt.current, sf(_.nodeType === 8 ? _.parentNode : _), Sk(), rt } for (; et = _.lastChild;)_.removeChild(et); if (typeof _e == "function") { var nt = _e; _e = function () { var st = hl(it); nt.call(st) } } var it = cl(_, 0, !1, null, null, !1, !1, "", ql); return _._reactRootContainer = it, _[uf] = it.current, sf(_.nodeType === 8 ? _.parentNode : _), Sk(function () { gl(j, it, $, _e) }), it } function sl(_, j, $, _e, et) { var tt = $._reactRootContainer; if (tt) { var rt = tt; if (typeof et == "function") { var nt = et; et = function () { var it = hl(rt); nt.call(it) } } gl(j, rt, _, et) } else rt = rl($, j, _, et, _e); return hl(rt) } Ec = function (_) { switch (_.tag) { case 3: var j = _.stateNode; if (j.current.memoizedState.isDehydrated) { var $ = tc(j.pendingLanes); $ !== 0 && (Cc(j, $ | 1), Ek(j, B()), !(K & 6) && (Hj = B() + 500, jg())) } break; case 13: Sk(function () { var _e = Zg(_, 1); if (_e !== null) { var et = L(); mh(_e, _, 1, et) } }), jl(_, 1) } }; Fc = function (_) { if (_.tag === 13) { var j = Zg(_, 134217728); if (j !== null) { var $ = L(); mh(j, _, 134217728, $) } jl(_, 134217728) } }; Gc = function (_) { if (_.tag === 13) { var j = lh(_), $ = Zg(_, j); if ($ !== null) { var _e = L(); mh($, _, j, _e) } jl(_, j) } }; Hc = function () { return C }; Ic = function (_, j) { var $ = C; try { return C = _, j() } finally { C = $ } }; yb = function (_, j, $) { switch (j) { case "input": if (bb(_, $), j = $.name, $.type === "radio" && j != null) { for ($ = _; $.parentNode;)$ = $.parentNode; for ($ = $.querySelectorAll("input[name=" + JSON.stringify("" + j) + '][type="radio"]'), j = 0; j < $.length; j++) { var _e = $[j]; if (_e !== _ && _e.form === _.form) { var et = Db(_e); if (!et) throw Error(p$3(90)); Wa(_e), bb(_e, et) } } } break; case "textarea": ib(_, $); break; case "select": j = $.value, j != null && fb(_, !!$.multiple, j, !1) } }; Gb = Rk; Hb = Sk; var tl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function (_) { return _ = Zb(_), _ === null ? null : _.stateNode }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!wl.isDisabled && wl.supportsFiber) try { kc = wl.inject(vl), lc = wl } catch { } } reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl; reactDom_production_min.createPortal = function (_, j) { var $ = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!ol(j)) throw Error(p$3(200)); return dl(_, j, null, $) }; reactDom_production_min.createRoot = function (_, j) { if (!ol(_)) throw Error(p$3(299)); var $ = !1, _e = "", et = ll; return j != null && (j.unstable_strictMode === !0 && ($ = !0), j.identifierPrefix !== void 0 && (_e = j.identifierPrefix), j.onRecoverableError !== void 0 && (et = j.onRecoverableError)), j = cl(_, 1, !1, null, null, $, !1, _e, et), _[uf] = j.current, sf(_.nodeType === 8 ? _.parentNode : _), new ml(j) }; reactDom_production_min.findDOMNode = function (_) { if (_ == null) return null; if (_.nodeType === 1) return _; var j = _._reactInternals; if (j === void 0) throw typeof _.render == "function" ? Error(p$3(188)) : (_ = Object.keys(_).join(","), Error(p$3(268, _))); return _ = Zb(j), _ = _ === null ? null : _.stateNode, _ }; reactDom_production_min.flushSync = function (_) { return Sk(_) }; reactDom_production_min.hydrate = function (_, j, $) { if (!pl(j)) throw Error(p$3(200)); return sl(null, _, j, !0, $) }; reactDom_production_min.hydrateRoot = function (_, j, $) { if (!ol(_)) throw Error(p$3(405)); var _e = $ != null && $.hydratedSources || null, et = !1, tt = "", rt = ll; if ($ != null && ($.unstable_strictMode === !0 && (et = !0), $.identifierPrefix !== void 0 && (tt = $.identifierPrefix), $.onRecoverableError !== void 0 && (rt = $.onRecoverableError)), j = fl(j, null, _, 1, $ ?? null, et, !1, tt, rt), _[uf] = j.current, sf(_), _e) for (_ = 0; _ < _e.length; _++)$ = _e[_], et = $._getVersion, et = et($._source), j.mutableSourceEagerHydrationData == null ? j.mutableSourceEagerHydrationData = [$, et] : j.mutableSourceEagerHydrationData.push($, et); return new nl(j) }; reactDom_production_min.render = function (_, j, $) { if (!pl(j)) throw Error(p$3(200)); return sl(null, _, j, !1, $) }; reactDom_production_min.unmountComponentAtNode = function (_) { if (!pl(_)) throw Error(p$3(40)); return _._reactRootContainer ? (Sk(function () { sl(null, null, _, !1, function () { _._reactRootContainer = null, _[uf] = null }) }), !0) : !1 }; reactDom_production_min.unstable_batchedUpdates = Rk; reactDom_production_min.unstable_renderSubtreeIntoContainer = function (_, j, $, _e) { if (!pl($)) throw Error(p$3(200)); if (_ == null || _._reactInternals === void 0) throw Error(p$3(38)); return sl(_, j, $, !1, _e) }; reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608"; function checkDCE() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE) } catch (_) { console.error(_) } } checkDCE(), reactDom.exports = reactDom_production_min; var reactDomExports = reactDom.exports, m$3 = reactDomExports; client.createRoot = m$3.createRoot, client.hydrateRoot = m$3.hydrateRoot; var __assign = function () { return __assign = Object.assign || function (j) { for (var $, _e = 1, et = arguments.length; _e < et; _e++) { $ = arguments[_e]; for (var tt in $) Object.prototype.hasOwnProperty.call($, tt) && (j[tt] = $[tt]) } return j }, __assign.apply(this, arguments) }; function useEventListener(_, j, $) { var _e = reactExports.useRef(j); reactExports.useEffect(function () { _e.current = j }), reactExports.useEffect(function () { var et = $ === void 0 ? window : $, tt = function (rt) { return _e.current(rt) }; return et == null || et.addEventListener(_, tt), function () { et == null || et.removeEventListener(_, tt) } }, [_, $]) } var useDeviceInfo = function () { var _ = reactExports.useState({ info: "", Android: function () { return null }, BlackBerry: function () { return null }, IEMobile: function () { return null }, iOS: function () { return null }, iPad: function () { return null }, OperaMini: function () { return null }, any: function () { return !1 } }), j = _[0], $ = _[1]; return reactExports.useEffect(function () { if (typeof navigator < "u") { var _e = navigator.userAgent; $(function (et) { return __assign(__assign({}, et), { info: _e, Android: function () { return _e.match(/Android/i) }, BlackBerry: function () { return _e.match(/BlackBerry/i) }, IEMobile: function () { return _e.match(/IEMobile/i) }, iOS: function () { return _e.match(/iPhone|iPad|iPod/i) }, iPad: function () { return !!(_e.match(/Mac/) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2) }, OperaMini: function () { return _e.match(/Opera Mini/i) }, any: function () { var tt, rt, nt, it, st; return !!(!((tt = et.Android()) === null || tt === void 0) && tt.length || !((rt = et.BlackBerry()) === null || rt === void 0) && rt.length || !((nt = et.iOS()) === null || nt === void 0) && nt.length || et.iPad() || !((it = et.OperaMini()) === null || it === void 0) && it.length || !((st = et.IEMobile()) === null || st === void 0) && st.length) } }) }) } }, []), j }; function findInArray(_, j) { for (var $ = [], _e = 2; _e < arguments.length; _e++)$[_e - 2] = arguments[_e]; if (typeof j != "function") throw new TypeError("callback must be a function"); for (var et = Object(_), tt = et.length >>> 0, rt = $[2], nt = 0; nt < tt; nt++) { var it = et[nt]; if (j.call(rt, it, nt, et)) return it } } function CursorCore(_) { var j = _.clickables, $ = j === void 0 ? ["a", 'input[type="text"]', 'input[type="email"]', 'input[type="number"]', 'input[type="submit"]', 'input[type="image"]', "label[for]", "select", "textarea", "button", ".link"] : j, _e = _.children, et = _.color, tt = et === void 0 ? "220, 90, 90" : et, rt = _.innerScale, nt = rt === void 0 ? .6 : rt, it = _.innerSize, st = it === void 0 ? 8 : it, ot = _.innerStyle, ft = _.outerAlpha, at = ft === void 0 ? .4 : ft, dt = _.outerScale, pt = dt === void 0 ? 6 : dt, ht = _.outerSize, xt = ht === void 0 ? 8 : ht, ct = _.outerStyle, ut = _.showSystemCursor, lt = ut === void 0 ? !1 : ut, mt = _.trailingSpeed, yt = mt === void 0 ? 8 : mt, gt = reactExports.useMemo(function () { return { children: _e, color: tt, innerScale: nt, innerSize: st, innerStyle: ot, outerAlpha: at, outerScale: pt, outerSize: xt, outerStyle: ct } }, [_e, tt, nt, st, ot, at, pt, xt, ct]), St = reactExports.useRef(null), bt = reactExports.useRef(null), _t = reactExports.useRef(null), Mt = reactExports.useRef(null), It = reactExports.useState({ x: 0, y: 0 }), Rt = It[0], Lt = It[1], Vt = reactExports.useState(!1), At = Vt[0], Pt = Vt[1], kt = reactExports.useState(gt), vt = kt[0], Et = kt[1], Ct = reactExports.useState(!1), wt = Ct[0], Tt = Ct[1], jt = reactExports.useState(!1), Ft = jt[0], Dt = jt[1], Ot = reactExports.useRef(0), Nt = reactExports.useRef(0), Yt = reactExports.useCallback(function (Gt) { var Bt = Gt.clientX, Wt = Gt.clientY; Lt({ x: Bt, y: Wt }), bt.current !== null && (bt.current.style.top = "".concat(Wt, "px"), bt.current.style.left = "".concat(Bt, "px")), Ot.current = Bt, Nt.current = Wt }, []), Xt = reactExports.useCallback(function (Gt) { Mt.current !== void 0 && (Rt.x += (Ot.current - Rt.x) / yt, Rt.y += (Nt.current - Rt.y) / yt, St.current !== null && (St.current.style.top = "".concat(Rt.y, "px"), St.current.style.left = "".concat(Rt.x, "px"))), Mt.current = Gt, _t.current = requestAnimationFrame(Xt) }, [_t]); reactExports.useEffect(function () { return _t.current = requestAnimationFrame(Xt), function () { _t.current !== null && cancelAnimationFrame(_t.current) } }, [Xt]); var Kt = function (Gt, Bt) { return "".concat(parseInt(String(Gt * Bt)), "px") }, Ht = reactExports.useCallback(function (Gt, Bt, Wt) { Gt && (Gt.style.height = Kt(Bt, Wt), Gt.style.width = Kt(Bt, Wt)) }, []), qt = reactExports.useCallback(function () { return Tt(!0) }, []), zt = reactExports.useCallback(function () { return Tt(!1) }, []), $t = reactExports.useCallback(function () { return Pt(!0) }, []), Jt = reactExports.useCallback(function () { return Pt(!1) }, []); useEventListener("mousemove", Yt), useEventListener("mousedown", qt), useEventListener("mouseup", zt), useEventListener("mouseover", $t), useEventListener("mouseout", Jt), reactExports.useEffect(function () { wt ? (Ht(bt.current, vt.innerSize, vt.innerScale), Ht(St.current, vt.outerSize, vt.outerScale)) : (Ht(bt.current, vt.innerSize, 1), Ht(St.current, vt.outerSize, 1)) }, [vt.innerSize, vt.innerScale, vt.outerSize, vt.outerScale, Ht, wt]), reactExports.useEffect(function () { Ft && (Ht(bt.current, vt.innerSize, vt.innerScale * 1.2), Ht(St.current, vt.outerSize, vt.outerScale * 1.4)) }, [vt.innerSize, vt.innerScale, vt.outerSize, vt.outerScale, Ht, Ft]), reactExports.useEffect(function () { bt.current == null || St.current == null || (At ? (bt.current.style.opacity = "1", St.current.style.opacity = "1") : (bt.current.style.opacity = "0", St.current.style.opacity = "0")) }, [At]), reactExports.useEffect(function () { var Gt = document.querySelectorAll($.map(function (Bt) { return typeof Bt == "object" && (Bt != null && Bt.target) ? Bt.target : Bt ?? "" }).join(",")); return Gt.forEach(function (Bt) { lt || (Bt.style.cursor = "none"); var Wt = typeof $ == "object" ? findInArray($, function (Zt) { return typeof Zt == "object" && Bt.matches(Zt.target) }) : {}, Ut = __assign(__assign({}, gt), Wt); Bt.addEventListener("mouseover", function () { Tt(!0), Et(Ut) }), Bt.addEventListener("click", function () { Tt(!0), Dt(!1) }), Bt.addEventListener("mousedown", function () { Dt(!0) }), Bt.addEventListener("mouseup", function () { Tt(!0) }), Bt.addEventListener("mouseout", function () { Tt(!1), Dt(!1), Et(gt) }) }), function () { Gt.forEach(function (Bt) { var Wt = typeof $ == "object" ? findInArray($, function (Zt) { return typeof Zt == "object" && Bt.matches(Zt.target) }) : {}, Ut = __assign(__assign({}, gt), Wt); Bt.removeEventListener("mouseover", function () { Tt(!0), Et(Ut) }), Bt.removeEventListener("click", function () { Tt(!0), Dt(!1) }), Bt.removeEventListener("mousedown", function () { Dt(!0) }), Bt.removeEventListener("mouseup", function () { Tt(!0) }), Bt.removeEventListener("mouseout", function () { Tt(!1), Dt(!1), Et(gt) }) }) } }, [wt, $, lt, gt]), reactExports.useEffect(function () { typeof window == "object" && !lt && (document.body.style.cursor = "none") }, [lt]); var er = { zIndex: 999, display: "flex", justifyContent: "center", alignItems: "center", position: "fixed", borderRadius: "50%", pointerEvents: "none", transform: "translate(-50%, -50%)", transition: "opacity 0.15s ease-in-out, height 0.2s ease-in-out, width 0.2s ease-in-out" }, Qt = { cursorInner: __assign(__assign({ width: vt.children ? "auto" : vt.innerSize, height: vt.children ? "auto" : vt.innerSize, backgroundColor: vt.children ? "transparent" : "rgba(".concat(vt.color, ", 1)") }, er), vt.innerStyle && vt.innerStyle), cursorOuter: __assign(__assign({ width: vt.outerSize, height: vt.outerSize, backgroundColor: "rgba(".concat(vt.color, ", ").concat(vt.outerAlpha, ")") }, er), vt.outerStyle && vt.outerStyle) }; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { ref: St, style: Qt.cursorOuter }), jsxRuntimeExports.jsx("div", __assign({ ref: bt, style: Qt.cursorInner }, { children: jsxRuntimeExports.jsx("div", __assign({ style: { opacity: vt.children ? 1 : 0, transition: "opacity 0.3s ease-in-out" } }, { children: vt.children })) }))] }) } function AnimatedCursor(_) { var j = _.children, $ = _.clickables, _e = _.color, et = _.innerScale, tt = _.innerSize, rt = _.innerStyle, nt = _.outerAlpha, it = _.outerScale, st = _.outerSize, ot = _.outerStyle, ft = _.showSystemCursor, at = _.trailingSpeed, dt = useDeviceInfo(); return typeof navigator < "u" && dt.any() ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : jsxRuntimeExports.jsx(CursorCore, __assign({ clickables: $, color: _e, innerScale: et, innerSize: tt, innerStyle: rt, outerAlpha: nt, outerScale: it, outerSize: st, outerStyle: ot, showSystemCursor: ft, trailingSpeed: at }, { children: j })) } const MotionConfigContext = reactExports.createContext({ transformPagePoint: _ => _, isStatic: !1, reducedMotion: "never" }), MotionContext = reactExports.createContext({}), PresenceContext = reactExports.createContext(null), isBrowser$1 = typeof document < "u", useIsomorphicLayoutEffect = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect, LazyContext = reactExports.createContext({ strict: !1 }), camelToDash = _ => _.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId), MotionGlobalConfig = { skipAnimations: !1, useManualTiming: !1 }; class Queue { constructor() { this.order = [], this.scheduled = new Set } add(j) { if (!this.scheduled.has(j)) return this.scheduled.add(j), this.order.push(j), !0 } remove(j) { const $ = this.order.indexOf(j); $ !== -1 && (this.order.splice($, 1), this.scheduled.delete(j)) } clear() { this.order.length = 0, this.scheduled.clear() } } function createRenderStep(_) { let j = new Queue, $ = new Queue, _e = 0, et = !1, tt = !1; const rt = new WeakSet, nt = { schedule: (it, st = !1, ot = !1) => { const ft = ot && et, at = ft ? j : $; return st && rt.add(it), at.add(it) && ft && et && (_e = j.order.length), it }, cancel: it => { $.remove(it), rt.delete(it) }, process: it => { if (et) { tt = !0; return } if (et = !0, [j, $] = [$, j], $.clear(), _e = j.order.length, _e) for (let st = 0; st < _e; st++) { const ot = j.order[st]; rt.has(ot) && (nt.schedule(ot), _()), ot(it) } et = !1, tt && (tt = !1, nt.process(it)) } }; return nt } const stepsOrder = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], maxElapsed$1 = 40; function createRenderBatcher(_, j) { let $ = !1, _e = !0; const et = { delta: 0, timestamp: 0, isProcessing: !1 }, tt = stepsOrder.reduce((ft, at) => (ft[at] = createRenderStep(() => $ = !0), ft), {}), rt = ft => { tt[ft].process(et) }, nt = () => { const ft = performance.now(); $ = !1, et.delta = _e ? 1e3 / 60 : Math.max(Math.min(ft - et.timestamp, maxElapsed$1), 1), et.timestamp = ft, et.isProcessing = !0, stepsOrder.forEach(rt), et.isProcessing = !1, $ && j && (_e = !1, _(nt)) }, it = () => { $ = !0, _e = !0, et.isProcessing || _(nt) }; return { schedule: stepsOrder.reduce((ft, at) => { const dt = tt[at]; return ft[at] = (pt, ht = !1, xt = !1) => ($ || it(), dt.schedule(pt, ht, xt)), ft }, {}), cancel: ft => stepsOrder.forEach(at => tt[at].cancel(ft)), state: et, steps: tt } } const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, !1); function useVisualElement(_, j, $, _e) { const { visualElement: et } = reactExports.useContext(MotionContext), tt = reactExports.useContext(LazyContext), rt = reactExports.useContext(PresenceContext), nt = reactExports.useContext(MotionConfigContext).reducedMotion, it = reactExports.useRef(); _e = _e || tt.renderer, !it.current && _e && (it.current = _e(_, { visualState: j, parent: et, props: $, presenceContext: rt, blockInitialAnimation: rt ? rt.initial === !1 : !1, reducedMotionConfig: nt })); const st = it.current; reactExports.useInsertionEffect(() => { st && st.update($, rt) }); const ot = reactExports.useRef(!!($[optimizedAppearDataAttribute] && !window.HandoffComplete)); return useIsomorphicLayoutEffect(() => { st && (microtask.postRender(st.render), ot.current && st.animationState && st.animationState.animateChanges()) }), reactExports.useEffect(() => { st && (st.updateFeatures(), !ot.current && st.animationState && st.animationState.animateChanges(), ot.current && (ot.current = !1, window.HandoffComplete = !0)) }), st } function isRefObject(_) { return _ && typeof _ == "object" && Object.prototype.hasOwnProperty.call(_, "current") } function useMotionRef(_, j, $) { return reactExports.useCallback(_e => { _e && _.mount && _.mount(_e), j && (_e ? j.mount(_e) : j.unmount()), $ && (typeof $ == "function" ? $(_e) : isRefObject($) && ($.current = _e)) }, [j]) } function isVariantLabel(_) { return typeof _ == "string" || Array.isArray(_) } function isAnimationControls(_) { return _ !== null && typeof _ == "object" && typeof _.start == "function" } const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], variantProps = ["initial", ...variantPriorityOrder]; function isControllingVariants(_) { return isAnimationControls(_.animate) || variantProps.some(j => isVariantLabel(_[j])) } function isVariantNode(_) { return !!(isControllingVariants(_) || _.variants) } function getCurrentTreeVariants(_, j) { if (isControllingVariants(_)) { const { initial: $, animate: _e } = _; return { initial: $ === !1 || isVariantLabel($) ? $ : void 0, animate: isVariantLabel(_e) ? _e : void 0 } } return _.inherit !== !1 ? j : {} } function useCreateMotionContext(_) { const { initial: j, animate: $ } = getCurrentTreeVariants(_, reactExports.useContext(MotionContext)); return reactExports.useMemo(() => ({ initial: j, animate: $ }), [variantLabelsAsDependency(j), variantLabelsAsDependency($)]) } function variantLabelsAsDependency(_) { return Array.isArray(_) ? _.join(" ") : _ } const featureProps = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, featureDefinitions = {}; for (const _ in featureProps) featureDefinitions[_] = { isEnabled: j => featureProps[_].some($ => !!j[$]) }; function loadFeatures(_) { for (const j in _) featureDefinitions[j] = { ...featureDefinitions[j], ..._[j] } } const LayoutGroupContext = reactExports.createContext({}), SwitchLayoutGroupContext = reactExports.createContext({}), motionComponentSymbol = Symbol.for("motionComponentSymbol"); function createMotionComponent({ preloadedFeatures: _, createVisualElement: j, useRender: $, useVisualState: _e, Component: et }) { _ && loadFeatures(_); function tt(nt, it) { let st; const ot = { ...reactExports.useContext(MotionConfigContext), ...nt, layoutId: useLayoutId(nt) }, { isStatic: ft } = ot, at = useCreateMotionContext(nt), dt = _e(nt, ft); if (!ft && isBrowser$1) { at.visualElement = useVisualElement(et, dt, ot, j); const pt = reactExports.useContext(SwitchLayoutGroupContext), ht = reactExports.useContext(LazyContext).strict; at.visualElement && (st = at.visualElement.loadFeatures(ot, ht, _, pt)) } return reactExports.createElement(MotionContext.Provider, { value: at }, st && at.visualElement ? reactExports.createElement(st, { visualElement: at.visualElement, ...ot }) : null, $(et, nt, useMotionRef(dt, at.visualElement, it), dt, ft, at.visualElement)) } const rt = reactExports.forwardRef(tt); return rt[motionComponentSymbol] = et, rt } function useLayoutId({ layoutId: _ }) { const j = reactExports.useContext(LayoutGroupContext).id; return j && _ !== void 0 ? j + "-" + _ : _ } function createMotionProxy(_) { function j(_e, et = {}) { return createMotionComponent(_(_e, et)) } if (typeof Proxy > "u") return j; const $ = new Map; return new Proxy(j, { get: (_e, et) => ($.has(et) || $.set(et, j(et)), $.get(et)) }) } const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function isSVGComponent(_) { return typeof _ != "string" || _.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(_) > -1 || /[A-Z]/u.test(_)) } const scaleCorrectors = {}; function addScaleCorrector(_) { Object.assign(scaleCorrectors, _) } const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], transformProps = new Set(transformPropOrder); function isForcedMotionValue(_, { layout: j, layoutId: $ }) { return transformProps.has(_) || _.startsWith("origin") || (j || $ !== void 0) && (!!scaleCorrectors[_] || _ === "opacity") } const isMotionValue = _ => !!(_ && _.getVelocity), translateAlias = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, numTransforms = transformPropOrder.length; function buildTransform(_, { enableHardwareAcceleration: j = !0, allowTransformNone: $ = !0 }, _e, et) { let tt = ""; for (let rt = 0; rt < numTransforms; rt++) { const nt = transformPropOrder[rt]; if (_[nt] !== void 0) { const it = translateAlias[nt] || nt; tt += `${it}(${_[nt]}) ` } } return j && !_.z && (tt += "translateZ(0)"), tt = tt.trim(), et ? tt = et(_, _e ? "" : tt) : $ && _e && (tt = "none"), tt } const checkStringStartsWith = _ => j => typeof j == "string" && j.startsWith(_), isCSSVariableName = checkStringStartsWith("--"), startsAsVariableToken = checkStringStartsWith("var(--"), isCSSVariableToken = _ => startsAsVariableToken(_) ? singleCssVariableRegex.test(_.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, getValueAsType = (_, j) => j && typeof _ == "number" ? j.transform(_) : _, clamp = (_, j, $) => $ > j ? j : $ < _ ? _ : $, number = { test: _ => typeof _ == "number", parse: parseFloat, transform: _ => _ }, alpha = { ...number, transform: _ => clamp(0, 1, _) }, scale = { ...number, default: 1 }, sanitize = _ => Math.round(_ * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function isString(_) { return typeof _ == "string" } const createUnitType = _ => ({ test: j => isString(j) && j.endsWith(_) && j.split(" ").length === 1, parse: parseFloat, transform: j => `${j}${_}` }), degrees = createUnitType("deg"), percent = createUnitType("%"), px = createUnitType("px"), vh = createUnitType("vh"), vw = createUnitType("vw"), progressPercentage = { ...percent, parse: _ => percent.parse(_) / 100, transform: _ => percent.transform(_ * 100) }, int = { ...number, transform: Math.round }, numberValueTypes = { borderWidth: px, borderTopWidth: px, borderRightWidth: px, borderBottomWidth: px, borderLeftWidth: px, borderRadius: px, radius: px, borderTopLeftRadius: px, borderTopRightRadius: px, borderBottomRightRadius: px, borderBottomLeftRadius: px, width: px, maxWidth: px, height: px, maxHeight: px, size: px, top: px, right: px, bottom: px, left: px, padding: px, paddingTop: px, paddingRight: px, paddingBottom: px, paddingLeft: px, margin: px, marginTop: px, marginRight: px, marginBottom: px, marginLeft: px, rotate: degrees, rotateX: degrees, rotateY: degrees, rotateZ: degrees, scale, scaleX: scale, scaleY: scale, scaleZ: scale, skew: degrees, skewX: degrees, skewY: degrees, distance: px, translateX: px, translateY: px, translateZ: px, x: px, y: px, z: px, perspective: px, transformPerspective: px, opacity: alpha, originX: progressPercentage, originY: progressPercentage, originZ: px, zIndex: int, backgroundPositionX: px, backgroundPositionY: px, fillOpacity: alpha, strokeOpacity: alpha, numOctaves: int }; function buildHTMLStyles(_, j, $, _e) { const { style: et, vars: tt, transform: rt, transformOrigin: nt } = _; let it = !1, st = !1, ot = !0; for (const ft in j) { const at = j[ft]; if (isCSSVariableName(ft)) { tt[ft] = at; continue } const dt = numberValueTypes[ft], pt = getValueAsType(at, dt); if (transformProps.has(ft)) { if (it = !0, rt[ft] = pt, !ot) continue; at !== (dt.default || 0) && (ot = !1) } else ft.startsWith("origin") ? (st = !0, nt[ft] = pt) : et[ft] = pt } if (j.transform || (it || _e ? et.transform = buildTransform(_.transform, $, ot, _e) : et.transform && (et.transform = "none")), st) { const { originX: ft = "50%", originY: at = "50%", originZ: dt = 0 } = nt; et.transformOrigin = `${ft} ${at} ${dt}` } } const createHtmlRenderState = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function copyRawValuesOnly(_, j, $) { for (const _e in j) !isMotionValue(j[_e]) && !isForcedMotionValue(_e, $) && (_[_e] = j[_e]) } function useInitialMotionValues({ transformTemplate: _ }, j, $) { return reactExports.useMemo(() => { const _e = createHtmlRenderState(); return buildHTMLStyles(_e, j, { enableHardwareAcceleration: !$ }, _), Object.assign({}, _e.vars, _e.style) }, [j]) } function useStyle(_, j, $) { const _e = _.style || {}, et = {}; return copyRawValuesOnly(et, _e, _), Object.assign(et, useInitialMotionValues(_, j, $)), et } function useHTMLProps(_, j, $) { const _e = {}, et = useStyle(_, j, $); return _.drag && _.dragListener !== !1 && (_e.draggable = !1, et.userSelect = et.WebkitUserSelect = et.WebkitTouchCallout = "none", et.touchAction = _.drag === !0 ? "none" : `pan-${_.drag === "x" ? "y" : "x"}`), _.tabIndex === void 0 && (_.onTap || _.onTapStart || _.whileTap) && (_e.tabIndex = 0), _e.style = et, _e } const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function isValidMotionProp(_) { return _.startsWith("while") || _.startsWith("drag") && _ !== "draggable" || _.startsWith("layout") || _.startsWith("onTap") || _.startsWith("onPan") || _.startsWith("onLayout") || validMotionProps.has(_) } let shouldForward = _ => !isValidMotionProp(_); function loadExternalIsValidProp(_) { _ && (shouldForward = j => j.startsWith("on") ? !isValidMotionProp(j) : _(j)) } try { loadExternalIsValidProp(require("@emotion/is-prop-valid").default) } catch { } function filterProps(_, j, $) { const _e = {}; for (const et in _) et === "values" && typeof _.values == "object" || (shouldForward(et) || $ === !0 && isValidMotionProp(et) || !j && !isValidMotionProp(et) || _.draggable && et.startsWith("onDrag")) && (_e[et] = _[et]); return _e } function calcOrigin$1(_, j, $) { return typeof _ == "string" ? _ : px.transform(j + $ * _) } function calcSVGTransformOrigin(_, j, $) { const _e = calcOrigin$1(j, _.x, _.width), et = calcOrigin$1($, _.y, _.height); return `${_e} ${et}` } const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" }; function buildSVGPath(_, j, $ = 1, _e = 0, et = !0) { _.pathLength = 1; const tt = et ? dashKeys : camelKeys; _[tt.offset] = px.transform(-_e); const rt = px.transform(j), nt = px.transform($); _[tt.array] = `${rt} ${nt}` } function buildSVGAttrs(_, { attrX: j, attrY: $, attrScale: _e, originX: et, originY: tt, pathLength: rt, pathSpacing: nt = 1, pathOffset: it = 0, ...st }, ot, ft, at) { if (buildHTMLStyles(_, st, ot, at), ft) { _.style.viewBox && (_.attrs.viewBox = _.style.viewBox); return } _.attrs = _.style, _.style = {}; const { attrs: dt, style: pt, dimensions: ht } = _; dt.transform && (ht && (pt.transform = dt.transform), delete dt.transform), ht && (et !== void 0 || tt !== void 0 || pt.transform) && (pt.transformOrigin = calcSVGTransformOrigin(ht, et !== void 0 ? et : .5, tt !== void 0 ? tt : .5)), j !== void 0 && (dt.x = j), $ !== void 0 && (dt.y = $), _e !== void 0 && (dt.scale = _e), rt !== void 0 && buildSVGPath(dt, rt, nt, it, !1) } const createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {} }), isSVGTag = _ => typeof _ == "string" && _.toLowerCase() === "svg"; function useSVGProps(_, j, $, _e) { const et = reactExports.useMemo(() => { const tt = createSvgRenderState(); return buildSVGAttrs(tt, j, { enableHardwareAcceleration: !1 }, isSVGTag(_e), _.transformTemplate), { ...tt.attrs, style: { ...tt.style } } }, [j]); if (_.style) { const tt = {}; copyRawValuesOnly(tt, _.style, _), et.style = { ...tt, ...et.style } } return et } function createUseRender(_ = !1) { return ($, _e, et, { latestValues: tt }, rt) => { const it = (isSVGComponent($) ? useSVGProps : useHTMLProps)(_e, tt, rt, $), st = filterProps(_e, typeof $ == "string", _), ot = $ !== reactExports.Fragment ? { ...st, ...it, ref: et } : {}, { children: ft } = _e, at = reactExports.useMemo(() => isMotionValue(ft) ? ft.get() : ft, [ft]); return reactExports.createElement($, { ...ot, children: at }) } } function renderHTML(_, { style: j, vars: $ }, _e, et) { Object.assign(_.style, j, et && et.getProjectionStyles(_e)); for (const tt in $) _.style.setProperty(tt, $[tt]) } const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function renderSVG(_, j, $, _e) { renderHTML(_, j, void 0, _e); for (const et in j.attrs) _.setAttribute(camelCaseAttributes.has(et) ? et : camelToDash(et), j.attrs[et]) } function scrapeMotionValuesFromProps$1(_, j) { const { style: $ } = _, _e = {}; for (const et in $) (isMotionValue($[et]) || j.style && isMotionValue(j.style[et]) || isForcedMotionValue(et, _)) && (_e[et] = $[et]); return _e } function scrapeMotionValuesFromProps(_, j) { const $ = scrapeMotionValuesFromProps$1(_, j); for (const _e in _) if (isMotionValue(_[_e]) || isMotionValue(j[_e])) { const et = transformPropOrder.indexOf(_e) !== -1 ? "attr" + _e.charAt(0).toUpperCase() + _e.substring(1) : _e; $[et] = _[_e] } return $ } function resolveVariantFromProps(_, j, $, _e = {}, et = {}) { return typeof j == "function" && (j = j($ !== void 0 ? $ : _.custom, _e, et)), typeof j == "string" && (j = _.variants && _.variants[j]), typeof j == "function" && (j = j($ !== void 0 ? $ : _.custom, _e, et)), j } function useConstant(_) { const j = reactExports.useRef(null); return j.current === null && (j.current = _()), j.current } const isKeyframesTarget = _ => Array.isArray(_), isCustomValue = _ => !!(_ && typeof _ == "object" && _.mix && _.toValue), resolveFinalValueInKeyframes = _ => isKeyframesTarget(_) ? _[_.length - 1] || 0 : _; function resolveMotionValue(_) { const j = isMotionValue(_) ? _.get() : _; return isCustomValue(j) ? j.toValue() : j } function makeState({ scrapeMotionValuesFromProps: _, createRenderState: j, onMount: $ }, _e, et, tt) { const rt = { latestValues: makeLatestValues(_e, et, tt, _), renderState: j() }; return $ && (rt.mount = nt => $(_e, nt, rt)), rt } const makeUseVisualState = _ => (j, $) => { const _e = reactExports.useContext(MotionContext), et = reactExports.useContext(PresenceContext), tt = () => makeState(_, j, _e, et); return $ ? tt() : useConstant(tt) }; function makeLatestValues(_, j, $, _e) { const et = {}, tt = _e(_, {}); for (const at in tt) et[at] = resolveMotionValue(tt[at]); let { initial: rt, animate: nt } = _; const it = isControllingVariants(_), st = isVariantNode(_); j && st && !it && _.inherit !== !1 && (rt === void 0 && (rt = j.initial), nt === void 0 && (nt = j.animate)); let ot = $ ? $.initial === !1 : !1; ot = ot || rt === !1; const ft = ot ? nt : rt; return ft && typeof ft != "boolean" && !isAnimationControls(ft) && (Array.isArray(ft) ? ft : [ft]).forEach(dt => { const pt = resolveVariantFromProps(_, dt); if (!pt) return; const { transitionEnd: ht, transition: xt, ...ct } = pt; for (const ut in ct) { let lt = ct[ut]; if (Array.isArray(lt)) { const mt = ot ? lt.length - 1 : 0; lt = lt[mt] } lt !== null && (et[ut] = lt) } for (const ut in ht) et[ut] = ht[ut] }), et } const noop = _ => _, { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0), svgMotionConfig = { useVisualState: makeUseVisualState({ scrapeMotionValuesFromProps, createRenderState: createSvgRenderState, onMount: (_, j, { renderState: $, latestValues: _e }) => { frame.read(() => { try { $.dimensions = typeof j.getBBox == "function" ? j.getBBox() : j.getBoundingClientRect() } catch { $.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), frame.render(() => { buildSVGAttrs($, _e, { enableHardwareAcceleration: !1 }, isSVGTag(j.tagName), _.transformTemplate), renderSVG(j, $) }) } }) }, htmlMotionConfig = { useVisualState: makeUseVisualState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1, createRenderState: createHtmlRenderState }) }; function createDomMotionConfig(_, { forwardMotionProps: j = !1 }, $, _e) { return { ...isSVGComponent(_) ? svgMotionConfig : htmlMotionConfig, preloadedFeatures: $, useRender: createUseRender(j), createVisualElement: _e, Component: _ } } function addDomEvent(_, j, $, _e = { passive: !0 }) { return _.addEventListener(j, $, _e), () => _.removeEventListener(j, $) } const isPrimaryPointer = _ => _.pointerType === "mouse" ? typeof _.button != "number" || _.button <= 0 : _.isPrimary !== !1; function extractEventInfo(_, j = "page") { return { point: { x: _[j + "X"], y: _[j + "Y"] } } } const addPointerInfo = _ => j => isPrimaryPointer(j) && _(j, extractEventInfo(j)); function addPointerEvent(_, j, $, _e) { return addDomEvent(_, j, addPointerInfo($), _e) } const combineFunctions = (_, j) => $ => j(_($)), pipe = (..._) => _.reduce(combineFunctions); function createLock(_) { let j = null; return () => { const $ = () => { j = null }; return j === null ? (j = _, $) : !1 } } const globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical"); function getGlobalLock(_) { let j = !1; if (_ === "y") j = globalVerticalLock(); else if (_ === "x") j = globalHorizontalLock(); else { const $ = globalHorizontalLock(), _e = globalVerticalLock(); $ && _e ? j = () => { $(), _e() } : ($ && $(), _e && _e()) } return j } function isDragActive() { const _ = getGlobalLock(!0); return _ ? (_(), !1) : !0 } class Feature { constructor(j) { this.isMounted = !1, this.node = j } update() { } } function addHoverEvent(_, j) { const $ = "pointer" + (j ? "enter" : "leave"), _e = "onHover" + (j ? "Start" : "End"), et = (tt, rt) => { if (tt.pointerType === "touch" || isDragActive()) return; const nt = _.getProps(); _.animationState && nt.whileHover && _.animationState.setActive("whileHover", j), nt[_e] && nt[_e](tt, rt) }; return addPointerEvent(_.current, $, et, { passive: !_.getProps()[_e] }) } class HoverGesture extends Feature { mount() { this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1)) } unmount() { } } class FocusGesture extends Feature { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let j = !1; try { j = this.node.current.matches(":focus-visible") } catch { j = !0 } !j || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const isNodeOrChild = (_, j) => j ? _ === j ? !0 : isNodeOrChild(_, j.parentElement) : !1; function fireSyntheticPointerEvent(_, j) { if (!j) return; const $ = new PointerEvent("pointer" + _); j($, extractEventInfo($)) } class PressGesture extends Feature { constructor() { super(...arguments), this.removeStartListeners = noop, this.removeEndListeners = noop, this.removeAccessibleListeners = noop, this.startPointerPress = (j, $) => { if (this.isPressing) return; this.removeEndListeners(); const _e = this.node.getProps(), tt = addPointerEvent(window, "pointerup", (nt, it) => { if (!this.checkPressEnd()) return; const { onTap: st, onTapCancel: ot, globalTapTarget: ft } = this.node.getProps(); !ft && !isNodeOrChild(this.node.current, nt.target) ? ot && ot(nt, it) : st && st(nt, it) }, { passive: !(_e.onTap || _e.onPointerUp) }), rt = addPointerEvent(window, "pointercancel", (nt, it) => this.cancelPress(nt, it), { passive: !(_e.onTapCancel || _e.onPointerCancel) }); this.removeEndListeners = pipe(tt, rt), this.startPress(j, $) }, this.startAccessiblePress = () => { const j = tt => { if (tt.key !== "Enter" || this.isPressing) return; const rt = nt => { nt.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (it, st) => { const { onTap: ot } = this.node.getProps(); ot && ot(it, st) }) }; this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", rt), fireSyntheticPointerEvent("down", (nt, it) => { this.startPress(nt, it) }) }, $ = addDomEvent(this.node.current, "keydown", j), _e = () => { this.isPressing && fireSyntheticPointerEvent("cancel", (tt, rt) => this.cancelPress(tt, rt)) }, et = addDomEvent(this.node.current, "blur", _e); this.removeAccessibleListeners = pipe($, et) } } startPress(j, $) { this.isPressing = !0; const { onTapStart: _e, whileTap: et } = this.node.getProps(); et && this.node.animationState && this.node.animationState.setActive("whileTap", !0), _e && _e(j, $) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive() } cancelPress(j, $) { if (!this.checkPressEnd()) return; const { onTapCancel: _e } = this.node.getProps(); _e && _e(j, $) } mount() { const j = this.node.getProps(), $ = addPointerEvent(j.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(j.onTapStart || j.onPointerStart) }), _e = addDomEvent(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = pipe($, _e) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const observerCallbacks = new WeakMap, observers = new WeakMap, fireObserverCallback = _ => { const j = observerCallbacks.get(_.target); j && j(_) }, fireAllObserverCallbacks = _ => { _.forEach(fireObserverCallback) }; function initIntersectionObserver({ root: _, ...j }) { const $ = _ || document; observers.has($) || observers.set($, {}); const _e = observers.get($), et = JSON.stringify(j); return _e[et] || (_e[et] = new IntersectionObserver(fireAllObserverCallbacks, { root: _, ...j })), _e[et] } function observeIntersection(_, j, $) { const _e = initIntersectionObserver(j); return observerCallbacks.set(_, $), _e.observe(_), () => { observerCallbacks.delete(_), _e.unobserve(_) } } const thresholdNames = { some: 0, all: 1 }; class InViewFeature extends Feature { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: j = {} } = this.node.getProps(), { root: $, margin: _e, amount: et = "some", once: tt } = j, rt = { root: $ ? $.current : void 0, rootMargin: _e, threshold: typeof et == "number" ? et : thresholdNames[et] }, nt = it => { const { isIntersecting: st } = it; if (this.isInView === st || (this.isInView = st, tt && !st && this.hasEnteredView)) return; st && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", st); const { onViewportEnter: ot, onViewportLeave: ft } = this.node.getProps(), at = st ? ot : ft; at && at(it) }; return observeIntersection(this.node.current, rt, nt) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: j, prevProps: $ } = this.node;["amount", "margin", "root"].some(hasViewportOptionChanged(j, $)) && this.startObserver() } unmount() { } } function hasViewportOptionChanged({ viewport: _ = {} }, { viewport: j = {} } = {}) { return $ => _[$] !== j[$] } const gestureAnimations = { inView: { Feature: InViewFeature }, tap: { Feature: PressGesture }, focus: { Feature: FocusGesture }, hover: { Feature: HoverGesture } }; function shallowCompare(_, j) { if (!Array.isArray(j)) return !1; const $ = j.length; if ($ !== _.length) return !1; for (let _e = 0; _e < $; _e++)if (j[_e] !== _[_e]) return !1; return !0 } function getCurrent(_) { const j = {}; return _.values.forEach(($, _e) => j[_e] = $.get()), j } function getVelocity$1(_) { const j = {}; return _.values.forEach(($, _e) => j[_e] = $.getVelocity()), j } function resolveVariant(_, j, $) { const _e = _.getProps(); return resolveVariantFromProps(_e, j, $ !== void 0 ? $ : _e.custom, getCurrent(_), getVelocity$1(_)) } const secondsToMilliseconds = _ => _ * 1e3, millisecondsToSeconds = _ => _ / 1e3, underDampedSpring = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, criticallyDampedSpring = _ => ({ type: "spring", stiffness: 550, damping: _ === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), keyframesTransition = { type: "keyframes", duration: .8 }, ease = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, getDefaultTransition = (_, { keyframes: j }) => j.length > 2 ? keyframesTransition : transformProps.has(_) ? _.startsWith("scale") ? criticallyDampedSpring(j[1]) : underDampedSpring : ease; function isTransitionDefined({ when: _, delay: j, delayChildren: $, staggerChildren: _e, staggerDirection: et, repeat: tt, repeatType: rt, repeatDelay: nt, from: it, elapsed: st, ...ot }) { return !!Object.keys(ot).length } function getValueTransition(_, j) { return _[j] || _.default || _ } const isNotNull = _ => _ !== null; function getFinalKeyframe(_, { repeat: j, repeatType: $ = "loop" }, _e) { const et = _.filter(isNotNull), tt = j && $ !== "loop" && j % 2 === 1 ? 0 : et.length - 1; return !tt || _e === void 0 ? et[tt] : _e } let now$1; function clearTime() { now$1 = void 0 } const time = { now: () => (now$1 === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now$1), set: _ => { now$1 = _, queueMicrotask(clearTime) } }, isZeroValueString = _ => /^0[^.\s]+$/u.test(_); function isNone(_) { return typeof _ == "number" ? _ === 0 : _ !== null ? _ === "none" || _ === "0" || isZeroValueString(_) : !0 } let warning = noop, invariant = noop; const isNumericalString = _ => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(_), splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function parseCSSVariable(_) { const j = splitCSSVariableRegex.exec(_); if (!j) return [,]; const [, $, _e, et] = j; return [`--${$ ?? _e}`, et] } function getVariableValue(_, j, $ = 1) { const [_e, et] = parseCSSVariable(_); if (!_e) return; const tt = window.getComputedStyle(j).getPropertyValue(_e); if (tt) { const rt = tt.trim(); return isNumericalString(rt) ? parseFloat(rt) : rt } return isCSSVariableToken(et) ? getVariableValue(et, j, $ + 1) : et } const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), isNumOrPxType = _ => _ === number || _ === px, getPosFromMatrix = (_, j) => parseFloat(_.split(", ")[j]), getTranslateFromMatrix = (_, j) => ($, { transform: _e }) => { if (_e === "none" || !_e) return 0; const et = _e.match(/^matrix3d\((.+)\)$/u); if (et) return getPosFromMatrix(et[1], j); { const tt = _e.match(/^matrix\((.+)\)$/u); return tt ? getPosFromMatrix(tt[1], _) : 0 } }, transformKeys = new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter(_ => !transformKeys.has(_)); function removeNonTranslationalTransform(_) { const j = []; return nonTranslationalTransformKeys.forEach($ => { const _e = _.getValue($); _e !== void 0 && (j.push([$, _e.get()]), _e.set($.startsWith("scale") ? 1 : 0)) }), j } const positionalValues = { width: ({ x: _ }, { paddingLeft: j = "0", paddingRight: $ = "0" }) => _.max - _.min - parseFloat(j) - parseFloat($), height: ({ y: _ }, { paddingTop: j = "0", paddingBottom: $ = "0" }) => _.max - _.min - parseFloat(j) - parseFloat($), top: (_, { top: j }) => parseFloat(j), left: (_, { left: j }) => parseFloat(j), bottom: ({ y: _ }, { top: j }) => parseFloat(j) + (_.max - _.min), right: ({ x: _ }, { left: j }) => parseFloat(j) + (_.max - _.min), x: getTranslateFromMatrix(4, 13), y: getTranslateFromMatrix(5, 14) }; positionalValues.translateX = positionalValues.x; positionalValues.translateY = positionalValues.y; const testValueType = _ => j => j.test(_), auto = { test: _ => _ === "auto", parse: _ => _ }, dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto], findDimensionValueType = _ => dimensionValueTypes.find(testValueType(_)), toResolve = new Set; let isScheduled = !1, anyNeedsMeasurement = !1; function measureAllKeyframes() { if (anyNeedsMeasurement) { const _ = Array.from(toResolve).filter(_e => _e.needsMeasurement), j = new Set(_.map(_e => _e.element)), $ = new Map; j.forEach(_e => { removeNonTranslationalTransform(_e).length && ($.set(_e, removeNonTranslationalTransform(_e)), _e.render()) }), _.forEach(_e => _e.measureInitialState()), j.forEach(_e => { _e.render() }), _.forEach(_e => _e.measureEndState()), _.forEach(_e => { _e.suspendedScrollY !== void 0 && window.scrollTo(0, _e.suspendedScrollY) }) } anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach(_ => _.complete()), toResolve.clear() } function readAllKeyframes() { toResolve.forEach(_ => { _.readKeyframes(), _.needsMeasurement && (anyNeedsMeasurement = !0) }) } function flushKeyframeResolvers() { readAllKeyframes(), measureAllKeyframes() } class KeyframeResolver { constructor(j, $, _e, et, tt, rt = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...j], this.onComplete = $, this.name = _e, this.motionValue = et, this.element = tt, this.isAsync = rt } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: j, name: $, element: _e, motionValue: et } = this; for (let tt = 0; tt < j.length; tt++)if (j[tt] === null) if (tt === 0) { const rt = et == null ? void 0 : et.get(), nt = j[j.length - 1]; if (rt !== void 0) j[0] = rt; else if (_e && $) { const it = _e.readValue($, nt); it != null && (j[0] = it) } j[0] === void 0 && (j[0] = nt), et && rt === void 0 && et.set(j[0]) } else j[tt] = j[tt - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), toResolve.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, toResolve.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const isColorString = (_, j) => $ => !!(isString($) && singleColorRegex.test($) && $.startsWith(_) || j && Object.prototype.hasOwnProperty.call($, j)), splitColor = (_, j, $) => _e => { if (!isString(_e)) return _e; const [et, tt, rt, nt] = _e.match(floatRegex); return { [_]: parseFloat(et), [j]: parseFloat(tt), [$]: parseFloat(rt), alpha: nt !== void 0 ? parseFloat(nt) : 1 } }, clampRgbUnit = _ => clamp(0, 255, _), rgbUnit = { ...number, transform: _ => Math.round(clampRgbUnit(_)) }, rgba = { test: isColorString("rgb", "red"), parse: splitColor("red", "green", "blue"), transform: ({ red: _, green: j, blue: $, alpha: _e = 1 }) => "rgba(" + rgbUnit.transform(_) + ", " + rgbUnit.transform(j) + ", " + rgbUnit.transform($) + ", " + sanitize(alpha.transform(_e)) + ")" }; function parseHex(_) { let j = "", $ = "", _e = "", et = ""; return _.length > 5 ? (j = _.substring(1, 3), $ = _.substring(3, 5), _e = _.substring(5, 7), et = _.substring(7, 9)) : (j = _.substring(1, 2), $ = _.substring(2, 3), _e = _.substring(3, 4), et = _.substring(4, 5), j += j, $ += $, _e += _e, et += et), { red: parseInt(j, 16), green: parseInt($, 16), blue: parseInt(_e, 16), alpha: et ? parseInt(et, 16) / 255 : 1 } } const hex = { test: isColorString("#"), parse: parseHex, transform: rgba.transform }, hsla = { test: isColorString("hsl", "hue"), parse: splitColor("hue", "saturation", "lightness"), transform: ({ hue: _, saturation: j, lightness: $, alpha: _e = 1 }) => "hsla(" + Math.round(_) + ", " + percent.transform(sanitize(j)) + ", " + percent.transform(sanitize($)) + ", " + sanitize(alpha.transform(_e)) + ")" }, color = { test: _ => rgba.test(_) || hex.test(_) || hsla.test(_), parse: _ => rgba.test(_) ? rgba.parse(_) : hsla.test(_) ? hsla.parse(_) : hex.parse(_), transform: _ => isString(_) ? _ : _.hasOwnProperty("red") ? rgba.transform(_) : hsla.transform(_) }; function test(_) { var j, $; return isNaN(_) && isString(_) && (((j = _.match(floatRegex)) === null || j === void 0 ? void 0 : j.length) || 0) + ((($ = _.match(colorRegex)) === null || $ === void 0 ? void 0 : $.length) || 0) > 0 } const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function analyseComplexValue(_) { const j = _.toString(), $ = [], _e = { color: [], number: [], var: [] }, et = []; let tt = 0; const nt = j.replace(complexRegex, it => (color.test(it) ? (_e.color.push(tt), et.push(COLOR_TOKEN), $.push(color.parse(it))) : it.startsWith(VAR_FUNCTION_TOKEN) ? (_e.var.push(tt), et.push(VAR_TOKEN), $.push(it)) : (_e.number.push(tt), et.push(NUMBER_TOKEN), $.push(parseFloat(it))), ++tt, SPLIT_TOKEN)).split(SPLIT_TOKEN); return { values: $, split: nt, indexes: _e, types: et } } function parseComplexValue(_) { return analyseComplexValue(_).values } function createTransformer(_) { const { split: j, types: $ } = analyseComplexValue(_), _e = j.length; return et => { let tt = ""; for (let rt = 0; rt < _e; rt++)if (tt += j[rt], et[rt] !== void 0) { const nt = $[rt]; nt === NUMBER_TOKEN ? tt += sanitize(et[rt]) : nt === COLOR_TOKEN ? tt += color.transform(et[rt]) : tt += et[rt] } return tt } } const convertNumbersToZero = _ => typeof _ == "number" ? 0 : _; function getAnimatableNone$1(_) { const j = parseComplexValue(_); return createTransformer(_)(j.map(convertNumbersToZero)) } const complex = { test, parse: parseComplexValue, createTransformer, getAnimatableNone: getAnimatableNone$1 }, maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]); function applyDefaultFilter(_) { const [j, $] = _.slice(0, -1).split("("); if (j === "drop-shadow") return _; const [_e] = $.match(floatRegex) || []; if (!_e) return _; const et = $.replace(_e, ""); let tt = maxDefaults.has(j) ? 1 : 0; return _e !== $ && (tt *= 100), j + "(" + tt + et + ")" } const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = { ...complex, getAnimatableNone: _ => { const j = _.match(functionRegex); return j ? j.map(applyDefaultFilter).join(" ") : _ } }, defaultValueTypes = { ...numberValueTypes, color, backgroundColor: color, outlineColor: color, fill: color, stroke: color, borderColor: color, borderTopColor: color, borderRightColor: color, borderBottomColor: color, borderLeftColor: color, filter, WebkitFilter: filter }, getDefaultValueType = _ => defaultValueTypes[_]; function getAnimatableNone(_, j) { let $ = getDefaultValueType(_); return $ !== filter && ($ = complex), $.getAnimatableNone ? $.getAnimatableNone(j) : void 0 } function makeNoneKeyframesAnimatable(_, j, $) { let _e = 0, et; for (; _e < _.length && !et;)typeof _[_e] == "string" && _[_e] !== "none" && _[_e] !== "0" && (et = _[_e]), _e++; if (et && $) for (const tt of j) _[tt] = getAnimatableNone($, et) } class DOMKeyframesResolver extends KeyframeResolver { constructor(j, $, _e, et) { super(j, $, _e, et, et == null ? void 0 : et.owner, !0) } readKeyframes() { const { unresolvedKeyframes: j, element: $, name: _e } = this; if (!$.current) return; super.readKeyframes(); for (let it = 0; it < j.length; it++) { const st = j[it]; if (typeof st == "string" && isCSSVariableToken(st)) { const ot = getVariableValue(st, $.current); ot !== void 0 && (j[it] = ot) } } if (!positionalKeys.has(_e) || j.length !== 2) return this.resolveNoneKeyframes(); const [et, tt] = j, rt = findDimensionValueType(et), nt = findDimensionValueType(tt); if (rt !== nt) if (isNumOrPxType(rt) && isNumOrPxType(nt)) for (let it = 0; it < j.length; it++) { const st = j[it]; typeof st == "string" && (j[it] = parseFloat(st)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: j, name: $ } = this, _e = []; for (let et = 0; et < j.length; et++)isNone(j[et]) && _e.push(et); _e.length && makeNoneKeyframesAnimatable(j, _e, $) } measureInitialState() { const { element: j, unresolvedKeyframes: $, name: _e } = this; if (!j.current) return; _e === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[_e](j.measureViewportBox(), window.getComputedStyle(j.current)), $[0] = this.measuredOrigin; const et = $[$.length - 1]; et !== void 0 && j.getValue(_e, et).jump(et, !1) } measureEndState() { var j; const { element: $, name: _e, unresolvedKeyframes: et } = this; if (!$.current) return; const tt = $.getValue(_e); tt && tt.jump(this.measuredOrigin, !1); const rt = et.length - 1, nt = et[rt]; et[rt] = positionalValues[_e]($.measureViewportBox(), window.getComputedStyle($.current)), nt !== null && (this.finalKeyframe = nt), !((j = this.removedTransforms) === null || j === void 0) && j.length && this.removedTransforms.forEach(([it, st]) => { $.getValue(it).set(st) }), this.resolveNoneKeyframes() } } function memo(_) { let j; return () => (j === void 0 && (j = _()), j) } const isAnimatable = (_, j) => j === "zIndex" ? !1 : !!(typeof _ == "number" || Array.isArray(_) || typeof _ == "string" && (complex.test(_) || _ === "0") && !_.startsWith("url(")); function hasKeyframesChanged(_) { const j = _[0]; if (_.length === 1) return !0; for (let $ = 0; $ < _.length; $++)if (_[$] !== j) return !0 } function canAnimate(_, j, $, _e) { const et = _[0]; if (et === null) return !1; const tt = _[_.length - 1], rt = isAnimatable(et, j), nt = isAnimatable(tt, j); return !rt || !nt ? !1 : hasKeyframesChanged(_) || $ === "spring" && _e } class BaseAnimation { constructor({ autoplay: j = !0, delay: $ = 0, type: _e = "keyframes", repeat: et = 0, repeatDelay: tt = 0, repeatType: rt = "loop", ...nt }) { this.isStopped = !1, this.options = { autoplay: j, delay: $, type: _e, repeat: et, repeatDelay: tt, repeatType: rt, ...nt }, this.updateFinishedPromise() } get resolved() { return this._resolved || flushKeyframeResolvers(), this._resolved } onKeyframesResolved(j, $) { const { name: _e, type: et, velocity: tt, delay: rt, onComplete: nt, onUpdate: it } = this.options; if (!canAnimate(j, _e, et, tt)) if (rt) this.options.duration = 0; else { it == null || it(getFinalKeyframe(j, this.options, $)), nt == null || nt(), this.resolveFinishedPromise(), this.updateFinishedPromise(); return } this._resolved = { keyframes: j, finalKeyframe: $, ...this.initPlayback(j, $) }, this.onPostResolved() } onPostResolved() { } then(j, $) { return this.currentFinishedPromise.then(j, $) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(j => { this.resolveFinishedPromise = () => { j(), this.updateFinishedPromise() } }) } } function velocityPerSecond(_, j) { return j ? _ * (1e3 / j) : 0 } const velocitySampleDuration = 5; function calcGeneratorVelocity(_, j, $) { const _e = Math.max(j - velocitySampleDuration, 0); return velocityPerSecond($ - _(_e), j - _e) } const safeMin = .001, minDuration = .01, maxDuration$1 = 10, minDamping = .05, maxDamping = 1; function findSpring({ duration: _ = 800, bounce: j = .25, velocity: $ = 0, mass: _e = 1 }) { let et, tt, rt = 1 - j; rt = clamp(minDamping, maxDamping, rt), _ = clamp(minDuration, maxDuration$1, millisecondsToSeconds(_)), rt < 1 ? (et = st => { const ot = st * rt, ft = ot * _, at = ot - $, dt = calcAngularFreq(st, rt), pt = Math.exp(-ft); return safeMin - at / dt * pt }, tt = st => { const ft = st * rt * _, at = ft * $ + $, dt = Math.pow(rt, 2) * Math.pow(st, 2) * _, pt = Math.exp(-ft), ht = calcAngularFreq(Math.pow(st, 2), rt); return (-et(st) + safeMin > 0 ? -1 : 1) * ((at - dt) * pt) / ht }) : (et = st => { const ot = Math.exp(-st * _), ft = (st - $) * _ + 1; return -safeMin + ot * ft }, tt = st => { const ot = Math.exp(-st * _), ft = ($ - st) * (_ * _); return ot * ft }); const nt = 5 / _, it = approximateRoot(et, tt, nt); if (_ = secondsToMilliseconds(_), isNaN(it)) return { stiffness: 100, damping: 10, duration: _ }; { const st = Math.pow(it, 2) * _e; return { stiffness: st, damping: rt * 2 * Math.sqrt(_e * st), duration: _ } } } const rootIterations = 12; function approximateRoot(_, j, $) { let _e = $; for (let et = 1; et < rootIterations; et++)_e = _e - _(_e) / j(_e); return _e } function calcAngularFreq(_, j) { return _ * Math.sqrt(1 - j * j) } const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"]; function isSpringType(_, j) { return j.some($ => _[$] !== void 0) } function getSpringOptions(_) { let j = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ..._ }; if (!isSpringType(_, physicsKeys) && isSpringType(_, durationKeys)) { const $ = findSpring(_); j = { ...j, ...$, mass: 1 }, j.isResolvedFromDuration = !0 } return j } function spring({ keyframes: _, restDelta: j, restSpeed: $, ..._e }) { const et = _[0], tt = _[_.length - 1], rt = { done: !1, value: et }, { stiffness: nt, damping: it, mass: st, duration: ot, velocity: ft, isResolvedFromDuration: at } = getSpringOptions({ ..._e, velocity: -millisecondsToSeconds(_e.velocity || 0) }), dt = ft || 0, pt = it / (2 * Math.sqrt(nt * st)), ht = tt - et, xt = millisecondsToSeconds(Math.sqrt(nt / st)), ct = Math.abs(ht) < 5; $ || ($ = ct ? .01 : 2), j || (j = ct ? .005 : .5); let ut; if (pt < 1) { const lt = calcAngularFreq(xt, pt); ut = mt => { const yt = Math.exp(-pt * xt * mt); return tt - yt * ((dt + pt * xt * ht) / lt * Math.sin(lt * mt) + ht * Math.cos(lt * mt)) } } else if (pt === 1) ut = lt => tt - Math.exp(-xt * lt) * (ht + (dt + xt * ht) * lt); else { const lt = xt * Math.sqrt(pt * pt - 1); ut = mt => { const yt = Math.exp(-pt * xt * mt), gt = Math.min(lt * mt, 300); return tt - yt * ((dt + pt * xt * ht) * Math.sinh(gt) + lt * ht * Math.cosh(gt)) / lt } } return { calculatedDuration: at && ot || null, next: lt => { const mt = ut(lt); if (at) rt.done = lt >= ot; else { let yt = dt; lt !== 0 && (pt < 1 ? yt = calcGeneratorVelocity(ut, lt, mt) : yt = 0); const gt = Math.abs(yt) <= $, St = Math.abs(tt - mt) <= j; rt.done = gt && St } return rt.value = rt.done ? tt : mt, rt } } } function inertia({ keyframes: _, velocity: j = 0, power: $ = .8, timeConstant: _e = 325, bounceDamping: et = 10, bounceStiffness: tt = 500, modifyTarget: rt, min: nt, max: it, restDelta: st = .5, restSpeed: ot }) { const ft = _[0], at = { done: !1, value: ft }, dt = bt => nt !== void 0 && bt < nt || it !== void 0 && bt > it, pt = bt => nt === void 0 ? it : it === void 0 || Math.abs(nt - bt) < Math.abs(it - bt) ? nt : it; let ht = $ * j; const xt = ft + ht, ct = rt === void 0 ? xt : rt(xt); ct !== xt && (ht = ct - ft); const ut = bt => -ht * Math.exp(-bt / _e), lt = bt => ct + ut(bt), mt = bt => { const _t = ut(bt), Mt = lt(bt); at.done = Math.abs(_t) <= st, at.value = at.done ? ct : Mt }; let yt, gt; const St = bt => { dt(at.value) && (yt = bt, gt = spring({ keyframes: [at.value, pt(at.value)], velocity: calcGeneratorVelocity(lt, bt, at.value), damping: et, stiffness: tt, restDelta: st, restSpeed: ot })) }; return St(0), { calculatedDuration: null, next: bt => { let _t = !1; return !gt && yt === void 0 && (_t = !0, mt(bt), St(bt)), yt !== void 0 && bt >= yt ? gt.next(bt - yt) : (!_t && mt(bt), at) } } } const calcBezier = (_, j, $) => (((1 - 3 * $ + 3 * j) * _ + (3 * $ - 6 * j)) * _ + 3 * j) * _, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12; function binarySubdivide(_, j, $, _e, et) { let tt, rt, nt = 0; do rt = j + ($ - j) / 2, tt = calcBezier(rt, _e, et) - _, tt > 0 ? $ = rt : j = rt; while (Math.abs(tt) > subdivisionPrecision && ++nt < subdivisionMaxIterations); return rt } function cubicBezier(_, j, $, _e) { if (_ === j && $ === _e) return noop; const et = tt => binarySubdivide(tt, 0, 1, _, $); return tt => tt === 0 || tt === 1 ? tt : calcBezier(et(tt), j, _e) } const easeIn = cubicBezier(.42, 0, 1, 1), easeOut = cubicBezier(0, 0, .58, 1), easeInOut = cubicBezier(.42, 0, .58, 1), isEasingArray = _ => Array.isArray(_) && typeof _[0] != "number", mirrorEasing = _ => j => j <= .5 ? _(2 * j) / 2 : (2 - _(2 * (1 - j))) / 2, reverseEasing = _ => j => 1 - _(1 - j), circIn = _ => 1 - Math.sin(Math.acos(_)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), backOut = cubicBezier(.33, 1.53, .69, .99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn), anticipate = _ => (_ *= 2) < 1 ? .5 * backIn(_) : .5 * (2 - Math.pow(2, -10 * (_ - 1))), easingLookup = { linear: noop, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate }, easingDefinitionToFunction = _ => { if (Array.isArray(_)) { invariant(_.length === 4); const [j, $, _e, et] = _; return cubicBezier(j, $, _e, et) } else if (typeof _ == "string") return easingLookup[_]; return _ }, progress = (_, j, $) => { const _e = j - _; return _e === 0 ? 1 : ($ - _) / _e }, mixNumber$1 = (_, j, $) => _ + (j - _) * $; function hueToRgb(_, j, $) { return $ < 0 && ($ += 1), $ > 1 && ($ -= 1), $ < 1 / 6 ? _ + (j - _) * 6 * $ : $ < 1 / 2 ? j : $ < 2 / 3 ? _ + (j - _) * (2 / 3 - $) * 6 : _ } function hslaToRgba({ hue: _, saturation: j, lightness: $, alpha: _e }) { _ /= 360, j /= 100, $ /= 100; let et = 0, tt = 0, rt = 0; if (!j) et = tt = rt = $; else { const nt = $ < .5 ? $ * (1 + j) : $ + j - $ * j, it = 2 * $ - nt; et = hueToRgb(it, nt, _ + 1 / 3), tt = hueToRgb(it, nt, _), rt = hueToRgb(it, nt, _ - 1 / 3) } return { red: Math.round(et * 255), green: Math.round(tt * 255), blue: Math.round(rt * 255), alpha: _e } } const mixLinearColor = (_, j, $) => { const _e = _ * _, et = $ * (j * j - _e) + _e; return et < 0 ? 0 : Math.sqrt(et) }, colorTypes = [hex, rgba, hsla], getColorType = _ => colorTypes.find(j => j.test(_)); function asRGBA(_) { const j = getColorType(_); let $ = j.parse(_); return j === hsla && ($ = hslaToRgba($)), $ } const mixColor = (_, j) => { const $ = asRGBA(_), _e = asRGBA(j), et = { ...$ }; return tt => (et.red = mixLinearColor($.red, _e.red, tt), et.green = mixLinearColor($.green, _e.green, tt), et.blue = mixLinearColor($.blue, _e.blue, tt), et.alpha = mixNumber$1($.alpha, _e.alpha, tt), rgba.transform(et)) }; function mixImmediate(_, j) { return $ => $ > 0 ? j : _ } function mixNumber(_, j) { return $ => mixNumber$1(_, j, $) } function getMixer$1(_) { return typeof _ == "number" ? mixNumber : typeof _ == "string" ? isCSSVariableToken(_) ? mixImmediate : color.test(_) ? mixColor : mixComplex : Array.isArray(_) ? mixArray : typeof _ == "object" ? color.test(_) ? mixColor : mixObject : mixImmediate } function mixArray(_, j) { const $ = [..._], _e = $.length, et = _.map((tt, rt) => getMixer$1(tt)(tt, j[rt])); return tt => { for (let rt = 0; rt < _e; rt++)$[rt] = et[rt](tt); return $ } } function mixObject(_, j) { const $ = { ..._, ...j }, _e = {}; for (const et in $) _[et] !== void 0 && j[et] !== void 0 && (_e[et] = getMixer$1(_[et])(_[et], j[et])); return et => { for (const tt in _e) $[tt] = _e[tt](et); return $ } } function matchOrder(_, j) { var $; const _e = [], et = { color: 0, var: 0, number: 0 }; for (let tt = 0; tt < j.values.length; tt++) { const rt = j.types[tt], nt = _.indexes[rt][et[rt]], it = ($ = _.values[nt]) !== null && $ !== void 0 ? $ : 0; _e[tt] = it, et[rt]++ } return _e } const mixComplex = (_, j) => { const $ = complex.createTransformer(j), _e = analyseComplexValue(_), et = analyseComplexValue(j); return _e.indexes.var.length === et.indexes.var.length && _e.indexes.color.length === et.indexes.color.length && _e.indexes.number.length >= et.indexes.number.length ? pipe(mixArray(matchOrder(_e, et), et.values), $) : mixImmediate(_, j) }; function mix(_, j, $) { return typeof _ == "number" && typeof j == "number" && typeof $ == "number" ? mixNumber$1(_, j, $) : getMixer$1(_)(_, j) } function createMixers(_, j, $) { const _e = [], et = $ || mix, tt = _.length - 1; for (let rt = 0; rt < tt; rt++) { let nt = et(_[rt], _[rt + 1]); if (j) { const it = Array.isArray(j) ? j[rt] || noop : j; nt = pipe(it, nt) } _e.push(nt) } return _e } function interpolate(_, j, { clamp: $ = !0, ease: _e, mixer: et } = {}) { const tt = _.length; if (invariant(tt === j.length), tt === 1) return () => j[0]; if (tt === 2 && _[0] === _[1]) return () => j[1]; _[0] > _[tt - 1] && (_ = [..._].reverse(), j = [...j].reverse()); const rt = createMixers(j, _e, et), nt = rt.length, it = st => { let ot = 0; if (nt > 1) for (; ot < _.length - 2 && !(st < _[ot + 1]); ot++); const ft = progress(_[ot], _[ot + 1], st); return rt[ot](ft) }; return $ ? st => it(clamp(_[0], _[tt - 1], st)) : it } function fillOffset(_, j) { const $ = _[_.length - 1]; for (let _e = 1; _e <= j; _e++) { const et = progress(0, j, _e); _.push(mixNumber$1($, 1, et)) } } function defaultOffset$1(_) { const j = [0]; return fillOffset(j, _.length - 1), j } function convertOffsetToTimes(_, j) { return _.map($ => $ * j) } function defaultEasing(_, j) { return _.map(() => j || easeInOut).splice(0, _.length - 1) } function keyframes$1({ duration: _ = 300, keyframes: j, times: $, ease: _e = "easeInOut" }) { const et = isEasingArray(_e) ? _e.map(easingDefinitionToFunction) : easingDefinitionToFunction(_e), tt = { done: !1, value: j[0] }, rt = convertOffsetToTimes($ && $.length === j.length ? $ : defaultOffset$1(j), _), nt = interpolate(rt, j, { ease: Array.isArray(et) ? et : defaultEasing(j, et) }); return { calculatedDuration: _, next: it => (tt.value = nt(it), tt.done = it >= _, tt) } } const maxGeneratorDuration = 2e4; function calcGeneratorDuration(_) { let j = 0; const $ = 50; let _e = _.next(j); for (; !_e.done && j < maxGeneratorDuration;)j += $, _e = _.next(j); return j >= maxGeneratorDuration ? 1 / 0 : j } const frameloopDriver = _ => { const j = ({ timestamp: $ }) => _($); return { start: () => frame.update(j, !0), stop: () => cancelFrame(j), now: () => frameData.isProcessing ? frameData.timestamp : time.now() } }, generators = { decay: inertia, inertia, tween: keyframes$1, keyframes: keyframes$1, spring }, percentToProgress = _ => _ / 100; class MainThreadAnimation extends BaseAnimation { constructor({ KeyframeResolver: j = KeyframeResolver, ...$ }) { super($), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle"; const { name: _e, motionValue: et, keyframes: tt } = this.options, rt = (nt, it) => this.onKeyframesResolved(nt, it); _e && et && et.owner ? this.resolver = et.owner.resolveKeyframes(tt, rt, _e, et) : this.resolver = new j(tt, rt, _e, et), this.resolver.scheduleResolve() } initPlayback(j) { const { type: $ = "keyframes", repeat: _e = 0, repeatDelay: et = 0, repeatType: tt, velocity: rt = 0 } = this.options, nt = generators[$] || keyframes$1; let it, st; nt !== keyframes$1 && typeof j[0] != "number" && (it = pipe(percentToProgress, mix(j[0], j[1])), j = [0, 100]); const ot = nt({ ...this.options, keyframes: j }); tt === "mirror" && (st = nt({ ...this.options, keyframes: [...j].reverse(), velocity: -rt })), ot.calculatedDuration === null && (ot.calculatedDuration = calcGeneratorDuration(ot)); const { calculatedDuration: ft } = ot, at = ft + et, dt = at * (_e + 1) - et; return { generator: ot, mirroredGenerator: st, mapPercentToKeyframes: it, calculatedDuration: ft, resolvedDuration: at, totalDuration: dt } } onPostResolved() { const { autoplay: j = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !j ? this.pause() : this.state = this.pendingPlayState } tick(j, $ = !1) { const { resolved: _e } = this; if (!_e) { const { keyframes: bt } = this.options; return { done: !0, value: bt[bt.length - 1] } } const { finalKeyframe: et, generator: tt, mirroredGenerator: rt, mapPercentToKeyframes: nt, keyframes: it, calculatedDuration: st, totalDuration: ot, resolvedDuration: ft } = _e; if (this.startTime === null) return tt.next(0); const { delay: at, repeat: dt, repeatType: pt, repeatDelay: ht, onUpdate: xt } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, j) : this.speed < 0 && (this.startTime = Math.min(j - ot / this.speed, this.startTime)), $ ? this.currentTime = j : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(j - this.startTime) * this.speed; const ct = this.currentTime - at * (this.speed >= 0 ? 1 : -1), ut = this.speed >= 0 ? ct < 0 : ct > ot; this.currentTime = Math.max(ct, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = ot); let lt = this.currentTime, mt = tt; if (dt) { const bt = Math.min(this.currentTime, ot) / ft; let _t = Math.floor(bt), Mt = bt % 1; !Mt && bt >= 1 && (Mt = 1), Mt === 1 && _t--, _t = Math.min(_t, dt + 1), !!(_t % 2) && (pt === "reverse" ? (Mt = 1 - Mt, ht && (Mt -= ht / ft)) : pt === "mirror" && (mt = rt)), lt = clamp(0, 1, Mt) * ft } const yt = ut ? { done: !1, value: it[0] } : mt.next(lt); nt && (yt.value = nt(yt.value)); let { done: gt } = yt; !ut && st !== null && (gt = this.speed >= 0 ? this.currentTime >= ot : this.currentTime <= 0); const St = this.holdTime === null && (this.state === "finished" || this.state === "running" && gt); return St && et !== void 0 && (yt.value = getFinalKeyframe(it, this.options, et)), xt && xt(yt.value), St && this.finish(), yt } get duration() { const { resolved: j } = this; return j ? millisecondsToSeconds(j.calculatedDuration) : 0 } get time() { return millisecondsToSeconds(this.currentTime) } set time(j) { j = secondsToMilliseconds(j), this.currentTime = j, this.holdTime !== null || this.speed === 0 ? this.holdTime = j : this.driver && (this.startTime = this.driver.now() - j / this.speed) } get speed() { return this.playbackSpeed } set speed(j) { const $ = this.playbackSpeed !== j; this.playbackSpeed = j, $ && (this.time = millisecondsToSeconds(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: j = frameloopDriver, onPlay: $ } = this.options; this.driver || (this.driver = j(et => this.tick(et))), $ && $(); const _e = this.driver.now(); this.holdTime !== null ? this.startTime = _e - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = _e), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var j; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (j = this.currentTime) !== null && j !== void 0 ? j : 0 } stop() { if (this.isStopped = !0, this.state === "idle") return; this.state = "idle"; const { onStop: j } = this.options; j && j(), this.teardown() } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: j } = this.options; j && j() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(j) { return this.startTime = 0, this.tick(j, !0) } } const isBezierDefinition = _ => Array.isArray(_) && typeof _[0] == "number"; function isWaapiSupportedEasing(_) { return !!(!_ || typeof _ == "string" && supportedWaapiEasing[_] || isBezierDefinition(_) || Array.isArray(_) && _.every(isWaapiSupportedEasing)) } const cubicBezierAsString = ([_, j, $, _e]) => `cubic-bezier(${_}, ${j}, ${$}, ${_e})`, supportedWaapiEasing = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: cubicBezierAsString([0, .65, .55, 1]), circOut: cubicBezierAsString([.55, 0, 1, .45]), backIn: cubicBezierAsString([.31, .01, .66, -.59]), backOut: cubicBezierAsString([.33, 1.53, .69, .99]) }; function mapEasingToNativeEasing(_) { if (_) return isBezierDefinition(_) ? cubicBezierAsString(_) : Array.isArray(_) ? _.map(mapEasingToNativeEasing) : supportedWaapiEasing[_] } function animateStyle(_, j, $, { delay: _e = 0, duration: et = 300, repeat: tt = 0, repeatType: rt = "loop", ease: nt, times: it } = {}) { const st = { [j]: $ }; it && (st.offset = it); const ot = mapEasingToNativeEasing(nt); return Array.isArray(ot) && (st.easing = ot), _.animate(st, { delay: _e, duration: et, easing: Array.isArray(ot) ? "linear" : ot, fill: "both", iterations: tt + 1, direction: rt === "reverse" ? "alternate" : "normal" }) } const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"]), sampleDelta = 10, maxDuration = 2e4; function requiresPregeneratedKeyframes(_) { return _.type === "spring" || _.name === "backgroundColor" || !isWaapiSupportedEasing(_.ease) } function pregenerateKeyframes(_, j) { const $ = new MainThreadAnimation({ ...j, keyframes: _, repeat: 0, delay: 0 }); let _e = { done: !1, value: _[0] }; const et = []; let tt = 0; for (; !_e.done && tt < maxDuration;)_e = $.sample(tt), et.push(_e.value), tt += sampleDelta; return { times: void 0, keyframes: et, duration: tt - sampleDelta, ease: "linear" } } class AcceleratedAnimation extends BaseAnimation { constructor(j) { super(j); const { name: $, motionValue: _e, keyframes: et } = this.options; this.resolver = new DOMKeyframesResolver(et, (tt, rt) => this.onKeyframesResolved(tt, rt), $, _e), this.resolver.scheduleResolve() } initPlayback(j, $) { let _e = this.options.duration || 300; if (requiresPregeneratedKeyframes(this.options)) { const { onComplete: nt, onUpdate: it, motionValue: st, ...ot } = this.options, ft = pregenerateKeyframes(j, ot); j = ft.keyframes, _e = ft.duration, this.options.times = ft.times, this.options.ease = ft.ease } const { motionValue: et, name: tt } = this.options, rt = animateStyle(et.owner.current, tt, j, { ...this.options, duration: _e }); return rt.startTime = time.now(), this.pendingTimeline ? (rt.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : rt.onfinish = () => { const { onComplete: nt } = this.options; et.set(getFinalKeyframe(j, this.options, $)), nt && nt(), this.cancel(), this.resolveFinishedPromise(), this.updateFinishedPromise() }, { animation: rt, duration: _e, keyframes: j } } get duration() { const { resolved: j } = this; if (!j) return 0; const { duration: $ } = j; return millisecondsToSeconds($) } get time() { const { resolved: j } = this; if (!j) return 0; const { animation: $ } = j; return millisecondsToSeconds($.currentTime || 0) } set time(j) { const { resolved: $ } = this; if (!$) return; const { animation: _e } = $; _e.currentTime = secondsToMilliseconds(j) } get speed() { const { resolved: j } = this; if (!j) return 1; const { animation: $ } = j; return $.playbackRate } set speed(j) { const { resolved: $ } = this; if (!$) return; const { animation: _e } = $; _e.playbackRate = j } get state() { const { resolved: j } = this; if (!j) return "idle"; const { animation: $ } = j; return $.playState } attachTimeline(j) { if (!this._resolved) this.pendingTimeline = j; else { const { resolved: $ } = this; if (!$) return noop; const { animation: _e } = $; _e.timeline = j, _e.onfinish = null } return noop } play() { if (this.isStopped) return; const { resolved: j } = this; if (!j) return; const { animation: $ } = j; $.play() } pause() { const { resolved: j } = this; if (!j) return; const { animation: $ } = j; $.pause() } stop() { this.isStopped = !0; const { resolved: j } = this; if (!j) return; const { animation: $, keyframes: _e } = j; if (!($.playState === "idle" || $.playState === "finished")) { if (this.time) { const { motionValue: et, onUpdate: tt, onComplete: rt, ...nt } = this.options, it = new MainThreadAnimation({ ...nt, keyframes: _e }); et.setWithVelocity(it.sample(this.time - sampleDelta).value, it.sample(this.time).value, sampleDelta) } this.cancel() } } complete() { const { resolved: j } = this; j && j.animation.finish() } cancel() { const { resolved: j } = this; j && j.animation.cancel() } static supports(j) { const { motionValue: $, name: _e, repeatDelay: et, repeatType: tt, damping: rt, type: nt } = j; return supportsWaapi() && _e && acceleratedValues.has(_e) && $ && $.owner && $.owner.current instanceof HTMLElement && !$.owner.getProps().onUpdate && !et && tt !== "mirror" && rt !== 0 && nt !== "inertia" } } const animateMotionValue = (_, j, $, _e = {}, et, tt) => rt => { const nt = getValueTransition(_e, _) || {}, it = nt.delay || _e.delay || 0; let { elapsed: st = 0 } = _e; st = st - secondsToMilliseconds(it); let ot = { keyframes: Array.isArray($) ? $ : [null, $], ease: "easeOut", velocity: j.getVelocity(), ...nt, delay: -st, onUpdate: at => { j.set(at), nt.onUpdate && nt.onUpdate(at) }, onComplete: () => { rt(), nt.onComplete && nt.onComplete() }, name: _, motionValue: j, element: tt ? void 0 : et }; isTransitionDefined(nt) || (ot = { ...ot, ...getDefaultTransition(_, ot) }), ot.duration && (ot.duration = secondsToMilliseconds(ot.duration)), ot.repeatDelay && (ot.repeatDelay = secondsToMilliseconds(ot.repeatDelay)), ot.from !== void 0 && (ot.keyframes[0] = ot.from); let ft = !1; if (ot.type === !1 && (ot.duration = 0, ot.delay === 0 && (ft = !0)), ft && !tt && j.get() !== void 0) { const at = getFinalKeyframe(ot.keyframes, nt); if (at !== void 0) { frame.update(() => { ot.onUpdate(at), ot.onComplete() }); return } } return !tt && AcceleratedAnimation.supports(ot) ? new AcceleratedAnimation(ot) : new MainThreadAnimation(ot) }; function isWillChangeMotionValue(_) { return !!(isMotionValue(_) && _.add) } function addUniqueItem(_, j) { _.indexOf(j) === -1 && _.push(j) } function removeItem(_, j) { const $ = _.indexOf(j); $ > -1 && _.splice($, 1) } class SubscriptionManager { constructor() { this.subscriptions = [] } add(j) { return addUniqueItem(this.subscriptions, j), () => removeItem(this.subscriptions, j) } notify(j, $, _e) { const et = this.subscriptions.length; if (et) if (et === 1) this.subscriptions[0](j, $, _e); else for (let tt = 0; tt < et; tt++) { const rt = this.subscriptions[tt]; rt && rt(j, $, _e) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const MAX_VELOCITY_DELTA = 30, isFloat = _ => !isNaN(parseFloat(_)), collectMotionValues = { current: void 0 }; class MotionValue { constructor(j, $ = {}) { this.version = "11.0.15", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (_e, et = !0) => { const tt = time.now(); this.updatedAt !== tt && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(_e), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), et && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(j), this.canTrackVelocity = isFloat(this.current), this.owner = $.owner } setCurrent(j) { this.current = j, this.updatedAt = time.now() } setPrevFrameValue(j = this.current) { this.prevFrameValue = j, this.prevUpdatedAt = this.updatedAt } onChange(j) { return this.on("change", j) } on(j, $) { this.events[j] || (this.events[j] = new SubscriptionManager); const _e = this.events[j].add($); return j === "change" ? () => { _e(), frame.read(() => { this.events.change.getSize() || this.stop() }) } : _e } clearListeners() { for (const j in this.events) this.events[j].clear() } attach(j, $) { this.passiveEffect = j, this.stopPassiveEffect = $ } set(j, $ = !0) { !$ || !this.passiveEffect ? this.updateAndNotify(j, $) : this.passiveEffect(j, this.updateAndNotify) } setWithVelocity(j, $, _e) { this.set($), this.prev = void 0, this.prevFrameValue = j, this.prevUpdatedAt = this.updatedAt - _e } jump(j, $ = !0) { this.updateAndNotify(j), this.prev = j, this.prevUpdatedAt = this.prevFrameValue = void 0, $ && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return collectMotionValues.current && collectMotionValues.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { const j = time.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || j - this.updatedAt > MAX_VELOCITY_DELTA) return 0; const $ = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA); return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), $) } start(j) { return this.stop(), new Promise($ => { this.hasAnimated = !0, this.animation = j($), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function motionValue(_, j) { return new MotionValue(_, j) } function setMotionValue(_, j, $) { _.hasValue(j) ? _.getValue(j).set($) : _.addValue(j, motionValue($)) } function setTarget(_, j) { const $ = resolveVariant(_, j); let { transitionEnd: _e = {}, transition: et = {}, ...tt } = $ || {}; tt = { ...tt, ..._e }; for (const rt in tt) { const nt = resolveFinalValueInKeyframes(tt[rt]); setMotionValue(_, rt, nt) } } function shouldBlockAnimation({ protectedKeys: _, needsAnimating: j }, $) { const _e = _.hasOwnProperty($) && j[$] !== !0; return j[$] = !1, _e } function animateTarget(_, j, { delay: $ = 0, transitionOverride: _e, type: et } = {}) { var tt; let { transition: rt = _.getDefaultTransition(), transitionEnd: nt, ...it } = j; const st = _.getValue("willChange"); _e && (rt = _e); const ot = [], ft = et && _.animationState && _.animationState.getState()[et]; for (const at in it) { const dt = _.getValue(at, (tt = _.latestValues[at]) !== null && tt !== void 0 ? tt : null), pt = it[at]; if (pt === void 0 || ft && shouldBlockAnimation(ft, at)) continue; const ht = { delay: $, elapsed: 0, ...getValueTransition(rt || {}, at) }; let xt = !1; if (window.HandoffAppearAnimations) { const ut = _.getProps()[optimizedAppearDataAttribute]; if (ut) { const lt = window.HandoffAppearAnimations(ut, at); lt !== null && (ht.elapsed = lt, xt = !0) } } dt.start(animateMotionValue(at, dt, pt, _.shouldReduceMotion && transformProps.has(at) ? { type: !1 } : ht, _, xt)); const ct = dt.animation; ct && (isWillChangeMotionValue(st) && (st.add(at), ct.then(() => st.remove(at))), ot.push(ct)) } return nt && Promise.all(ot).then(() => { frame.update(() => { nt && setTarget(_, nt) }) }), ot } function animateVariant(_, j, $ = {}) { var _e; const et = resolveVariant(_, j, $.type === "exit" ? (_e = _.presenceContext) === null || _e === void 0 ? void 0 : _e.custom : void 0); let { transition: tt = _.getDefaultTransition() || {} } = et || {}; $.transitionOverride && (tt = $.transitionOverride); const rt = et ? () => Promise.all(animateTarget(_, et, $)) : () => Promise.resolve(), nt = _.variantChildren && _.variantChildren.size ? (st = 0) => { const { delayChildren: ot = 0, staggerChildren: ft, staggerDirection: at } = tt; return animateChildren(_, j, ot + st, ft, at, $) } : () => Promise.resolve(), { when: it } = tt; if (it) { const [st, ot] = it === "beforeChildren" ? [rt, nt] : [nt, rt]; return st().then(() => ot()) } else return Promise.all([rt(), nt($.delay)]) } function animateChildren(_, j, $ = 0, _e = 0, et = 1, tt) { const rt = [], nt = (_.variantChildren.size - 1) * _e, it = et === 1 ? (st = 0) => st * _e : (st = 0) => nt - st * _e; return Array.from(_.variantChildren).sort(sortByTreeOrder).forEach((st, ot) => { st.notify("AnimationStart", j), rt.push(animateVariant(st, j, { ...tt, delay: $ + it(ot) }).then(() => st.notify("AnimationComplete", j))) }), Promise.all(rt) } function sortByTreeOrder(_, j) { return _.sortNodePosition(j) } function animateVisualElement(_, j, $ = {}) { _.notify("AnimationStart", j); let _e; if (Array.isArray(j)) { const et = j.map(tt => animateVariant(_, tt, $)); _e = Promise.all(et) } else if (typeof j == "string") _e = animateVariant(_, j, $); else { const et = typeof j == "function" ? resolveVariant(_, j, $.custom) : j; _e = Promise.all(animateTarget(_, et, $)) } return _e.then(() => { frame.postRender(() => { _.notify("AnimationComplete", j) }) }) } const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length; function animateList(_) { return j => Promise.all(j.map(({ animation: $, options: _e }) => animateVisualElement(_, $, _e))) } function createAnimationState(_) { let j = animateList(_); const $ = createState(); let _e = !0; const et = it => (st, ot) => { var ft; const at = resolveVariant(_, ot, it === "exit" ? (ft = _.presenceContext) === null || ft === void 0 ? void 0 : ft.custom : void 0); if (at) { const { transition: dt, transitionEnd: pt, ...ht } = at; st = { ...st, ...ht, ...pt } } return st }; function tt(it) { j = it(_) } function rt(it) { const st = _.getProps(), ot = _.getVariantContext(!0) || {}, ft = [], at = new Set; let dt = {}, pt = 1 / 0; for (let xt = 0; xt < numAnimationTypes; xt++) { const ct = reversePriorityOrder[xt], ut = $[ct], lt = st[ct] !== void 0 ? st[ct] : ot[ct], mt = isVariantLabel(lt), yt = ct === it ? ut.isActive : null; yt === !1 && (pt = xt); let gt = lt === ot[ct] && lt !== st[ct] && mt; if (gt && _e && _.manuallyAnimateOnMount && (gt = !1), ut.protectedKeys = { ...dt }, !ut.isActive && yt === null || !lt && !ut.prevProp || isAnimationControls(lt) || typeof lt == "boolean") continue; let bt = checkVariantsDidChange(ut.prevProp, lt) || ct === it && ut.isActive && !gt && mt || xt > pt && mt, _t = !1; const Mt = Array.isArray(lt) ? lt : [lt]; let It = Mt.reduce(et(ct), {}); yt === !1 && (It = {}); const { prevResolvedValues: Rt = {} } = ut, Lt = { ...Rt, ...It }, Vt = At => { bt = !0, at.has(At) && (_t = !0, at.delete(At)), ut.needsAnimating[At] = !0 }; for (const At in Lt) { const Pt = It[At], kt = Rt[At]; if (dt.hasOwnProperty(At)) continue; let vt = !1; isKeyframesTarget(Pt) && isKeyframesTarget(kt) ? vt = !shallowCompare(Pt, kt) : vt = Pt !== kt, vt ? Pt != null ? Vt(At) : at.add(At) : Pt !== void 0 && at.has(At) ? Vt(At) : ut.protectedKeys[At] = !0 } ut.prevProp = lt, ut.prevResolvedValues = It, ut.isActive && (dt = { ...dt, ...It }), _e && _.blockInitialAnimation && (bt = !1), bt && (!gt || _t) && ft.push(...Mt.map(At => ({ animation: At, options: { type: ct } }))) } if (at.size) { const xt = {}; at.forEach(ct => { const ut = _.getBaseTarget(ct); xt[ct] = ut === void 0 ? null : ut }), ft.push({ animation: xt }) } let ht = !!ft.length; return _e && (st.initial === !1 || st.initial === st.animate) && !_.manuallyAnimateOnMount && (ht = !1), _e = !1, ht ? j(ft) : Promise.resolve() } function nt(it, st) { var ot; if ($[it].isActive === st) return Promise.resolve(); (ot = _.variantChildren) === null || ot === void 0 || ot.forEach(at => { var dt; return (dt = at.animationState) === null || dt === void 0 ? void 0 : dt.setActive(it, st) }), $[it].isActive = st; const ft = rt(it); for (const at in $) $[at].protectedKeys = {}; return ft } return { animateChanges: rt, setActive: nt, setAnimateFunction: tt, getState: () => $ } } function checkVariantsDidChange(_, j) { return typeof j == "string" ? j !== _ : Array.isArray(j) ? !shallowCompare(j, _) : !1 } function createTypeState(_ = !1) { return { isActive: _, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function createState() { return { animate: createTypeState(!0), whileInView: createTypeState(), whileHover: createTypeState(), whileTap: createTypeState(), whileDrag: createTypeState(), whileFocus: createTypeState(), exit: createTypeState() } } class AnimationFeature extends Feature { constructor(j) { super(j), j.animationState || (j.animationState = createAnimationState(j)) } updateAnimationControlsSubscription() { const { animate: j } = this.node.getProps(); this.unmount(), isAnimationControls(j) && (this.unmount = j.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: j } = this.node.getProps(), { animate: $ } = this.node.prevProps || {}; j !== $ && this.updateAnimationControlsSubscription() } unmount() { } } let id$1 = 0; class ExitAnimationFeature extends Feature { constructor() { super(...arguments), this.id = id$1++ } update() { if (!this.node.presenceContext) return; const { isPresent: j, onExitComplete: $ } = this.node.presenceContext, { isPresent: _e } = this.node.prevPresenceContext || {}; if (!this.node.animationState || j === _e) return; const et = this.node.animationState.setActive("exit", !j); $ && !j && et.then(() => $(this.id)) } mount() { const { register: j } = this.node.presenceContext || {}; j && (this.unmount = j(this.id)) } unmount() { } } const animations = { animation: { Feature: AnimationFeature }, exit: { Feature: ExitAnimationFeature } }, distance = (_, j) => Math.abs(_ - j); function distance2D(_, j) { const $ = distance(_.x, j.x), _e = distance(_.y, j.y); return Math.sqrt($ ** 2 + _e ** 2) } class PanSession { constructor(j, $, { transformPagePoint: _e, contextWindow: et, dragSnapToOrigin: tt = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const ft = getPanInfo(this.lastMoveEventInfo, this.history), at = this.startEvent !== null, dt = distance2D(ft.offset, { x: 0, y: 0 }) >= 3; if (!at && !dt) return; const { point: pt } = ft, { timestamp: ht } = frameData; this.history.push({ ...pt, timestamp: ht }); const { onStart: xt, onMove: ct } = this.handlers; at || (xt && xt(this.lastMoveEvent, ft), this.startEvent = this.lastMoveEvent), ct && ct(this.lastMoveEvent, ft) }, this.handlePointerMove = (ft, at) => { this.lastMoveEvent = ft, this.lastMoveEventInfo = transformPoint(at, this.transformPagePoint), frame.update(this.updatePoint, !0) }, this.handlePointerUp = (ft, at) => { this.end(); const { onEnd: dt, onSessionEnd: pt, resumeAnimation: ht } = this.handlers; if (this.dragSnapToOrigin && ht && ht(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const xt = getPanInfo(ft.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(at, this.transformPagePoint), this.history); this.startEvent && dt && dt(ft, xt), pt && pt(ft, xt) }, !isPrimaryPointer(j)) return; this.dragSnapToOrigin = tt, this.handlers = $, this.transformPagePoint = _e, this.contextWindow = et || window; const rt = extractEventInfo(j), nt = transformPoint(rt, this.transformPagePoint), { point: it } = nt, { timestamp: st } = frameData; this.history = [{ ...it, timestamp: st }]; const { onSessionStart: ot } = $; ot && ot(j, getPanInfo(nt, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(j) { this.handlers = j } end() { this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint) } } function transformPoint(_, j) { return j ? { point: j(_.point) } : _ } function subtractPoint(_, j) { return { x: _.x - j.x, y: _.y - j.y } } function getPanInfo({ point: _ }, j) { return { point: _, delta: subtractPoint(_, lastDevicePoint(j)), offset: subtractPoint(_, startDevicePoint(j)), velocity: getVelocity(j, .1) } } function startDevicePoint(_) { return _[0] } function lastDevicePoint(_) { return _[_.length - 1] } function getVelocity(_, j) { if (_.length < 2) return { x: 0, y: 0 }; let $ = _.length - 1, _e = null; const et = lastDevicePoint(_); for (; $ >= 0 && (_e = _[$], !(et.timestamp - _e.timestamp > secondsToMilliseconds(j)));)$--; if (!_e) return { x: 0, y: 0 }; const tt = millisecondsToSeconds(et.timestamp - _e.timestamp); if (tt === 0) return { x: 0, y: 0 }; const rt = { x: (et.x - _e.x) / tt, y: (et.y - _e.y) / tt }; return rt.x === 1 / 0 && (rt.x = 0), rt.y === 1 / 0 && (rt.y = 0), rt } function calcLength(_) { return _.max - _.min } function isNear(_, j = 0, $ = .01) { return Math.abs(_ - j) <= $ } function calcAxisDelta(_, j, $, _e = .5) { _.origin = _e, _.originPoint = mixNumber$1(j.min, j.max, _.origin), _.scale = calcLength($) / calcLength(j), (isNear(_.scale, 1, 1e-4) || isNaN(_.scale)) && (_.scale = 1), _.translate = mixNumber$1($.min, $.max, _.origin) - _.originPoint, (isNear(_.translate) || isNaN(_.translate)) && (_.translate = 0) } function calcBoxDelta(_, j, $, _e) { calcAxisDelta(_.x, j.x, $.x, _e ? _e.originX : void 0), calcAxisDelta(_.y, j.y, $.y, _e ? _e.originY : void 0) } function calcRelativeAxis(_, j, $) { _.min = $.min + j.min, _.max = _.min + calcLength(j) } function calcRelativeBox(_, j, $) { calcRelativeAxis(_.x, j.x, $.x), calcRelativeAxis(_.y, j.y, $.y) } function calcRelativeAxisPosition(_, j, $) { _.min = j.min - $.min, _.max = _.min + calcLength(j) } function calcRelativePosition(_, j, $) { calcRelativeAxisPosition(_.x, j.x, $.x), calcRelativeAxisPosition(_.y, j.y, $.y) } function applyConstraints(_, { min: j, max: $ }, _e) { return j !== void 0 && _ < j ? _ = _e ? mixNumber$1(j, _, _e.min) : Math.max(_, j) : $ !== void 0 && _ > $ && (_ = _e ? mixNumber$1($, _, _e.max) : Math.min(_, $)), _ } function calcRelativeAxisConstraints(_, j, $) { return { min: j !== void 0 ? _.min + j : void 0, max: $ !== void 0 ? _.max + $ - (_.max - _.min) : void 0 } } function calcRelativeConstraints(_, { top: j, left: $, bottom: _e, right: et }) { return { x: calcRelativeAxisConstraints(_.x, $, et), y: calcRelativeAxisConstraints(_.y, j, _e) } } function calcViewportAxisConstraints(_, j) { let $ = j.min - _.min, _e = j.max - _.max; return j.max - j.min < _.max - _.min && ([$, _e] = [_e, $]), { min: $, max: _e } } function calcViewportConstraints(_, j) { return { x: calcViewportAxisConstraints(_.x, j.x), y: calcViewportAxisConstraints(_.y, j.y) } } function calcOrigin(_, j) { let $ = .5; const _e = calcLength(_), et = calcLength(j); return et > _e ? $ = progress(j.min, j.max - _e, _.min) : _e > et && ($ = progress(_.min, _.max - et, j.min)), clamp(0, 1, $) } function rebaseAxisConstraints(_, j) { const $ = {}; return j.min !== void 0 && ($.min = j.min - _.min), j.max !== void 0 && ($.max = j.max - _.min), $ } const defaultElastic = .35; function resolveDragElastic(_ = defaultElastic) { return _ === !1 ? _ = 0 : _ === !0 && (_ = defaultElastic), { x: resolveAxisElastic(_, "left", "right"), y: resolveAxisElastic(_, "top", "bottom") } } function resolveAxisElastic(_, j, $) { return { min: resolvePointElastic(_, j), max: resolvePointElastic(_, $) } } function resolvePointElastic(_, j) { return typeof _ == "number" ? _ : _[j] || 0 } const createAxisDelta = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({ x: createAxis(), y: createAxis() }); function eachAxis(_) { return [_("x"), _("y")] } function convertBoundingBoxToBox({ top: _, left: j, right: $, bottom: _e }) { return { x: { min: j, max: $ }, y: { min: _, max: _e } } } function convertBoxToBoundingBox({ x: _, y: j }) { return { top: j.min, right: _.max, bottom: j.max, left: _.min } } function transformBoxPoints(_, j) { if (!j) return _; const $ = j({ x: _.left, y: _.top }), _e = j({ x: _.right, y: _.bottom }); return { top: $.y, left: $.x, bottom: _e.y, right: _e.x } } function isIdentityScale(_) { return _ === void 0 || _ === 1 } function hasScale({ scale: _, scaleX: j, scaleY: $ }) { return !isIdentityScale(_) || !isIdentityScale(j) || !isIdentityScale($) } function hasTransform(_) { return hasScale(_) || has2DTranslate(_) || _.z || _.rotate || _.rotateX || _.rotateY } function has2DTranslate(_) { return is2DTranslate(_.x) || is2DTranslate(_.y) } function is2DTranslate(_) { return _ && _ !== "0%" } function scalePoint(_, j, $) { const _e = _ - $, et = j * _e; return $ + et } function applyPointDelta(_, j, $, _e, et) { return et !== void 0 && (_ = scalePoint(_, et, _e)), scalePoint(_, $, _e) + j } function applyAxisDelta(_, j = 0, $ = 1, _e, et) { _.min = applyPointDelta(_.min, j, $, _e, et), _.max = applyPointDelta(_.max, j, $, _e, et) } function applyBoxDelta(_, { x: j, y: $ }) { applyAxisDelta(_.x, j.translate, j.scale, j.originPoint), applyAxisDelta(_.y, $.translate, $.scale, $.originPoint) } function applyTreeDeltas(_, j, $, _e = !1) { const et = $.length; if (!et) return; j.x = j.y = 1; let tt, rt; for (let nt = 0; nt < et; nt++) { tt = $[nt], rt = tt.projectionDelta; const it = tt.instance; it && it.style && it.style.display === "contents" || (_e && tt.options.layoutScroll && tt.scroll && tt !== tt.root && transformBox(_, { x: -tt.scroll.offset.x, y: -tt.scroll.offset.y }), rt && (j.x *= rt.x.scale, j.y *= rt.y.scale, applyBoxDelta(_, rt)), _e && hasTransform(tt.latestValues) && transformBox(_, tt.latestValues)) } j.x = snapToDefault(j.x), j.y = snapToDefault(j.y) } function snapToDefault(_) { return Number.isInteger(_) || _ > 1.0000000000001 || _ < .999999999999 ? _ : 1 } function translateAxis(_, j) { _.min = _.min + j, _.max = _.max + j } function transformAxis(_, j, [$, _e, et]) { const tt = j[et] !== void 0 ? j[et] : .5, rt = mixNumber$1(_.min, _.max, tt); applyAxisDelta(_, j[$], j[_e], rt, j.scale) } const xKeys$1 = ["x", "scaleX", "originX"], yKeys$1 = ["y", "scaleY", "originY"]; function transformBox(_, j) { transformAxis(_.x, j, xKeys$1), transformAxis(_.y, j, yKeys$1) } function measureViewportBox(_, j) { return convertBoundingBoxToBox(transformBoxPoints(_.getBoundingClientRect(), j)) } function measurePageBox(_, j, $) { const _e = measureViewportBox(_, $), { scroll: et } = j; return et && (translateAxis(_e.x, et.offset.x), translateAxis(_e.y, et.offset.y)), _e } const getContextWindow = ({ current: _ }) => _ ? _.ownerDocument.defaultView : null, elementDragControls = new WeakMap; class VisualElementDragControls { constructor(j) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = j } start(j, { snapToCursor: $ = !1 } = {}) { const { presenceContext: _e } = this.visualElement; if (_e && _e.isPresent === !1) return; const et = ot => { const { dragSnapToOrigin: ft } = this.getProps(); ft ? this.pauseAnimation() : this.stopAnimation(), $ && this.snapToCursor(extractEventInfo(ot, "page").point) }, tt = (ot, ft) => { const { drag: at, dragPropagation: dt, onDragStart: pt } = this.getProps(); if (at && !dt && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(at), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis(xt => { let ct = this.getAxisMotionValue(xt).get() || 0; if (percent.test(ct)) { const { projection: ut } = this.visualElement; if (ut && ut.layout) { const lt = ut.layout.layoutBox[xt]; lt && (ct = calcLength(lt) * (parseFloat(ct) / 100)) } } this.originPoint[xt] = ct }), pt && pt(ot, ft); const { animationState: ht } = this.visualElement; ht && ht.setActive("whileDrag", !0) }, rt = (ot, ft) => { const { dragPropagation: at, dragDirectionLock: dt, onDirectionLock: pt, onDrag: ht } = this.getProps(); if (!at && !this.openGlobalLock) return; const { offset: xt } = ft; if (dt && this.currentDirection === null) { this.currentDirection = getCurrentDirection(xt), this.currentDirection !== null && pt && pt(this.currentDirection); return } this.updateAxis("x", ft.point, xt), this.updateAxis("y", ft.point, xt), this.visualElement.render(), ht && ht(ot, ft) }, nt = (ot, ft) => this.stop(ot, ft), it = () => eachAxis(ot => { var ft; return this.getAnimationState(ot) === "paused" && ((ft = this.getAxisMotionValue(ot).animation) === null || ft === void 0 ? void 0 : ft.play()) }), { dragSnapToOrigin: st } = this.getProps(); this.panSession = new PanSession(j, { onSessionStart: et, onStart: tt, onMove: rt, onSessionEnd: nt, resumeAnimation: it }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: st, contextWindow: getContextWindow(this.visualElement) }) } stop(j, $) { const _e = this.isDragging; if (this.cancel(), !_e) return; const { velocity: et } = $; this.startAnimation(et); const { onDragEnd: tt } = this.getProps(); tt && tt(j, $) } cancel() { this.isDragging = !1; const { projection: j, animationState: $ } = this.visualElement; j && (j.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: _e } = this.getProps(); !_e && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), $ && $.setActive("whileDrag", !1) } updateAxis(j, $, _e) { const { drag: et } = this.getProps(); if (!_e || !shouldDrag(j, et, this.currentDirection)) return; const tt = this.getAxisMotionValue(j); let rt = this.originPoint[j] + _e[j]; this.constraints && this.constraints[j] && (rt = applyConstraints(rt, this.constraints[j], this.elastic[j])), tt.set(rt) } resolveConstraints() { var j; const { dragConstraints: $, dragElastic: _e } = this.getProps(), et = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (j = this.visualElement.projection) === null || j === void 0 ? void 0 : j.layout, tt = this.constraints; $ && isRefObject($) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : $ && et ? this.constraints = calcRelativeConstraints(et.layoutBox, $) : this.constraints = !1, this.elastic = resolveDragElastic(_e), tt !== this.constraints && et && this.constraints && !this.hasMutatedConstraints && eachAxis(rt => { this.getAxisMotionValue(rt) && (this.constraints[rt] = rebaseAxisConstraints(et.layoutBox[rt], this.constraints[rt])) }) } resolveRefConstraints() { const { dragConstraints: j, onMeasureDragConstraints: $ } = this.getProps(); if (!j || !isRefObject(j)) return !1; const _e = j.current, { projection: et } = this.visualElement; if (!et || !et.layout) return !1; const tt = measurePageBox(_e, et.root, this.visualElement.getTransformPagePoint()); let rt = calcViewportConstraints(et.layout.layoutBox, tt); if ($) { const nt = $(convertBoxToBoundingBox(rt)); this.hasMutatedConstraints = !!nt, nt && (rt = convertBoundingBoxToBox(nt)) } return rt } startAnimation(j) { const { drag: $, dragMomentum: _e, dragElastic: et, dragTransition: tt, dragSnapToOrigin: rt, onDragTransitionEnd: nt } = this.getProps(), it = this.constraints || {}, st = eachAxis(ot => { if (!shouldDrag(ot, $, this.currentDirection)) return; let ft = it && it[ot] || {}; rt && (ft = { min: 0, max: 0 }); const at = et ? 200 : 1e6, dt = et ? 40 : 1e7, pt = { type: "inertia", velocity: _e ? j[ot] : 0, bounceStiffness: at, bounceDamping: dt, timeConstant: 750, restDelta: 1, restSpeed: 10, ...tt, ...ft }; return this.startAxisValueAnimation(ot, pt) }); return Promise.all(st).then(nt) } startAxisValueAnimation(j, $) { const _e = this.getAxisMotionValue(j); return _e.start(animateMotionValue(j, _e, 0, $, this.visualElement)) } stopAnimation() { eachAxis(j => this.getAxisMotionValue(j).stop()) } pauseAnimation() { eachAxis(j => { var $; return ($ = this.getAxisMotionValue(j).animation) === null || $ === void 0 ? void 0 : $.pause() }) } getAnimationState(j) { var $; return ($ = this.getAxisMotionValue(j).animation) === null || $ === void 0 ? void 0 : $.state } getAxisMotionValue(j) { const $ = "_drag" + j.toUpperCase(), _e = this.visualElement.getProps(), et = _e[$]; return et || this.visualElement.getValue(j, (_e.initial ? _e.initial[j] : void 0) || 0) } snapToCursor(j) { eachAxis($ => { const { drag: _e } = this.getProps(); if (!shouldDrag($, _e, this.currentDirection)) return; const { projection: et } = this.visualElement, tt = this.getAxisMotionValue($); if (et && et.layout) { const { min: rt, max: nt } = et.layout.layoutBox[$]; tt.set(j[$] - mixNumber$1(rt, nt, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: j, dragConstraints: $ } = this.getProps(), { projection: _e } = this.visualElement; if (!isRefObject($) || !_e || !this.constraints) return; this.stopAnimation(); const et = { x: 0, y: 0 }; eachAxis(rt => { const nt = this.getAxisMotionValue(rt); if (nt) { const it = nt.get(); et[rt] = calcOrigin({ min: it, max: it }, this.constraints[rt]) } }); const { transformTemplate: tt } = this.visualElement.getProps(); this.visualElement.current.style.transform = tt ? tt({}, "") : "none", _e.root && _e.root.updateScroll(), _e.updateLayout(), this.resolveConstraints(), eachAxis(rt => { if (!shouldDrag(rt, j, null)) return; const nt = this.getAxisMotionValue(rt), { min: it, max: st } = this.constraints[rt]; nt.set(mixNumber$1(it, st, et[rt])) }) } addListeners() { if (!this.visualElement.current) return; elementDragControls.set(this.visualElement, this); const j = this.visualElement.current, $ = addPointerEvent(j, "pointerdown", it => { const { drag: st, dragListener: ot = !0 } = this.getProps(); st && ot && this.start(it) }), _e = () => { const { dragConstraints: it } = this.getProps(); isRefObject(it) && (this.constraints = this.resolveRefConstraints()) }, { projection: et } = this.visualElement, tt = et.addEventListener("measure", _e); et && !et.layout && (et.root && et.root.updateScroll(), et.updateLayout()), _e(); const rt = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), nt = et.addEventListener("didUpdate", ({ delta: it, hasLayoutChanged: st }) => { this.isDragging && st && (eachAxis(ot => { const ft = this.getAxisMotionValue(ot); ft && (this.originPoint[ot] += it[ot].translate, ft.set(ft.get() + it[ot].translate)) }), this.visualElement.render()) }); return () => { rt(), $(), tt(), nt && nt() } } getProps() { const j = this.visualElement.getProps(), { drag: $ = !1, dragDirectionLock: _e = !1, dragPropagation: et = !1, dragConstraints: tt = !1, dragElastic: rt = defaultElastic, dragMomentum: nt = !0 } = j; return { ...j, drag: $, dragDirectionLock: _e, dragPropagation: et, dragConstraints: tt, dragElastic: rt, dragMomentum: nt } } } function shouldDrag(_, j, $) { return (j === !0 || j === _) && ($ === null || $ === _) } function getCurrentDirection(_, j = 10) { let $ = null; return Math.abs(_.y) > j ? $ = "y" : Math.abs(_.x) > j && ($ = "x"), $ } class DragGesture extends Feature { constructor(j) { super(j), this.removeGroupControls = noop, this.removeListeners = noop, this.controls = new VisualElementDragControls(j) } mount() { const { dragControls: j } = this.node.getProps(); j && (this.removeGroupControls = j.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop } unmount() { this.removeGroupControls(), this.removeListeners() } } const asyncHandler = _ => (j, $) => { _ && _(j, $) }; class PanGesture extends Feature { constructor() { super(...arguments), this.removePointerDownListener = noop } onPointerDown(j) { this.session = new PanSession(j, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: getContextWindow(this.node) }) } createPanHandlers() { const { onPanSessionStart: j, onPanStart: $, onPan: _e, onPanEnd: et } = this.node.getProps(); return { onSessionStart: asyncHandler(j), onStart: asyncHandler($), onMove: _e, onEnd: (tt, rt) => { delete this.session, et && et(tt, rt) } } } mount() { this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", j => this.onPointerDown(j)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function usePresence() { const _ = reactExports.useContext(PresenceContext); if (_ === null) return [!0, null]; const { isPresent: j, onExitComplete: $, register: _e } = _, et = reactExports.useId(); return reactExports.useEffect(() => _e(et), []), !j && $ ? [!1, () => $ && $(et)] : [!0] } const globalProjectionState = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function pixelsToPercent(_, j) { return j.max === j.min ? 0 : _ / (j.max - j.min) * 100 } const correctBorderRadius = { correct: (_, j) => { if (!j.target) return _; if (typeof _ == "string") if (px.test(_)) _ = parseFloat(_); else return _; const $ = pixelsToPercent(_, j.target.x), _e = pixelsToPercent(_, j.target.y); return `${$}% ${_e}%` } }, correctBoxShadow = { correct: (_, { treeScale: j, projectionDelta: $ }) => { const _e = _, et = complex.parse(_); if (et.length > 5) return _e; const tt = complex.createTransformer(_), rt = typeof et[0] != "number" ? 1 : 0, nt = $.x.scale * j.x, it = $.y.scale * j.y; et[0 + rt] /= nt, et[1 + rt] /= it; const st = mixNumber$1(nt, it, .5); return typeof et[2 + rt] == "number" && (et[2 + rt] /= st), typeof et[3 + rt] == "number" && (et[3 + rt] /= st), tt(et) } }; class MeasureLayoutWithContext extends React$1.Component { componentDidMount() { const { visualElement: j, layoutGroup: $, switchLayoutGroup: _e, layoutId: et } = this.props, { projection: tt } = j; addScaleCorrector(defaultScaleCorrectors), tt && ($.group && $.group.add(tt), _e && _e.register && et && _e.register(tt), tt.root.didUpdate(), tt.addEventListener("animationComplete", () => { this.safeToRemove() }), tt.setOptions({ ...tt.options, onExitComplete: () => this.safeToRemove() })), globalProjectionState.hasEverUpdated = !0 } getSnapshotBeforeUpdate(j) { const { layoutDependency: $, visualElement: _e, drag: et, isPresent: tt } = this.props, rt = _e.projection; return rt && (rt.isPresent = tt, et || j.layoutDependency !== $ || $ === void 0 ? rt.willUpdate() : this.safeToRemove(), j.isPresent !== tt && (tt ? rt.promote() : rt.relegate() || frame.postRender(() => { const nt = rt.getStack(); (!nt || !nt.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: j } = this.props.visualElement; j && (j.root.didUpdate(), microtask.postRender(() => { !j.currentAnimation && j.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: j, layoutGroup: $, switchLayoutGroup: _e } = this.props, { projection: et } = j; et && (et.scheduleCheckAfterUnmount(), $ && $.group && $.group.remove(et), _e && _e.deregister && _e.deregister(et)) } safeToRemove() { const { safeToRemove: j } = this.props; j && j() } render() { return null } } function MeasureLayout(_) { const [j, $] = usePresence(), _e = reactExports.useContext(LayoutGroupContext); return React$1.createElement(MeasureLayoutWithContext, { ..._, layoutGroup: _e, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent: j, safeToRemove: $ }) } const defaultScaleCorrectors = { borderRadius: { ...correctBorderRadius, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: correctBorderRadius, borderTopRightRadius: correctBorderRadius, borderBottomLeftRadius: correctBorderRadius, borderBottomRightRadius: correctBorderRadius, boxShadow: correctBoxShadow }, borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = _ => typeof _ == "string" ? parseFloat(_) : _, isPx = _ => typeof _ == "number" || px.test(_); function mixValues(_, j, $, _e, et, tt) { et ? (_.opacity = mixNumber$1(0, $.opacity !== void 0 ? $.opacity : 1, easeCrossfadeIn(_e)), _.opacityExit = mixNumber$1(j.opacity !== void 0 ? j.opacity : 1, 0, easeCrossfadeOut(_e))) : tt && (_.opacity = mixNumber$1(j.opacity !== void 0 ? j.opacity : 1, $.opacity !== void 0 ? $.opacity : 1, _e)); for (let rt = 0; rt < numBorders; rt++) { const nt = `border${borders[rt]}Radius`; let it = getRadius(j, nt), st = getRadius($, nt); if (it === void 0 && st === void 0) continue; it || (it = 0), st || (st = 0), it === 0 || st === 0 || isPx(it) === isPx(st) ? (_[nt] = Math.max(mixNumber$1(asNumber(it), asNumber(st), _e), 0), (percent.test(st) || percent.test(it)) && (_[nt] += "%")) : _[nt] = st } (j.rotate || $.rotate) && (_.rotate = mixNumber$1(j.rotate || 0, $.rotate || 0, _e)) } function getRadius(_, j) { return _[j] !== void 0 ? _[j] : _.borderRadius } const easeCrossfadeIn = compress(0, .5, circOut), easeCrossfadeOut = compress(.5, .95, noop); function compress(_, j, $) { return _e => _e < _ ? 0 : _e > j ? 1 : $(progress(_, j, _e)) } function copyAxisInto(_, j) { _.min = j.min, _.max = j.max } function copyBoxInto(_, j) { copyAxisInto(_.x, j.x), copyAxisInto(_.y, j.y) } function removePointDelta(_, j, $, _e, et) { return _ -= j, _ = scalePoint(_, 1 / $, _e), et !== void 0 && (_ = scalePoint(_, 1 / et, _e)), _ } function removeAxisDelta(_, j = 0, $ = 1, _e = .5, et, tt = _, rt = _) { if (percent.test(j) && (j = parseFloat(j), j = mixNumber$1(rt.min, rt.max, j / 100) - rt.min), typeof j != "number") return; let nt = mixNumber$1(tt.min, tt.max, _e); _ === tt && (nt -= j), _.min = removePointDelta(_.min, j, $, nt, et), _.max = removePointDelta(_.max, j, $, nt, et) } function removeAxisTransforms(_, j, [$, _e, et], tt, rt) { removeAxisDelta(_, j[$], j[_e], j[et], j.scale, tt, rt) } const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"]; function removeBoxTransforms(_, j, $, _e) { removeAxisTransforms(_.x, j, xKeys, $ ? $.x : void 0, _e ? _e.x : void 0), removeAxisTransforms(_.y, j, yKeys, $ ? $.y : void 0, _e ? _e.y : void 0) } function isAxisDeltaZero(_) { return _.translate === 0 && _.scale === 1 } function isDeltaZero(_) { return isAxisDeltaZero(_.x) && isAxisDeltaZero(_.y) } function boxEquals(_, j) { return _.x.min === j.x.min && _.x.max === j.x.max && _.y.min === j.y.min && _.y.max === j.y.max } function boxEqualsRounded(_, j) { return Math.round(_.x.min) === Math.round(j.x.min) && Math.round(_.x.max) === Math.round(j.x.max) && Math.round(_.y.min) === Math.round(j.y.min) && Math.round(_.y.max) === Math.round(j.y.max) } function aspectRatio(_) { return calcLength(_.x) / calcLength(_.y) } class NodeStack { constructor() { this.members = [] } add(j) { addUniqueItem(this.members, j), j.scheduleRender() } remove(j) { if (removeItem(this.members, j), j === this.prevLead && (this.prevLead = void 0), j === this.lead) { const $ = this.members[this.members.length - 1]; $ && this.promote($) } } relegate(j) { const $ = this.members.findIndex(et => j === et); if ($ === 0) return !1; let _e; for (let et = $; et >= 0; et--) { const tt = this.members[et]; if (tt.isPresent !== !1) { _e = tt; break } } return _e ? (this.promote(_e), !0) : !1 } promote(j, $) { const _e = this.lead; if (j !== _e && (this.prevLead = _e, this.lead = j, j.show(), _e)) { _e.instance && _e.scheduleRender(), j.scheduleRender(), j.resumeFrom = _e, $ && (j.resumeFrom.preserveOpacity = !0), _e.snapshot && (j.snapshot = _e.snapshot, j.snapshot.latestValues = _e.animationValues || _e.latestValues), j.root && j.root.isUpdating && (j.isLayoutDirty = !0); const { crossfade: et } = j.options; et === !1 && _e.hide() } } exitAnimationComplete() { this.members.forEach(j => { const { options: $, resumingFrom: _e } = j; $.onExitComplete && $.onExitComplete(), _e && _e.options.onExitComplete && _e.options.onExitComplete() }) } scheduleRender() { this.members.forEach(j => { j.instance && j.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function buildProjectionTransform(_, j, $) { let _e = ""; const et = _.x.translate / j.x, tt = _.y.translate / j.y; if ((et || tt) && (_e = `translate3d(${et}px, ${tt}px, 0) `), (j.x !== 1 || j.y !== 1) && (_e += `scale(${1 / j.x}, ${1 / j.y}) `), $) { const { rotate: it, rotateX: st, rotateY: ot } = $; it && (_e += `rotate(${it}deg) `), st && (_e += `rotateX(${st}deg) `), ot && (_e += `rotateY(${ot}deg) `) } const rt = _.x.scale * j.x, nt = _.y.scale * j.y; return (rt !== 1 || nt !== 1) && (_e += `scale(${rt}, ${nt})`), _e || "none" } const compareByDepth = (_, j) => _.depth - j.depth; class FlatTree { constructor() { this.children = [], this.isDirty = !1 } add(j) { addUniqueItem(this.children, j), this.isDirty = !0 } remove(j) { removeItem(this.children, j), this.isDirty = !0 } forEach(j) { this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(j) } } function delay(_, j) { const $ = time.now(), _e = ({ timestamp: et }) => { const tt = et - $; tt >= j && (cancelFrame(_e), _(tt - j)) }; return frame.read(_e, !0), () => cancelFrame(_e) } function record(_) { window.MotionDebug && window.MotionDebug.record(_) } function isSVGElement(_) { return _ instanceof SVGElement && _.tagName !== "svg" } function animateSingleValue(_, j, $) { const _e = isMotionValue(_) ? _ : motionValue(_); return _e.start(animateMotionValue("", _e, j, $)), _e.animation } const transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = { visibility: "hidden" }, animationTarget = 1e3; let id = 0; const projectionFrameData = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function createProjectionNode({ attachResizeListener: _, defaultParent: j, measureScroll: $, checkIsScrollRoot: _e, resetTransform: et }) { return class { constructor(rt = {}, nt = j == null ? void 0 : j()) { this.id = id++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), record(projectionFrameData) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = rt, this.root = nt ? nt.root || nt : this, this.path = nt ? [...nt.path, nt] : [], this.parent = nt, this.depth = nt ? nt.depth + 1 : 0; for (let it = 0; it < this.path.length; it++)this.path[it].shouldResetTransform = !0; this.root === this && (this.nodes = new FlatTree) } addEventListener(rt, nt) { return this.eventHandlers.has(rt) || this.eventHandlers.set(rt, new SubscriptionManager), this.eventHandlers.get(rt).add(nt) } notifyListeners(rt, ...nt) { const it = this.eventHandlers.get(rt); it && it.notify(...nt) } hasListeners(rt) { return this.eventHandlers.has(rt) } mount(rt, nt = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = isSVGElement(rt), this.instance = rt; const { layoutId: it, layout: st, visualElement: ot } = this.options; if (ot && !ot.current && ot.mount(rt), this.root.nodes.add(this), this.parent && this.parent.children.add(this), nt && (st || it) && (this.isLayoutDirty = !0), _) { let ft; const at = () => this.root.updateBlockedByResize = !1; _(rt, () => { this.root.updateBlockedByResize = !0, ft && ft(), ft = delay(at, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation)) }) } it && this.root.registerSharedNode(it, this), this.options.animate !== !1 && ot && (it || st) && this.addEventListener("didUpdate", ({ delta: ft, hasLayoutChanged: at, hasRelativeTargetChanged: dt, layout: pt }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const ht = this.options.transition || ot.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart: xt, onLayoutAnimationComplete: ct } = ot.getProps(), ut = !this.targetLayout || !boxEqualsRounded(this.targetLayout, pt) || dt, lt = !at && dt; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || lt || at && (ut || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(ft, lt); const mt = { ...getValueTransition(ht, "layout"), onPlay: xt, onComplete: ct }; (ot.shouldReduceMotion || this.options.layoutRoot) && (mt.delay = 0, mt.type = !1), this.startAnimation(mt) } else at || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = pt }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const rt = this.getStack(); rt && rt.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetRotation), this.animationId++) } getTransformTemplate() { const { visualElement: rt } = this.options; return rt && rt.getProps().transformTemplate } willUpdate(rt = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let ot = 0; ot < this.path.length; ot++) { const ft = this.path[ot]; ft.shouldResetTransform = !0, ft.updateScroll("snapshot"), ft.options.layoutRoot && ft.willUpdate(!1) } const { layoutId: nt, layout: it } = this.options; if (nt === void 0 && !it) return; const st = this.getTransformTemplate(); this.prevTransformTemplateValue = st ? st(this.latestValues, "") : void 0, this.updateSnapshot(), rt && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements); return } this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(), this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots(); const nt = time.now(); frameData.delta = clamp(0, 1e3 / 60, nt - frameData.timestamp), frameData.timestamp = nt, frameData.isProcessing = !0, steps.update.process(frameData), steps.preRender.process(frameData), steps.render.process(frameData), frameData.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, microtask.read(() => this.update())) } clearAllSnapshots() { this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { frame.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let it = 0; it < this.path.length; it++)this.path[it].updateScroll(); const rt = this.layout; this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: nt } = this.options; nt && nt.notify("LayoutMeasure", this.layout.layoutBox, rt ? rt.layoutBox : void 0) } updateScroll(rt = "measure") { let nt = !!(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === rt && (nt = !1), nt && (this.scroll = { animationId: this.root.animationId, phase: rt, isRoot: _e(this.instance), offset: $(this.instance) }) } resetTransform() { if (!et) return; const rt = this.isLayoutDirty || this.shouldResetTransform, nt = this.projectionDelta && !isDeltaZero(this.projectionDelta), it = this.getTransformTemplate(), st = it ? it(this.latestValues, "") : void 0, ot = st !== this.prevTransformTemplateValue; rt && (nt || hasTransform(this.latestValues) || ot) && (et(this.instance, st), this.shouldResetTransform = !1, this.scheduleRender()) } measure(rt = !0) { const nt = this.measurePageBox(); let it = this.removeElementScroll(nt); return rt && (it = this.removeTransform(it)), roundBox(it), { animationId: this.root.animationId, measuredBox: nt, layoutBox: it, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: rt } = this.options; if (!rt) return createBox(); const nt = rt.measureViewportBox(), { scroll: it } = this.root; return it && (translateAxis(nt.x, it.offset.x), translateAxis(nt.y, it.offset.y)), nt } removeElementScroll(rt) { const nt = createBox(); copyBoxInto(nt, rt); for (let it = 0; it < this.path.length; it++) { const st = this.path[it], { scroll: ot, options: ft } = st; if (st !== this.root && ot && ft.layoutScroll) { if (ot.isRoot) { copyBoxInto(nt, rt); const { scroll: at } = this.root; at && (translateAxis(nt.x, -at.offset.x), translateAxis(nt.y, -at.offset.y)) } translateAxis(nt.x, ot.offset.x), translateAxis(nt.y, ot.offset.y) } } return nt } applyTransform(rt, nt = !1) { const it = createBox(); copyBoxInto(it, rt); for (let st = 0; st < this.path.length; st++) { const ot = this.path[st]; !nt && ot.options.layoutScroll && ot.scroll && ot !== ot.root && transformBox(it, { x: -ot.scroll.offset.x, y: -ot.scroll.offset.y }), hasTransform(ot.latestValues) && transformBox(it, ot.latestValues) } return hasTransform(this.latestValues) && transformBox(it, this.latestValues), it } removeTransform(rt) { const nt = createBox(); copyBoxInto(nt, rt); for (let it = 0; it < this.path.length; it++) { const st = this.path[it]; if (!st.instance || !hasTransform(st.latestValues)) continue; hasScale(st.latestValues) && st.updateSnapshot(); const ot = createBox(), ft = st.measurePageBox(); copyBoxInto(ot, ft), removeBoxTransforms(nt, st.latestValues, st.snapshot ? st.snapshot.layoutBox : void 0, ot) } return hasTransform(this.latestValues) && removeBoxTransforms(nt, this.latestValues), nt } setTargetDelta(rt) { this.targetDelta = rt, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(rt) { this.options = { ...this.options, ...rt, crossfade: rt.crossfade !== void 0 ? rt.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(rt = !1) { var nt; const it = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = it.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = it.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = it.isSharedProjectionDirty); const st = !!this.resumingFrom || this !== it; if (!(rt || st && this.isSharedProjectionDirty || this.isProjectionDirty || !((nt = this.parent) === null || nt === void 0) && nt.isProjectionDirty || this.attemptToResolveRelativeTarget)) return; const { layout: ft, layoutId: at } = this.options; if (!(!this.layout || !(ft || at))) { if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) { const dt = this.getClosestProjectingParent(); dt && dt.layout && this.animationProgress !== 1 ? (this.relativeParent = dt, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, dt.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const dt = this.getClosestProjectingParent(); dt && !!dt.resumingFrom == !!this.resumingFrom && !dt.options.layoutScroll && dt.target && this.animationProgress !== 1 ? (this.relativeParent = dt, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, dt.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } projectionFrameData.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var rt; const nt = this.getLead(), it = !!this.resumingFrom || this !== nt; let st = !0; if ((this.isProjectionDirty || !((rt = this.parent) === null || rt === void 0) && rt.isProjectionDirty) && (st = !1), it && (this.isSharedProjectionDirty || this.isTransformDirty) && (st = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (st = !1), st) return; const { layout: ot, layoutId: ft } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(ot || ft)) return; copyBoxInto(this.layoutCorrected, this.layout.layoutBox); const at = this.treeScale.x, dt = this.treeScale.y; applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, it), nt.layout && !nt.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (nt.target = nt.layout.layoutBox, nt.targetWithTransforms = createBox()); const { target: pt } = nt; if (!pt) { this.projectionTransform && (this.projectionDelta = createDelta(), this.projectionTransform = "none", this.scheduleRender()); return } this.projectionDelta || (this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta()); const ht = this.projectionTransform; calcBoxDelta(this.projectionDelta, this.layoutCorrected, pt, this.latestValues), this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale), (this.projectionTransform !== ht || this.treeScale.x !== at || this.treeScale.y !== dt) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", pt)), projectionFrameData.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(rt = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), rt) { const nt = this.getStack(); nt && nt.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(rt, nt = !1) { const it = this.snapshot, st = it ? it.latestValues : {}, ot = { ...this.latestValues }, ft = createDelta(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !nt; const at = createBox(), dt = it ? it.source : void 0, pt = this.layout ? this.layout.source : void 0, ht = dt !== pt, xt = this.getStack(), ct = !xt || xt.members.length <= 1, ut = !!(ht && !ct && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade)); this.animationProgress = 0; let lt; this.mixTargetDelta = mt => { const yt = mt / 1e3; mixAxisDelta(ft.x, rt.x, yt), mixAxisDelta(ft.y, rt.y, yt), this.setTargetDelta(ft), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(at, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, at, yt), lt && boxEquals(this.relativeTarget, lt) && (this.isProjectionDirty = !1), lt || (lt = createBox()), copyBoxInto(lt, this.relativeTarget)), ht && (this.animationValues = ot, mixValues(ot, st, this.latestValues, yt, ut, ct)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = yt }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(rt) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => { globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, { ...rt, onUpdate: nt => { this.mixTargetDelta(nt), rt.onUpdate && rt.onUpdate(nt) }, onComplete: () => { rt.onComplete && rt.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const rt = this.getStack(); rt && rt.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const rt = this.getLead(); let { targetWithTransforms: nt, target: it, layout: st, latestValues: ot } = rt; if (!(!nt || !it || !st)) { if (this !== rt && this.layout && st && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, st.layoutBox)) { it = this.target || createBox(); const ft = calcLength(this.layout.layoutBox.x); it.x.min = rt.target.x.min, it.x.max = it.x.min + ft; const at = calcLength(this.layout.layoutBox.y); it.y.min = rt.target.y.min, it.y.max = it.y.min + at } copyBoxInto(nt, it), transformBox(nt, ot), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, nt, ot) } } registerSharedNode(rt, nt) { this.sharedNodes.has(rt) || this.sharedNodes.set(rt, new NodeStack), this.sharedNodes.get(rt).add(nt); const st = nt.options.initialPromotionConfig; nt.promote({ transition: st ? st.transition : void 0, preserveFollowOpacity: st && st.shouldPreserveFollowOpacity ? st.shouldPreserveFollowOpacity(nt) : void 0 }) } isLead() { const rt = this.getStack(); return rt ? rt.lead === this : !0 } getLead() { var rt; const { layoutId: nt } = this.options; return nt ? ((rt = this.getStack()) === null || rt === void 0 ? void 0 : rt.lead) || this : this } getPrevLead() { var rt; const { layoutId: nt } = this.options; return nt ? (rt = this.getStack()) === null || rt === void 0 ? void 0 : rt.prevLead : void 0 } getStack() { const { layoutId: rt } = this.options; if (rt) return this.root.sharedNodes.get(rt) } promote({ needsReset: rt, transition: nt, preserveFollowOpacity: it } = {}) { const st = this.getStack(); st && st.promote(this, it), rt && (this.projectionDelta = void 0, this.needsReset = !0), nt && this.setOptions({ transition: nt }) } relegate() { const rt = this.getStack(); return rt ? rt.relegate(this) : !1 } resetRotation() { const { visualElement: rt } = this.options; if (!rt) return; let nt = !1; const { latestValues: it } = rt; if ((it.rotate || it.rotateX || it.rotateY || it.rotateZ) && (nt = !0), !nt) return; const st = {}; for (let ot = 0; ot < transformAxes.length; ot++) { const ft = "rotate" + transformAxes[ot]; it[ft] && (st[ft] = it[ft], rt.setStaticValue(ft, 0)) } rt.render(); for (const ot in st) rt.setStaticValue(ot, st[ot]); rt.scheduleRender() } getProjectionStyles(rt) { var nt, it; if (!this.instance || this.isSVG) return; if (!this.isVisible) return hiddenVisibility; const st = { visibility: "" }, ot = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, st.opacity = "", st.pointerEvents = resolveMotionValue(rt == null ? void 0 : rt.pointerEvents) || "", st.transform = ot ? ot(this.latestValues, "") : "none", st; const ft = this.getLead(); if (!this.projectionDelta || !this.layout || !ft.target) { const ht = {}; return this.options.layoutId && (ht.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, ht.pointerEvents = resolveMotionValue(rt == null ? void 0 : rt.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (ht.transform = ot ? ot({}, "") : "none", this.hasProjected = !1), ht } const at = ft.animationValues || ft.latestValues; this.applyTransformsToTarget(), st.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, at), ot && (st.transform = ot(at, st.transform)); const { x: dt, y: pt } = this.projectionDelta; st.transformOrigin = `${dt.origin * 100}% ${pt.origin * 100}% 0`, ft.animationValues ? st.opacity = ft === this ? (it = (nt = at.opacity) !== null && nt !== void 0 ? nt : this.latestValues.opacity) !== null && it !== void 0 ? it : 1 : this.preserveOpacity ? this.latestValues.opacity : at.opacityExit : st.opacity = ft === this ? at.opacity !== void 0 ? at.opacity : "" : at.opacityExit !== void 0 ? at.opacityExit : 0; for (const ht in scaleCorrectors) { if (at[ht] === void 0) continue; const { correct: xt, applyTo: ct } = scaleCorrectors[ht], ut = st.transform === "none" ? at[ht] : xt(at[ht], ft); if (ct) { const lt = ct.length; for (let mt = 0; mt < lt; mt++)st[ct[mt]] = ut } else st[ht] = ut } return this.options.layoutId && (st.pointerEvents = ft === this ? resolveMotionValue(rt == null ? void 0 : rt.pointerEvents) || "" : "none"), st } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(rt => { var nt; return (nt = rt.currentAnimation) === null || nt === void 0 ? void 0 : nt.stop() }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear() } } } function updateLayout(_) { _.updateLayout() } function notifyLayoutUpdate(_) { var j; const $ = ((j = _.resumeFrom) === null || j === void 0 ? void 0 : j.snapshot) || _.snapshot; if (_.isLead() && _.layout && $ && _.hasListeners("didUpdate")) { const { layoutBox: _e, measuredBox: et } = _.layout, { animationType: tt } = _.options, rt = $.source !== _.layout.source; tt === "size" ? eachAxis(ft => { const at = rt ? $.measuredBox[ft] : $.layoutBox[ft], dt = calcLength(at); at.min = _e[ft].min, at.max = at.min + dt }) : shouldAnimatePositionOnly(tt, $.layoutBox, _e) && eachAxis(ft => { const at = rt ? $.measuredBox[ft] : $.layoutBox[ft], dt = calcLength(_e[ft]); at.max = at.min + dt, _.relativeTarget && !_.currentAnimation && (_.isProjectionDirty = !0, _.relativeTarget[ft].max = _.relativeTarget[ft].min + dt) }); const nt = createDelta(); calcBoxDelta(nt, _e, $.layoutBox); const it = createDelta(); rt ? calcBoxDelta(it, _.applyTransform(et, !0), $.measuredBox) : calcBoxDelta(it, _e, $.layoutBox); const st = !isDeltaZero(nt); let ot = !1; if (!_.resumeFrom) { const ft = _.getClosestProjectingParent(); if (ft && !ft.resumeFrom) { const { snapshot: at, layout: dt } = ft; if (at && dt) { const pt = createBox(); calcRelativePosition(pt, $.layoutBox, at.layoutBox); const ht = createBox(); calcRelativePosition(ht, _e, dt.layoutBox), boxEqualsRounded(pt, ht) || (ot = !0), ft.options.layoutRoot && (_.relativeTarget = ht, _.relativeTargetOrigin = pt, _.relativeParent = ft) } } } _.notifyListeners("didUpdate", { layout: _e, snapshot: $, delta: it, layoutDelta: nt, hasLayoutChanged: st, hasRelativeTargetChanged: ot }) } else if (_.isLead()) { const { onExitComplete: _e } = _.options; _e && _e() } _.options.transition = void 0 } function propagateDirtyNodes(_) { projectionFrameData.totalNodes++, _.parent && (_.isProjecting() || (_.isProjectionDirty = _.parent.isProjectionDirty), _.isSharedProjectionDirty || (_.isSharedProjectionDirty = !!(_.isProjectionDirty || _.parent.isProjectionDirty || _.parent.isSharedProjectionDirty)), _.isTransformDirty || (_.isTransformDirty = _.parent.isTransformDirty)) } function cleanDirtyNodes(_) { _.isProjectionDirty = _.isSharedProjectionDirty = _.isTransformDirty = !1 } function clearSnapshot(_) { _.clearSnapshot() } function clearMeasurements(_) { _.clearMeasurements() } function clearIsLayoutDirty(_) { _.isLayoutDirty = !1 } function resetTransformStyle(_) { const { visualElement: j } = _.options; j && j.getProps().onBeforeLayoutMeasure && j.notify("BeforeLayoutMeasure"), _.resetTransform() } function finishAnimation(_) { _.finishAnimation(), _.targetDelta = _.relativeTarget = _.target = void 0, _.isProjectionDirty = !0 } function resolveTargetDelta(_) { _.resolveTargetDelta() } function calcProjection(_) { _.calcProjection() } function resetRotation(_) { _.resetRotation() } function removeLeadSnapshots(_) { _.removeLeadSnapshot() } function mixAxisDelta(_, j, $) { _.translate = mixNumber$1(j.translate, 0, $), _.scale = mixNumber$1(j.scale, 1, $), _.origin = j.origin, _.originPoint = j.originPoint } function mixAxis(_, j, $, _e) { _.min = mixNumber$1(j.min, $.min, _e), _.max = mixNumber$1(j.max, $.max, _e) } function mixBox(_, j, $, _e) { mixAxis(_.x, j.x, $.x, _e), mixAxis(_.y, j.y, $.y, _e) } function hasOpacityCrossfade(_) { return _.animationValues && _.animationValues.opacityExit !== void 0 } const defaultLayoutTransition = { duration: .45, ease: [.4, 0, .1, 1] }, userAgentContains = _ => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(_), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop; function roundAxis(_) { _.min = roundPoint(_.min), _.max = roundPoint(_.max) } function roundBox(_) { roundAxis(_.x), roundAxis(_.y) } function shouldAnimatePositionOnly(_, j, $) { return _ === "position" || _ === "preserve-aspect" && !isNear(aspectRatio(j), aspectRatio($), .2) } const DocumentProjectionNode = createProjectionNode({ attachResizeListener: (_, j) => addDomEvent(_, "resize", j), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), rootProjectionNode = { current: void 0 }, HTMLProjectionNode = createProjectionNode({ measureScroll: _ => ({ x: _.scrollLeft, y: _.scrollTop }), defaultParent: () => { if (!rootProjectionNode.current) { const _ = new DocumentProjectionNode({}); _.mount(window), _.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = _ } return rootProjectionNode.current }, resetTransform: (_, j) => { _.style.transform = j !== void 0 ? j : "none" }, checkIsScrollRoot: _ => window.getComputedStyle(_).position === "fixed" }), drag = { pan: { Feature: PanGesture }, drag: { Feature: DragGesture, ProjectionNode: HTMLProjectionNode, MeasureLayout } }, prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 }; function initPrefersReducedMotion() { if (hasReducedMotionListener.current = !0, !!isBrowser$1) if (window.matchMedia) { const _ = window.matchMedia("(prefers-reduced-motion)"), j = () => prefersReducedMotion.current = _.matches; _.addListener(j), j() } else prefersReducedMotion.current = !1 } function updateMotionValuesFromProps(_, j, $) { const { willChange: _e } = j; for (const et in j) { const tt = j[et], rt = $[et]; if (isMotionValue(tt)) _.addValue(et, tt), isWillChangeMotionValue(_e) && _e.add(et); else if (isMotionValue(rt)) _.addValue(et, motionValue(tt, { owner: _ })), isWillChangeMotionValue(_e) && _e.remove(et); else if (rt !== tt) if (_.hasValue(et)) { const nt = _.getValue(et); !nt.hasAnimated && nt.set(tt) } else { const nt = _.getStaticValue(et); _.addValue(et, motionValue(nt !== void 0 ? nt : tt, { owner: _ })) } } for (const et in $) j[et] === void 0 && _.removeValue(et); return j } const visualElementStore = new WeakMap, valueTypes = [...dimensionValueTypes, color, complex], findValueType = _ => valueTypes.find(testValueType(_)), featureNames = Object.keys(featureDefinitions), numFeatures = featureNames.length, propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], numVariantProps = variantProps.length; class VisualElement { constructor({ parent: j, props: $, presenceContext: _e, reducedMotionConfig: et, blockInitialAnimation: tt, visualState: rt }, nt = {}) { this.resolveKeyframes = (at, dt, pt, ht) => new this.KeyframeResolver(at, dt, pt, ht, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => frame.render(this.render, !1, !0); const { latestValues: it, renderState: st } = rt; this.latestValues = it, this.baseTarget = { ...it }, this.initialValues = $.initial ? { ...it } : {}, this.renderState = st, this.parent = j, this.props = $, this.presenceContext = _e, this.depth = j ? j.depth + 1 : 0, this.reducedMotionConfig = et, this.options = nt, this.blockInitialAnimation = !!tt, this.isControllingVariants = isControllingVariants($), this.isVariantNode = isVariantNode($), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(j && j.current); const { willChange: ot, ...ft } = this.scrapeMotionValuesFromProps($, {}); for (const at in ft) { const dt = ft[at]; it[at] !== void 0 && isMotionValue(dt) && (dt.set(it[at], !1), isWillChangeMotionValue(ot) && ot.add(at)) } } scrapeMotionValuesFromProps(j, $) { return {} } mount(j) { this.current = j, visualElementStore.set(j, this), this.projection && !this.projection.instance && this.projection.mount(j), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach(($, _e) => this.bindToMotionValue(_e, $)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach(j => j()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const j in this.events) this.events[j].clear(); for (const j in this.features) this.features[j].unmount(); this.current = null } bindToMotionValue(j, $) { const _e = transformProps.has(j), et = $.on("change", rt => { this.latestValues[j] = rt, this.props.onUpdate && frame.preRender(this.notifyUpdate), _e && this.projection && (this.projection.isTransformDirty = !0) }), tt = $.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(j, () => { et(), tt() }) } sortNodePosition(j) { return !this.current || !this.sortInstanceNodePosition || this.type !== j.type ? 0 : this.sortInstanceNodePosition(this.current, j.current) } loadFeatures({ children: j, ...$ }, _e, et, tt) { let rt, nt; for (let it = 0; it < numFeatures; it++) { const st = featureNames[it], { isEnabled: ot, Feature: ft, ProjectionNode: at, MeasureLayout: dt } = featureDefinitions[st]; at && (rt = at), ot($) && (!this.features[st] && ft && (this.features[st] = new ft(this)), dt && (nt = dt)) } if ((this.type === "html" || this.type === "svg") && !this.projection && rt) { this.projection = new rt(this.latestValues, this.parent && this.parent.projection); const { layoutId: it, layout: st, drag: ot, dragConstraints: ft, layoutScroll: at, layoutRoot: dt } = $; this.projection.setOptions({ layoutId: it, layout: st, alwaysMeasureLayout: !!ot || ft && isRefObject(ft), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof st == "string" ? st : "both", initialPromotionConfig: tt, layoutScroll: at, layoutRoot: dt }) } return nt } updateFeatures() { for (const j in this.features) { const $ = this.features[j]; $.isMounted ? $.update() : ($.mount(), $.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox() } getStaticValue(j) { return this.latestValues[j] } setStaticValue(j, $) { this.latestValues[j] = $ } update(j, $) { (j.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = j, this.prevPresenceContext = this.presenceContext, this.presenceContext = $; for (let _e = 0; _e < propEventHandlers.length; _e++) { const et = propEventHandlers[_e]; this.propEventSubscriptions[et] && (this.propEventSubscriptions[et](), delete this.propEventSubscriptions[et]); const tt = j["on" + et]; tt && (this.propEventSubscriptions[et] = this.on(et, tt)) } this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(j, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(j) { return this.props.variants ? this.props.variants[j] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(j = !1) { if (j) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const _e = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (_e.initial = this.props.initial), _e } const $ = {}; for (let _e = 0; _e < numVariantProps; _e++) { const et = variantProps[_e], tt = this.props[et]; (isVariantLabel(tt) || tt === !1) && ($[et] = tt) } return $ } addVariantChild(j) { const $ = this.getClosestVariantNode(); if ($) return $.variantChildren && $.variantChildren.add(j), () => $.variantChildren.delete(j) } addValue(j, $) { $ !== this.values.get(j) && (this.removeValue(j), this.bindToMotionValue(j, $)), this.values.set(j, $), this.latestValues[j] = $.get() } removeValue(j) { this.values.delete(j); const $ = this.valueSubscriptions.get(j); $ && ($(), this.valueSubscriptions.delete(j)), delete this.latestValues[j], this.removeValueFromRenderState(j, this.renderState) } hasValue(j) { return this.values.has(j) } getValue(j, $) { if (this.props.values && this.props.values[j]) return this.props.values[j]; let _e = this.values.get(j); return _e === void 0 && $ !== void 0 && (_e = motionValue($ === null ? void 0 : $, { owner: this }), this.addValue(j, _e)), _e } readValue(j, $) { var _e; let et = this.latestValues[j] !== void 0 || !this.current ? this.latestValues[j] : (_e = this.getBaseTargetFromProps(this.props, j)) !== null && _e !== void 0 ? _e : this.readValueFromInstance(this.current, j, this.options); return et != null && (typeof et == "string" && (isNumericalString(et) || isZeroValueString(et)) ? et = parseFloat(et) : !findValueType(et) && complex.test($) && (et = getAnimatableNone(j, $)), this.setBaseTarget(j, isMotionValue(et) ? et.get() : et)), isMotionValue(et) ? et.get() : et } setBaseTarget(j, $) { this.baseTarget[j] = $ } getBaseTarget(j) { var $, _e; const { initial: et } = this.props, tt = typeof et == "string" || typeof et == "object" ? (_e = resolveVariantFromProps(this.props, et, ($ = this.presenceContext) === null || $ === void 0 ? void 0 : $.custom)) === null || _e === void 0 ? void 0 : _e[j] : void 0; if (et && tt !== void 0) return tt; const rt = this.getBaseTargetFromProps(this.props, j); return rt !== void 0 && !isMotionValue(rt) ? rt : this.initialValues[j] !== void 0 && tt === void 0 ? void 0 : this.baseTarget[j] } on(j, $) { return this.events[j] || (this.events[j] = new SubscriptionManager), this.events[j].add($) } notify(j, ...$) { this.events[j] && this.events[j].notify(...$) } } class DOMVisualElement extends VisualElement { constructor() { super(...arguments), this.KeyframeResolver = DOMKeyframesResolver } sortInstanceNodePosition(j, $) { return j.compareDocumentPosition($) & 2 ? 1 : -1 } getBaseTargetFromProps(j, $) { return j.style ? j.style[$] : void 0 } removeValueFromRenderState(j, { vars: $, style: _e }) { delete $[j], delete _e[j] } } function getComputedStyle$1(_) { return window.getComputedStyle(_) } class HTMLVisualElement extends DOMVisualElement { constructor() { super(...arguments), this.type = "html" } readValueFromInstance(j, $) { if (transformProps.has($)) { const _e = getDefaultValueType($); return _e && _e.default || 0 } else { const _e = getComputedStyle$1(j), et = (isCSSVariableName($) ? _e.getPropertyValue($) : _e[$]) || 0; return typeof et == "string" ? et.trim() : et } } measureInstanceViewportBox(j, { transformPagePoint: $ }) { return measureViewportBox(j, $) } build(j, $, _e, et) { buildHTMLStyles(j, $, _e, et.transformTemplate) } scrapeMotionValuesFromProps(j, $) { return scrapeMotionValuesFromProps$1(j, $) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: j } = this.props; isMotionValue(j) && (this.childSubscription = j.on("change", $ => { this.current && (this.current.textContent = `${$}`) })) } renderInstance(j, $, _e, et) { renderHTML(j, $, _e, et) } } class SVGVisualElement extends DOMVisualElement { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1 } getBaseTargetFromProps(j, $) { return j[$] } readValueFromInstance(j, $) { if (transformProps.has($)) { const _e = getDefaultValueType($); return _e && _e.default || 0 } return $ = camelCaseAttributes.has($) ? $ : camelToDash($), j.getAttribute($) } measureInstanceViewportBox() { return createBox() } scrapeMotionValuesFromProps(j, $) { return scrapeMotionValuesFromProps(j, $) } build(j, $, _e, et) { buildSVGAttrs(j, $, _e, this.isSVGTag, et.transformTemplate) } renderInstance(j, $, _e, et) { renderSVG(j, $, _e, et) } mount(j) { this.isSVGTag = isSVGTag(j.tagName), super.mount(j) } } const createDomVisualElement = (_, j) => isSVGComponent(_) ? new SVGVisualElement(j, { enableHardwareAcceleration: !1 }) : new HTMLVisualElement(j, { enableHardwareAcceleration: !0 }), layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout } }, preloadedFeatures = { ...animations, ...gestureAnimations, ...drag, ...layout }, motion = createMotionProxy((_, j) => createDomMotionConfig(_, j, preloadedFeatures, createDomVisualElement)); function useMotionValue(_) { const j = useConstant(() => motionValue(_)), { isStatic: $ } = reactExports.useContext(MotionConfigContext); if ($) { const [, _e] = reactExports.useState(_); reactExports.useEffect(() => j.on("change", _e), []) } return j } const isCustomValueType = _ => _ && typeof _ == "object" && _.mix, getMixer = _ => isCustomValueType(_) ? _.mix : void 0; function transform(..._) { const j = !Array.isArray(_[0]), $ = j ? 0 : -1, _e = _[0 + $], et = _[1 + $], tt = _[2 + $], rt = _[3 + $], nt = interpolate(et, tt, { mixer: getMixer(tt[0]), ...rt }); return j ? nt(_e) : nt } function useCombineMotionValues(_, j) { const $ = useMotionValue(j()), _e = () => $.set(j()); return _e(), useIsomorphicLayoutEffect(() => { const et = () => frame.update(_e, !1, !0), tt = _.map(rt => rt.on("change", et)); return () => { tt.forEach(rt => rt()), cancelFrame(_e) } }), $ } function useComputed(_) { collectMotionValues.current = [], _(); const j = useCombineMotionValues(collectMotionValues.current, _); return collectMotionValues.current = void 0, j } function useTransform(_, j, $, _e) { if (typeof _ == "function") return useComputed(_); const et = typeof j == "function" ? j : transform(j, $, _e); return Array.isArray(_) ? useListTransform(_, et) : useListTransform([_], ([tt]) => et(tt)) } function useListTransform(_, j) { const $ = useConstant(() => []); return useCombineMotionValues(_, () => { $.length = 0; const _e = _.length; for (let et = 0; et < _e; et++)$[et] = _[et].get(); return j($) }) } function resolveElements(_, j, $) { var _e; if (typeof _ == "string") { let et = document; j && (invariant(!!j.current), et = j.current), $ ? ((_e = $[_]) !== null && _e !== void 0 || ($[_] = et.querySelectorAll(_)), _ = $[_]) : _ = et.querySelectorAll(_) } else _ instanceof Element && (_ = [_]); return Array.from(_ || []) } const resizeHandlers = new WeakMap; let observer; function getElementSize(_, j) { if (j) { const { inlineSize: $, blockSize: _e } = j[0]; return { width: $, height: _e } } else return _ instanceof SVGElement && "getBBox" in _ ? _.getBBox() : { width: _.offsetWidth, height: _.offsetHeight } } function notifyTarget({ target: _, contentRect: j, borderBoxSize: $ }) { var _e; (_e = resizeHandlers.get(_)) === null || _e === void 0 || _e.forEach(et => { et({ target: _, contentSize: j, get size() { return getElementSize(_, $) } }) }) } function notifyAll(_) { _.forEach(notifyTarget) } function createResizeObserver() { typeof ResizeObserver > "u" || (observer = new ResizeObserver(notifyAll)) } function resizeElement(_, j) { observer || createResizeObserver(); const $ = resolveElements(_); return $.forEach(_e => { let et = resizeHandlers.get(_e); et || (et = new Set, resizeHandlers.set(_e, et)), et.add(j), observer == null || observer.observe(_e) }), () => { $.forEach(_e => { const et = resizeHandlers.get(_e); et == null || et.delete(j), et != null && et.size || observer == null || observer.unobserve(_e) }) } } const windowCallbacks = new Set; let windowResizeHandler; function createWindowResizeHandler() { windowResizeHandler = () => { const _ = { width: window.innerWidth, height: window.innerHeight }, j = { target: window, size: _, contentSize: _ }; windowCallbacks.forEach($ => $(j)) }, window.addEventListener("resize", windowResizeHandler) } function resizeWindow(_) { return windowCallbacks.add(_), windowResizeHandler || createWindowResizeHandler(), () => { windowCallbacks.delete(_), !windowCallbacks.size && windowResizeHandler && (windowResizeHandler = void 0) } } function resize(_, j) { return typeof _ == "function" ? resizeWindow(_) : resizeElement(_, j) } const maxElapsed = 50, createAxisInfo = () => ({ current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }), createScrollInfo = () => ({ time: 0, x: createAxisInfo(), y: createAxisInfo() }), keys = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function updateAxisInfo(_, j, $, _e) { const et = $[j], { length: tt, position: rt } = keys[j], nt = et.current, it = $.time; et.current = _["scroll" + rt], et.scrollLength = _["scroll" + tt] - _["client" + tt], et.offset.length = 0, et.offset[0] = 0, et.offset[1] = et.scrollLength, et.progress = progress(0, et.scrollLength, et.current); const st = _e - it; et.velocity = st > maxElapsed ? 0 : velocityPerSecond(et.current - nt, st) } function updateScrollInfo(_, j, $) { updateAxisInfo(_, "x", j, $), updateAxisInfo(_, "y", j, $), j.time = $ } function calcInset(_, j) { const $ = { x: 0, y: 0 }; let _e = _; for (; _e && _e !== j;)if (_e instanceof HTMLElement) $.x += _e.offsetLeft, $.y += _e.offsetTop, _e = _e.offsetParent; else if (_e.tagName === "svg") { const et = _e.getBoundingClientRect(); _e = _e.parentElement; const tt = _e.getBoundingClientRect(); $.x += et.left - tt.left, $.y += et.top - tt.top } else if (_e instanceof SVGGraphicsElement) { const { x: et, y: tt } = _e.getBBox(); $.x += et, $.y += tt; let rt = null, nt = _e.parentNode; for (; !rt;)nt.tagName === "svg" && (rt = nt), nt = _e.parentNode; _e = rt } else break; return $ } const ScrollOffset = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }, namedEdges = { start: 0, center: .5, end: 1 }; function resolveEdge(_, j, $ = 0) { let _e = 0; if (namedEdges[_] !== void 0 && (_ = namedEdges[_]), typeof _ == "string") { const et = parseFloat(_); _.endsWith("px") ? _e = et : _.endsWith("%") ? _ = et / 100 : _.endsWith("vw") ? _e = et / 100 * document.documentElement.clientWidth : _.endsWith("vh") ? _e = et / 100 * document.documentElement.clientHeight : _ = et } return typeof _ == "number" && (_e = j * _), $ + _e } const defaultOffset = [0, 0]; function resolveOffset(_, j, $, _e) { let et = Array.isArray(_) ? _ : defaultOffset, tt = 0, rt = 0; return typeof _ == "number" ? et = [_, _] : typeof _ == "string" && (_ = _.trim(), _.includes(" ") ? et = _.split(" ") : et = [_, namedEdges[_] ? _ : "0"]), tt = resolveEdge(et[0], $, _e), rt = resolveEdge(et[1], j), tt - rt } const point = { x: 0, y: 0 }; function getTargetSize(_) { return "getBBox" in _ && _.tagName !== "svg" ? _.getBBox() : { width: _.clientWidth, height: _.clientHeight } } function resolveOffsets(_, j, $) { const { offset: _e = ScrollOffset.All } = $, { target: et = _, axis: tt = "y" } = $, rt = tt === "y" ? "height" : "width", nt = et !== _ ? calcInset(et, _) : point, it = et === _ ? { width: _.scrollWidth, height: _.scrollHeight } : getTargetSize(et), st = { width: _.clientWidth, height: _.clientHeight }; j[tt].offset.length = 0; let ot = !j[tt].interpolate; const ft = _e.length; for (let at = 0; at < ft; at++) { const dt = resolveOffset(_e[at], st[rt], it[rt], nt[tt]); !ot && dt !== j[tt].interpolatorOffsets[at] && (ot = !0), j[tt].offset[at] = dt } ot && (j[tt].interpolate = interpolate(j[tt].offset, defaultOffset$1(_e)), j[tt].interpolatorOffsets = [...j[tt].offset]), j[tt].progress = j[tt].interpolate(j[tt].current) } function measure(_, j = _, $) { if ($.x.targetOffset = 0, $.y.targetOffset = 0, j !== _) { let _e = j; for (; _e && _e !== _;)$.x.targetOffset += _e.offsetLeft, $.y.targetOffset += _e.offsetTop, _e = _e.offsetParent } $.x.targetLength = j === _ ? j.scrollWidth : j.clientWidth, $.y.targetLength = j === _ ? j.scrollHeight : j.clientHeight, $.x.containerLength = _.clientWidth, $.y.containerLength = _.clientHeight } function createOnScrollHandler(_, j, $, _e = {}) { return { measure: () => measure(_, _e.target, $), update: et => { updateScrollInfo(_, $, et), (_e.offset || _e.target) && resolveOffsets(_, $, _e) }, notify: () => j($) } } const scrollListeners = new WeakMap, resizeListeners = new WeakMap, onScrollHandlers = new WeakMap, getEventTarget = _ => _ === document.documentElement ? window : _; function scrollInfo(_, { container: j = document.documentElement, ...$ } = {}) { let _e = onScrollHandlers.get(j); _e || (_e = new Set, onScrollHandlers.set(j, _e)); const et = createScrollInfo(), tt = createOnScrollHandler(j, _, et, $); if (_e.add(tt), !scrollListeners.has(j)) { const nt = () => { for (const at of _e) at.measure() }, it = () => { for (const at of _e) at.update(frameData.timestamp) }, st = () => { for (const at of _e) at.notify() }, ot = () => { frame.read(nt, !1, !0), frame.read(it, !1, !0), frame.update(st, !1, !0) }; scrollListeners.set(j, ot); const ft = getEventTarget(j); window.addEventListener("resize", ot, { passive: !0 }), j !== document.documentElement && resizeListeners.set(j, resize(j, ot)), ft.addEventListener("scroll", ot, { passive: !0 }) } const rt = scrollListeners.get(j); return frame.read(rt, !1, !0), () => { var nt; cancelFrame(rt); const it = onScrollHandlers.get(j); if (!it || (it.delete(tt), it.size)) return; const st = scrollListeners.get(j); scrollListeners.delete(j), st && (getEventTarget(j).removeEventListener("scroll", st), (nt = resizeListeners.get(j)) === null || nt === void 0 || nt(), window.removeEventListener("resize", st)) } } function refWarning(_, j) { warning(!!(!j || j.current)) } const createScrollMotionValues = () => ({ scrollX: motionValue(0), scrollY: motionValue(0), scrollXProgress: motionValue(0), scrollYProgress: motionValue(0) }); function useScroll({ container: _, target: j, layoutEffect: $ = !0, ..._e } = {}) { const et = useConstant(createScrollMotionValues); return ($ ? useIsomorphicLayoutEffect : reactExports.useEffect)(() => (refWarning("target", j), refWarning("container", _), scrollInfo(({ x: rt, y: nt }) => { et.scrollX.set(rt.current), et.scrollXProgress.set(rt.progress), et.scrollY.set(nt.current), et.scrollYProgress.set(nt.progress) }, { ..._e, container: (_ == null ? void 0 : _.current) || void 0, target: (j == null ? void 0 : j.current) || void 0 })), [_, j, JSON.stringify(_e.offset)]), et } var lottie$1 = { exports: {} }; (function (module, exports) {
  typeof navigator < "u" && function (_, j) { module.exports = j() }(commonjsGlobal, function () {
    var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function (j) { _useWebWorker = !!j }, getWebWorker = function () { return _useWebWorker }, setLocationHref = function (j) { locationHref = j }, getLocationHref = function () { return locationHref }; function createTag(_) { return document.createElement(_) } function extendPrototype(_, j) { var $, _e = _.length, et; for ($ = 0; $ < _e; $ += 1) { et = _[$].prototype; for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (j.prototype[tt] = et[tt]) } } function getDescriptor(_, j) { return Object.getOwnPropertyDescriptor(_, j) } function createProxyFunction(_) { function j() { } return j.prototype = _, j } var audioControllerFactory = function () { function _(j) { this.audios = [], this.audioFactory = j, this._volume = 1, this._isMuted = !1 } return _.prototype = { addAudio: function ($) { this.audios.push($) }, pause: function () { var $, _e = this.audios.length; for ($ = 0; $ < _e; $ += 1)this.audios[$].pause() }, resume: function () { var $, _e = this.audios.length; for ($ = 0; $ < _e; $ += 1)this.audios[$].resume() }, setRate: function ($) { var _e, et = this.audios.length; for (_e = 0; _e < et; _e += 1)this.audios[_e].setRate($) }, createAudio: function ($) { return this.audioFactory ? this.audioFactory($) : window.Howl ? new window.Howl({ src: [$] }) : { isPlaying: !1, play: function () { this.isPlaying = !0 }, seek: function () { this.isPlaying = !1 }, playing: function () { }, rate: function () { }, setVolume: function () { } } }, setAudioFactory: function ($) { this.audioFactory = $ }, setVolume: function ($) { this._volume = $, this._updateVolume() }, mute: function () { this._isMuted = !0, this._updateVolume() }, unmute: function () { this._isMuted = !1, this._updateVolume() }, getVolume: function () { return this._volume }, _updateVolume: function () { var $, _e = this.audios.length; for ($ = 0; $ < _e; $ += 1)this.audios[$].volume(this._volume * (this._isMuted ? 0 : 1)) } }, function () { return new _ } }(), createTypedArray = function () { function _($, _e) { var et = 0, tt = [], rt; switch ($) { case "int16": case "uint8c": rt = 1; break; default: rt = 1.1; break }for (et = 0; et < _e; et += 1)tt.push(rt); return tt } function j($, _e) { return $ === "float32" ? new Float32Array(_e) : $ === "int16" ? new Int16Array(_e) : $ === "uint8c" ? new Uint8ClampedArray(_e) : _($, _e) } return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? j : _ }(); function createSizedArray(_) { return Array.apply(null, { length: _ }) } function _typeof$6(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function ($) { return typeof $ } : _typeof$6 = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof$6(_) } var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {}; (function () { var _ = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], j, $ = _.length; for (j = 0; j < $; j += 1)BMMath[_[j]] = Math[_[j]] })(), BMMath.random = Math.random, BMMath.abs = function (_) { var j = _typeof$6(_); if (j === "object" && _.length) { var $ = createSizedArray(_.length), _e, et = _.length; for (_e = 0; _e < et; _e += 1)$[_e] = Math.abs(_[_e]); return $ } return Math.abs(_) }; var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = .5519; function styleDiv(_) { _.style.position = "absolute", _.style.top = 0, _.style.left = 0, _.style.display = "block", _.style.transformOrigin = "0 0", _.style.webkitTransformOrigin = "0 0", _.style.backfaceVisibility = "visible", _.style.webkitBackfaceVisibility = "visible", _.style.transformStyle = "preserve-3d", _.style.webkitTransformStyle = "preserve-3d", _.style.mozTransformStyle = "preserve-3d" } function BMEnterFrameEvent(_, j, $, _e) { this.type = _, this.currentTime = j, this.totalTime = $, this.direction = _e < 0 ? -1 : 1 } function BMCompleteEvent(_, j) { this.type = _, this.direction = j < 0 ? -1 : 1 } function BMCompleteLoopEvent(_, j, $, _e) { this.type = _, this.currentLoop = $, this.totalLoops = j, this.direction = _e < 0 ? -1 : 1 } function BMSegmentStartEvent(_, j, $) { this.type = _, this.firstFrame = j, this.totalFrames = $ } function BMDestroyEvent(_, j) { this.type = _, this.target = j } function BMRenderFrameErrorEvent(_, j) { this.type = "renderFrameError", this.nativeError = _, this.currentTime = j } function BMConfigErrorEvent(_) { this.type = "configError", this.nativeError = _ } var createElementID = function () { var _ = 0; return function () { return _ += 1, idPrefix$1 + "__lottie_element_" + _ } }(); function HSVtoRGB(_, j, $) { var _e, et, tt, rt, nt, it, st, ot; switch (rt = Math.floor(_ * 6), nt = _ * 6 - rt, it = $ * (1 - j), st = $ * (1 - nt * j), ot = $ * (1 - (1 - nt) * j), rt % 6) { case 0: _e = $, et = ot, tt = it; break; case 1: _e = st, et = $, tt = it; break; case 2: _e = it, et = $, tt = ot; break; case 3: _e = it, et = st, tt = $; break; case 4: _e = ot, et = it, tt = $; break; case 5: _e = $, et = it, tt = st; break }return [_e, et, tt] } function RGBtoHSV(_, j, $) { var _e = Math.max(_, j, $), et = Math.min(_, j, $), tt = _e - et, rt, nt = _e === 0 ? 0 : tt / _e, it = _e / 255; switch (_e) { case et: rt = 0; break; case _: rt = j - $ + tt * (j < $ ? 6 : 0), rt /= 6 * tt; break; case j: rt = $ - _ + tt * 2, rt /= 6 * tt; break; case $: rt = _ - j + tt * 4, rt /= 6 * tt; break }return [rt, nt, it] } function addSaturationToRGB(_, j) { var $ = RGBtoHSV(_[0] * 255, _[1] * 255, _[2] * 255); return $[1] += j, $[1] > 1 ? $[1] = 1 : $[1] <= 0 && ($[1] = 0), HSVtoRGB($[0], $[1], $[2]) } function addBrightnessToRGB(_, j) { var $ = RGBtoHSV(_[0] * 255, _[1] * 255, _[2] * 255); return $[2] += j, $[2] > 1 ? $[2] = 1 : $[2] < 0 && ($[2] = 0), HSVtoRGB($[0], $[1], $[2]) } function addHueToRGB(_, j) { var $ = RGBtoHSV(_[0] * 255, _[1] * 255, _[2] * 255); return $[0] += j / 360, $[0] > 1 ? $[0] -= 1 : $[0] < 0 && ($[0] += 1), HSVtoRGB($[0], $[1], $[2]) } var rgbToHex = function () { var _ = [], j, $; for (j = 0; j < 256; j += 1)$ = j.toString(16), _[j] = $.length === 1 ? "0" + $ : $; return function (_e, et, tt) { return _e < 0 && (_e = 0), et < 0 && (et = 0), tt < 0 && (tt = 0), "#" + _[_e] + _[et] + _[tt] } }(), setSubframeEnabled = function (j) { subframeEnabled = !!j }, getSubframeEnabled = function () { return subframeEnabled }, setExpressionsPlugin = function (j) { expressionsPlugin = j }, getExpressionsPlugin = function () { return expressionsPlugin }, setExpressionInterfaces = function (j) { expressionsInterfaces = j }, getExpressionInterfaces = function () { return expressionsInterfaces }, setDefaultCurveSegments = function (j) { defaultCurveSegments = j }, getDefaultCurveSegments = function () { return defaultCurveSegments }, setIdPrefix = function (j) { idPrefix$1 = j }; function createNS(_) { return document.createElementNS(svgNS, _) } function _typeof$5(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function ($) { return typeof $ } : _typeof$5 = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof$5(_) } var dataManager = function () { var _ = 1, j = [], $, _e, et = { onmessage: function () { }, postMessage: function (dt) { $({ data: dt }) } }, tt = { postMessage: function (dt) { et.onmessage({ data: dt }) } }; function rt(at) { if (window.Worker && window.Blob && getWebWorker()) { var dt = new Blob(["var _workerSelf = self; self.onmessage = ", at.toString()], { type: "text/javascript" }), pt = URL.createObjectURL(dt); return new Worker(pt) } return $ = at, et } function nt() { _e || (_e = rt(function (dt) { function pt() { function xt(At, Pt) { var kt, vt, Et = At.length, Ct, wt, Tt, jt; for (vt = 0; vt < Et; vt += 1)if (kt = At[vt], "ks" in kt && !kt.completed) { if (kt.completed = !0, kt.hasMask) { var Ft = kt.masksProperties; for (wt = Ft.length, Ct = 0; Ct < wt; Ct += 1)if (Ft[Ct].pt.k.i) yt(Ft[Ct].pt.k); else for (jt = Ft[Ct].pt.k.length, Tt = 0; Tt < jt; Tt += 1)Ft[Ct].pt.k[Tt].s && yt(Ft[Ct].pt.k[Tt].s[0]), Ft[Ct].pt.k[Tt].e && yt(Ft[Ct].pt.k[Tt].e[0]) } kt.ty === 0 ? (kt.layers = lt(kt.refId, Pt), xt(kt.layers, Pt)) : kt.ty === 4 ? mt(kt.shapes) : kt.ty === 5 && Lt(kt) } } function ct(At, Pt) { if (At) { var kt = 0, vt = At.length; for (kt = 0; kt < vt; kt += 1)At[kt].t === 1 && (At[kt].data.layers = lt(At[kt].data.refId, Pt), xt(At[kt].data.layers, Pt)) } } function ut(At, Pt) { for (var kt = 0, vt = Pt.length; kt < vt;) { if (Pt[kt].id === At) return Pt[kt]; kt += 1 } return null } function lt(At, Pt) { var kt = ut(At, Pt); return kt ? kt.layers.__used ? JSON.parse(JSON.stringify(kt.layers)) : (kt.layers.__used = !0, kt.layers) : null } function mt(At) { var Pt, kt = At.length, vt, Et; for (Pt = kt - 1; Pt >= 0; Pt -= 1)if (At[Pt].ty === "sh") if (At[Pt].ks.k.i) yt(At[Pt].ks.k); else for (Et = At[Pt].ks.k.length, vt = 0; vt < Et; vt += 1)At[Pt].ks.k[vt].s && yt(At[Pt].ks.k[vt].s[0]), At[Pt].ks.k[vt].e && yt(At[Pt].ks.k[vt].e[0]); else At[Pt].ty === "gr" && mt(At[Pt].it) } function yt(At) { var Pt, kt = At.i.length; for (Pt = 0; Pt < kt; Pt += 1)At.i[Pt][0] += At.v[Pt][0], At.i[Pt][1] += At.v[Pt][1], At.o[Pt][0] += At.v[Pt][0], At.o[Pt][1] += At.v[Pt][1] } function gt(At, Pt) { var kt = Pt ? Pt.split(".") : [100, 100, 100]; return At[0] > kt[0] ? !0 : kt[0] > At[0] ? !1 : At[1] > kt[1] ? !0 : kt[1] > At[1] ? !1 : At[2] > kt[2] ? !0 : kt[2] > At[2] ? !1 : null } var St = function () { var At = [4, 4, 14]; function Pt(vt) { var Et = vt.t.d; vt.t.d = { k: [{ s: Et, t: 0 }] } } function kt(vt) { var Et, Ct = vt.length; for (Et = 0; Et < Ct; Et += 1)vt[Et].ty === 5 && Pt(vt[Et]) } return function (vt) { if (gt(At, vt.v) && (kt(vt.layers), vt.assets)) { var Et, Ct = vt.assets.length; for (Et = 0; Et < Ct; Et += 1)vt.assets[Et].layers && kt(vt.assets[Et].layers) } } }(), bt = function () { var At = [4, 7, 99]; return function (Pt) { if (Pt.chars && !gt(At, Pt.v)) { var kt, vt = Pt.chars.length; for (kt = 0; kt < vt; kt += 1) { var Et = Pt.chars[kt]; Et.data && Et.data.shapes && (mt(Et.data.shapes), Et.data.ip = 0, Et.data.op = 99999, Et.data.st = 0, Et.data.sr = 1, Et.data.ks = { p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 } }, Pt.chars[kt].t || (Et.data.shapes.push({ ty: "no" }), Et.data.shapes[0].it.push({ p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 }, sk: { k: 0, a: 0 }, sa: { k: 0, a: 0 }, ty: "tr" }))) } } } }(), _t = function () { var At = [5, 7, 15]; function Pt(vt) { var Et = vt.t.p; typeof Et.a == "number" && (Et.a = { a: 0, k: Et.a }), typeof Et.p == "number" && (Et.p = { a: 0, k: Et.p }), typeof Et.r == "number" && (Et.r = { a: 0, k: Et.r }) } function kt(vt) { var Et, Ct = vt.length; for (Et = 0; Et < Ct; Et += 1)vt[Et].ty === 5 && Pt(vt[Et]) } return function (vt) { if (gt(At, vt.v) && (kt(vt.layers), vt.assets)) { var Et, Ct = vt.assets.length; for (Et = 0; Et < Ct; Et += 1)vt.assets[Et].layers && kt(vt.assets[Et].layers) } } }(), Mt = function () { var At = [4, 1, 9]; function Pt(vt) { var Et, Ct = vt.length, wt, Tt; for (Et = 0; Et < Ct; Et += 1)if (vt[Et].ty === "gr") Pt(vt[Et].it); else if (vt[Et].ty === "fl" || vt[Et].ty === "st") if (vt[Et].c.k && vt[Et].c.k[0].i) for (Tt = vt[Et].c.k.length, wt = 0; wt < Tt; wt += 1)vt[Et].c.k[wt].s && (vt[Et].c.k[wt].s[0] /= 255, vt[Et].c.k[wt].s[1] /= 255, vt[Et].c.k[wt].s[2] /= 255, vt[Et].c.k[wt].s[3] /= 255), vt[Et].c.k[wt].e && (vt[Et].c.k[wt].e[0] /= 255, vt[Et].c.k[wt].e[1] /= 255, vt[Et].c.k[wt].e[2] /= 255, vt[Et].c.k[wt].e[3] /= 255); else vt[Et].c.k[0] /= 255, vt[Et].c.k[1] /= 255, vt[Et].c.k[2] /= 255, vt[Et].c.k[3] /= 255 } function kt(vt) { var Et, Ct = vt.length; for (Et = 0; Et < Ct; Et += 1)vt[Et].ty === 4 && Pt(vt[Et].shapes) } return function (vt) { if (gt(At, vt.v) && (kt(vt.layers), vt.assets)) { var Et, Ct = vt.assets.length; for (Et = 0; Et < Ct; Et += 1)vt.assets[Et].layers && kt(vt.assets[Et].layers) } } }(), It = function () { var At = [4, 4, 18]; function Pt(vt) { var Et, Ct = vt.length, wt, Tt; for (Et = Ct - 1; Et >= 0; Et -= 1)if (vt[Et].ty === "sh") if (vt[Et].ks.k.i) vt[Et].ks.k.c = vt[Et].closed; else for (Tt = vt[Et].ks.k.length, wt = 0; wt < Tt; wt += 1)vt[Et].ks.k[wt].s && (vt[Et].ks.k[wt].s[0].c = vt[Et].closed), vt[Et].ks.k[wt].e && (vt[Et].ks.k[wt].e[0].c = vt[Et].closed); else vt[Et].ty === "gr" && Pt(vt[Et].it) } function kt(vt) { var Et, Ct, wt = vt.length, Tt, jt, Ft, Dt; for (Ct = 0; Ct < wt; Ct += 1) { if (Et = vt[Ct], Et.hasMask) { var Ot = Et.masksProperties; for (jt = Ot.length, Tt = 0; Tt < jt; Tt += 1)if (Ot[Tt].pt.k.i) Ot[Tt].pt.k.c = Ot[Tt].cl; else for (Dt = Ot[Tt].pt.k.length, Ft = 0; Ft < Dt; Ft += 1)Ot[Tt].pt.k[Ft].s && (Ot[Tt].pt.k[Ft].s[0].c = Ot[Tt].cl), Ot[Tt].pt.k[Ft].e && (Ot[Tt].pt.k[Ft].e[0].c = Ot[Tt].cl) } Et.ty === 4 && Pt(Et.shapes) } } return function (vt) { if (gt(At, vt.v) && (kt(vt.layers), vt.assets)) { var Et, Ct = vt.assets.length; for (Et = 0; Et < Ct; Et += 1)vt.assets[Et].layers && kt(vt.assets[Et].layers) } } }(); function Rt(At) { At.__complete || (Mt(At), St(At), bt(At), _t(At), It(At), xt(At.layers, At.assets), ct(At.chars, At.assets), At.__complete = !0) } function Lt(At) { At.t.a.length === 0 && "m" in At.t.p } var Vt = {}; return Vt.completeData = Rt, Vt.checkColors = Mt, Vt.checkChars = bt, Vt.checkPathProperties = _t, Vt.checkShapes = It, Vt.completeLayers = xt, Vt } if (tt.dataManager || (tt.dataManager = pt()), tt.assetLoader || (tt.assetLoader = function () { function xt(ut) { var lt = ut.getResponseHeader("content-type"); return lt && ut.responseType === "json" && lt.indexOf("json") !== -1 || ut.response && _typeof$5(ut.response) === "object" ? ut.response : ut.response && typeof ut.response == "string" ? JSON.parse(ut.response) : ut.responseText ? JSON.parse(ut.responseText) : null } function ct(ut, lt, mt, yt) { var gt, St = new XMLHttpRequest; try { St.responseType = "json" } catch { } St.onreadystatechange = function () { if (St.readyState === 4) if (St.status === 200) gt = xt(St), mt(gt); else try { gt = xt(St), mt(gt) } catch (bt) { yt && yt(bt) } }; try { St.open(["G", "E", "T"].join(""), ut, !0) } catch { St.open(["G", "E", "T"].join(""), lt + "/" + ut, !0) } St.send() } return { load: ct } }()), dt.data.type === "loadAnimation") tt.assetLoader.load(dt.data.path, dt.data.fullPath, function (xt) { tt.dataManager.completeData(xt), tt.postMessage({ id: dt.data.id, payload: xt, status: "success" }) }, function () { tt.postMessage({ id: dt.data.id, status: "error" }) }); else if (dt.data.type === "complete") { var ht = dt.data.animation; tt.dataManager.completeData(ht), tt.postMessage({ id: dt.data.id, payload: ht, status: "success" }) } else dt.data.type === "loadData" && tt.assetLoader.load(dt.data.path, dt.data.fullPath, function (xt) { tt.postMessage({ id: dt.data.id, payload: xt, status: "success" }) }, function () { tt.postMessage({ id: dt.data.id, status: "error" }) }) }), _e.onmessage = function (at) { var dt = at.data, pt = dt.id, ht = j[pt]; j[pt] = null, dt.status === "success" ? ht.onComplete(dt.payload) : ht.onError && ht.onError() }) } function it(at, dt) { _ += 1; var pt = "processId_" + _; return j[pt] = { onComplete: at, onError: dt }, pt } function st(at, dt, pt) { nt(); var ht = it(dt, pt); _e.postMessage({ type: "loadAnimation", path: at, fullPath: window.location.origin + window.location.pathname, id: ht }) } function ot(at, dt, pt) { nt(); var ht = it(dt, pt); _e.postMessage({ type: "loadData", path: at, fullPath: window.location.origin + window.location.pathname, id: ht }) } function ft(at, dt, pt) { nt(); var ht = it(dt, pt); _e.postMessage({ type: "complete", animation: at, id: ht }) } return { loadAnimation: st, loadData: ot, completeAnimation: ft } }(), ImagePreloader = function () { var _ = function () { var ct = createTag("canvas"); ct.width = 1, ct.height = 1; var ut = ct.getContext("2d"); return ut.fillStyle = "rgba(0,0,0,0)", ut.fillRect(0, 0, 1, 1), ct }(); function j() { this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function $() { this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function _e(ct, ut, lt) { var mt = ""; if (ct.e) mt = ct.p; else if (ut) { var yt = ct.p; yt.indexOf("images/") !== -1 && (yt = yt.split("/")[1]), mt = ut + yt } else mt = lt, mt += ct.u ? ct.u : "", mt += ct.p; return mt } function et(ct) { var ut = 0, lt = setInterval((function () { var mt = ct.getBBox(); (mt.width || ut > 500) && (this._imageLoaded(), clearInterval(lt)), ut += 1 }).bind(this), 50) } function tt(ct) { var ut = _e(ct, this.assetsPath, this.path), lt = createNS("image"); isSafari ? this.testImageLoaded(lt) : lt.addEventListener("load", this._imageLoaded, !1), lt.addEventListener("error", (function () { mt.img = _, this._imageLoaded() }).bind(this), !1), lt.setAttributeNS("http://www.w3.org/1999/xlink", "href", ut), this._elementHelper.append ? this._elementHelper.append(lt) : this._elementHelper.appendChild(lt); var mt = { img: lt, assetData: ct }; return mt } function rt(ct) { var ut = _e(ct, this.assetsPath, this.path), lt = createTag("img"); lt.crossOrigin = "anonymous", lt.addEventListener("load", this._imageLoaded, !1), lt.addEventListener("error", (function () { mt.img = _, this._imageLoaded() }).bind(this), !1), lt.src = ut; var mt = { img: lt, assetData: ct }; return mt } function nt(ct) { var ut = { assetData: ct }, lt = _e(ct, this.assetsPath, this.path); return dataManager.loadData(lt, (function (mt) { ut.img = mt, this._footageLoaded() }).bind(this), (function () { ut.img = {}, this._footageLoaded() }).bind(this)), ut } function it(ct, ut) { this.imagesLoadedCb = ut; var lt, mt = ct.length; for (lt = 0; lt < mt; lt += 1)ct[lt].layers || (!ct[lt].t || ct[lt].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(ct[lt]))) : ct[lt].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(ct[lt])))) } function st(ct) { this.path = ct || "" } function ot(ct) { this.assetsPath = ct || "" } function ft(ct) { for (var ut = 0, lt = this.images.length; ut < lt;) { if (this.images[ut].assetData === ct) return this.images[ut].img; ut += 1 } return null } function at() { this.imagesLoadedCb = null, this.images.length = 0 } function dt() { return this.totalImages === this.loadedAssets } function pt() { return this.totalFootages === this.loadedFootagesCount } function ht(ct, ut) { ct === "svg" ? (this._elementHelper = ut, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this) } function xt() { this._imageLoaded = j.bind(this), this._footageLoaded = $.bind(this), this.testImageLoaded = et.bind(this), this.createFootageData = nt.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [] } return xt.prototype = { loadAssets: it, setAssetsPath: ot, setPath: st, loadedImages: dt, loadedFootages: pt, destroy: at, getAsset: ft, createImgData: rt, createImageData: tt, imageLoaded: j, footageLoaded: $, setCacheType: ht }, xt }(); function BaseEvent() { } BaseEvent.prototype = { triggerEvent: function (j, $) { if (this._cbs[j]) for (var _e = this._cbs[j], et = 0; et < _e.length; et += 1)_e[et]($) }, addEventListener: function (j, $) { return this._cbs[j] || (this._cbs[j] = []), this._cbs[j].push($), (function () { this.removeEventListener(j, $) }).bind(this) }, removeEventListener: function (j, $) { if (!$) this._cbs[j] = null; else if (this._cbs[j]) { for (var _e = 0, et = this._cbs[j].length; _e < et;)this._cbs[j][_e] === $ && (this._cbs[j].splice(_e, 1), _e -= 1, et -= 1), _e += 1; this._cbs[j].length || (this._cbs[j] = null) } } }; var markerParser = function () {
      function _(j) {
        for (var $ = j.split(`\r
`), _e = {}, et, tt = 0, rt = 0; rt < $.length; rt += 1)et = $[rt].split(":"), et.length === 2 && (_e[et[0]] = et[1].trim(), tt += 1); if (tt === 0) throw new Error; return _e
      } return function (j) { for (var $ = [], _e = 0; _e < j.length; _e += 1) { var et = j[_e], tt = { time: et.tm, duration: et.dr }; try { tt.payload = JSON.parse(j[_e].cm) } catch { try { tt.payload = _(j[_e].cm) } catch { tt.payload = { name: j[_e].cm } } } $.push(tt) } return $ }
    }(), ProjectInterface = function () { function _(j) { this.compositions.push(j) } return function () { function j($) { for (var _e = 0, et = this.compositions.length; _e < et;) { if (this.compositions[_e].data && this.compositions[_e].data.nm === $) return this.compositions[_e].prepareFrame && this.compositions[_e].data.xt && this.compositions[_e].prepareFrame(this.currentFrame), this.compositions[_e].compInterface; _e += 1 } return null } return j.compositions = [], j.currentFrame = 0, j.registerComposition = _, j } }(), renderers = {}, registerRenderer = function (j, $) { renderers[j] = $ }; function getRenderer(_) { return renderers[_] } function getRegisteredRenderer() { if (renderers.canvas) return "canvas"; for (var _ in renderers) if (renderers[_]) return _; return "" } function _typeof$4(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function ($) { return typeof $ } : _typeof$4 = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof$4(_) } var AnimationItem = function () { this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin() }; extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (_) { (_.wrapper || _.container) && (this.wrapper = _.wrapper || _.container); var j = "svg"; _.animType ? j = _.animType : _.renderer && (j = _.renderer); var $ = getRenderer(j); this.renderer = new $(this, _.rendererSettings), this.imagePreloader.setCacheType(j, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = j, _.loop === "" || _.loop === null || _.loop === void 0 || _.loop === !0 ? this.loop = !0 : _.loop === !1 ? this.loop = !1 : this.loop = parseInt(_.loop, 10), this.autoplay = "autoplay" in _ ? _.autoplay : !0, this.name = _.name ? _.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(_, "autoloadSegments") ? _.autoloadSegments : !0, this.assetsPath = _.assetsPath, this.initialSegment = _.initialSegment, _.audioFactory && this.audioController.setAudioFactory(_.audioFactory), _.animationData ? this.setupAnimation(_.animationData) : _.path && (_.path.lastIndexOf("\\") !== -1 ? this.path = _.path.substr(0, _.path.lastIndexOf("\\") + 1) : this.path = _.path.substr(0, _.path.lastIndexOf("/") + 1), this.fileName = _.path.substr(_.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(_.path, this.configAnimation, this.onSetupError)) }, AnimationItem.prototype.onSetupError = function () { this.trigger("data_failed") }, AnimationItem.prototype.setupAnimation = function (_) { dataManager.completeAnimation(_, this.configAnimation) }, AnimationItem.prototype.setData = function (_, j) { j && _typeof$4(j) !== "object" && (j = JSON.parse(j)); var $ = { wrapper: _, animationData: j }, _e = _.attributes; $.path = _e.getNamedItem("data-animation-path") ? _e.getNamedItem("data-animation-path").value : _e.getNamedItem("data-bm-path") ? _e.getNamedItem("data-bm-path").value : _e.getNamedItem("bm-path") ? _e.getNamedItem("bm-path").value : "", $.animType = _e.getNamedItem("data-anim-type") ? _e.getNamedItem("data-anim-type").value : _e.getNamedItem("data-bm-type") ? _e.getNamedItem("data-bm-type").value : _e.getNamedItem("bm-type") ? _e.getNamedItem("bm-type").value : _e.getNamedItem("data-bm-renderer") ? _e.getNamedItem("data-bm-renderer").value : _e.getNamedItem("bm-renderer") ? _e.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas"; var et = _e.getNamedItem("data-anim-loop") ? _e.getNamedItem("data-anim-loop").value : _e.getNamedItem("data-bm-loop") ? _e.getNamedItem("data-bm-loop").value : _e.getNamedItem("bm-loop") ? _e.getNamedItem("bm-loop").value : ""; et === "false" ? $.loop = !1 : et === "true" ? $.loop = !0 : et !== "" && ($.loop = parseInt(et, 10)); var tt = _e.getNamedItem("data-anim-autoplay") ? _e.getNamedItem("data-anim-autoplay").value : _e.getNamedItem("data-bm-autoplay") ? _e.getNamedItem("data-bm-autoplay").value : _e.getNamedItem("bm-autoplay") ? _e.getNamedItem("bm-autoplay").value : !0; $.autoplay = tt !== "false", $.name = _e.getNamedItem("data-name") ? _e.getNamedItem("data-name").value : _e.getNamedItem("data-bm-name") ? _e.getNamedItem("data-bm-name").value : _e.getNamedItem("bm-name") ? _e.getNamedItem("bm-name").value : ""; var rt = _e.getNamedItem("data-anim-prerender") ? _e.getNamedItem("data-anim-prerender").value : _e.getNamedItem("data-bm-prerender") ? _e.getNamedItem("data-bm-prerender").value : _e.getNamedItem("bm-prerender") ? _e.getNamedItem("bm-prerender").value : ""; rt === "false" && ($.prerender = !1), $.path ? this.setParams($) : this.trigger("destroy") }, AnimationItem.prototype.includeLayers = function (_) { _.op > this.animationData.op && (this.animationData.op = _.op, this.totalFrames = Math.floor(_.op - this.animationData.ip)); var j = this.animationData.layers, $, _e = j.length, et = _.layers, tt, rt = et.length; for (tt = 0; tt < rt; tt += 1)for ($ = 0; $ < _e;) { if (j[$].id === et[tt].id) { j[$] = et[tt]; break } $ += 1 } if ((_.chars || _.fonts) && (this.renderer.globalData.fontManager.addChars(_.chars), this.renderer.globalData.fontManager.addFonts(_.fonts, this.renderer.globalData.defs)), _.assets) for (_e = _.assets.length, $ = 0; $ < _e; $ += 1)this.animationData.assets.push(_.assets[$]); this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete) }, AnimationItem.prototype.onSegmentComplete = function (_) { this.animationData = _; var j = getExpressionsPlugin(); j && j.initExpressions(this), this.loadNextSegment() }, AnimationItem.prototype.loadNextSegment = function () { var _ = this.animationData.segments; if (!_ || _.length === 0 || !this.autoloadSegments) { this.trigger("data_ready"), this.timeCompleted = this.totalFrames; return } var j = _.shift(); this.timeCompleted = j.time * this.frameRate; var $ = this.path + this.fileName + "_" + this.segmentPos + ".json"; this.segmentPos += 1, dataManager.loadData($, this.includeLayers.bind(this), (function () { this.trigger("data_failed") }).bind(this)) }, AnimationItem.prototype.loadSegments = function () { var _ = this.animationData.segments; _ || (this.timeCompleted = this.totalFrames), this.loadNextSegment() }, AnimationItem.prototype.imagesLoaded = function () { this.trigger("loaded_images"), this.checkLoaded() }, AnimationItem.prototype.preloadImages = function () { this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this)) }, AnimationItem.prototype.configAnimation = function (_) { if (this.renderer) try { this.animationData = _, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(_), _.assets || (_.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(_.assets), this.markers = markerParser(_.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause() } catch (j) { this.triggerConfigError(j) } }, AnimationItem.prototype.waitForFontsLoaded = function () { this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20)) }, AnimationItem.prototype.checkLoaded = function () { if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) { this.isLoaded = !0; var _ = getExpressionsPlugin(); _ && _.initExpressions(this), this.renderer.initItems(), setTimeout((function () { this.trigger("DOMLoaded") }).bind(this), 0), this.gotoFrame(), this.autoplay && this.play() } }, AnimationItem.prototype.resize = function (_, j) { var $ = typeof _ == "number" ? _ : void 0, _e = typeof j == "number" ? j : void 0; this.renderer.updateContainerSize($, _e) }, AnimationItem.prototype.setSubframe = function (_) { this.isSubframeEnabled = !!_ }, AnimationItem.prototype.gotoFrame = function () { this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame") }, AnimationItem.prototype.renderFrame = function () { if (!(this.isLoaded === !1 || !this.renderer)) try { this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame) } catch (_) { this.triggerRenderFrameError(_) } }, AnimationItem.prototype.play = function (_) { _ && this.name !== _ || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active"))) }, AnimationItem.prototype.pause = function (_) { _ && this.name !== _ || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause()) }, AnimationItem.prototype.togglePause = function (_) { _ && this.name !== _ || (this.isPaused === !0 ? this.play() : this.pause()) }, AnimationItem.prototype.stop = function (_) { _ && this.name !== _ || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0)) }, AnimationItem.prototype.getMarkerData = function (_) { for (var j, $ = 0; $ < this.markers.length; $ += 1)if (j = this.markers[$], j.payload && j.payload.name === _) return j; return null }, AnimationItem.prototype.goToAndStop = function (_, j, $) { if (!($ && this.name !== $)) { var _e = Number(_); if (isNaN(_e)) { var et = this.getMarkerData(_); et && this.goToAndStop(et.time, !0) } else j ? this.setCurrentRawFrameValue(_) : this.setCurrentRawFrameValue(_ * this.frameModifier); this.pause() } }, AnimationItem.prototype.goToAndPlay = function (_, j, $) { if (!($ && this.name !== $)) { var _e = Number(_); if (isNaN(_e)) { var et = this.getMarkerData(_); et && (et.duration ? this.playSegments([et.time, et.time + et.duration], !0) : this.goToAndStop(et.time, !0)) } else this.goToAndStop(_e, j, $); this.play() } }, AnimationItem.prototype.advanceTime = function (_) { if (!(this.isPaused === !0 || this.isLoaded === !1)) { var j = this.currentRawFrame + _ * this.frameModifier, $ = !1; j >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(j > this.totalFrames ? j % this.totalFrames : 0) || ($ = !0, j = this.totalFrames - 1) : j >= this.totalFrames ? (this.playCount += 1, this.checkSegments(j % this.totalFrames) || (this.setCurrentRawFrameValue(j % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(j) : j < 0 ? this.checkSegments(j % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + j % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : ($ = !0, j = 0)) : this.setCurrentRawFrameValue(j), $ && (this.setCurrentRawFrameValue(j), this.pause(), this.trigger("complete")) } }, AnimationItem.prototype.adjustSegment = function (_, j) { this.playCount = 0, _[1] < _[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = _[0] - _[1], this.timeCompleted = this.totalFrames, this.firstFrame = _[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - j)) : _[1] > _[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = _[1] - _[0], this.timeCompleted = this.totalFrames, this.firstFrame = _[0], this.setCurrentRawFrameValue(.001 + j)), this.trigger("segmentStart") }, AnimationItem.prototype.setSegment = function (_, j) { var $ = -1; this.isPaused && (this.currentRawFrame + this.firstFrame < _ ? $ = _ : this.currentRawFrame + this.firstFrame > j && ($ = j - _)), this.firstFrame = _, this.totalFrames = j - _, this.timeCompleted = this.totalFrames, $ !== -1 && this.goToAndStop($, !0) }, AnimationItem.prototype.playSegments = function (_, j) { if (j && (this.segments.length = 0), _typeof$4(_[0]) === "object") { var $, _e = _.length; for ($ = 0; $ < _e; $ += 1)this.segments.push(_[$]) } else this.segments.push(_); this.segments.length && j && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play() }, AnimationItem.prototype.resetSegments = function (_) { this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), _ && this.checkSegments(0) }, AnimationItem.prototype.checkSegments = function (_) { return this.segments.length ? (this.adjustSegment(this.segments.shift(), _), !0) : !1 }, AnimationItem.prototype.destroy = function (_) { _ && this.name !== _ || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null) }, AnimationItem.prototype.setCurrentRawFrameValue = function (_) { this.currentRawFrame = _, this.gotoFrame() }, AnimationItem.prototype.setSpeed = function (_) { this.playSpeed = _, this.updaFrameModifier() }, AnimationItem.prototype.setDirection = function (_) { this.playDirection = _ < 0 ? -1 : 1, this.updaFrameModifier() }, AnimationItem.prototype.setLoop = function (_) { this.loop = _ }, AnimationItem.prototype.setVolume = function (_, j) { j && this.name !== j || this.audioController.setVolume(_) }, AnimationItem.prototype.getVolume = function () { return this.audioController.getVolume() }, AnimationItem.prototype.mute = function (_) { _ && this.name !== _ || this.audioController.mute() }, AnimationItem.prototype.unmute = function (_) { _ && this.name !== _ || this.audioController.unmute() }, AnimationItem.prototype.updaFrameModifier = function () { this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection) }, AnimationItem.prototype.getPath = function () { return this.path }, AnimationItem.prototype.getAssetsPath = function (_) { var j = ""; if (_.e) j = _.p; else if (this.assetsPath) { var $ = _.p; $.indexOf("images/") !== -1 && ($ = $.split("/")[1]), j = this.assetsPath + $ } else j = this.path, j += _.u ? _.u : "", j += _.p; return j }, AnimationItem.prototype.getAssetData = function (_) { for (var j = 0, $ = this.assets.length; j < $;) { if (_ === this.assets[j].id) return this.assets[j]; j += 1 } return null }, AnimationItem.prototype.hide = function () { this.renderer.hide() }, AnimationItem.prototype.show = function () { this.renderer.show() }, AnimationItem.prototype.getDuration = function (_) { return _ ? this.totalFrames : this.totalFrames / this.frameRate }, AnimationItem.prototype.updateDocumentData = function (_, j, $) { try { var _e = this.renderer.getElementByPath(_); _e.updateDocumentData(j, $) } catch { } }, AnimationItem.prototype.trigger = function (_) { if (this._cbs && this._cbs[_]) switch (_) { case "enterFrame": this.triggerEvent(_, new BMEnterFrameEvent(_, this.currentFrame, this.totalFrames, this.frameModifier)); break; case "drawnFrame": this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(_, this.drawnFrameEvent); break; case "loopComplete": this.triggerEvent(_, new BMCompleteLoopEvent(_, this.loop, this.playCount, this.frameMult)); break; case "complete": this.triggerEvent(_, new BMCompleteEvent(_, this.frameMult)); break; case "segmentStart": this.triggerEvent(_, new BMSegmentStartEvent(_, this.firstFrame, this.totalFrames)); break; case "destroy": this.triggerEvent(_, new BMDestroyEvent(_, this)); break; default: this.triggerEvent(_) }_ === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(_, this.currentFrame, this.totalFrames, this.frameMult)), _ === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(_, this.loop, this.playCount, this.frameMult)), _ === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(_, this.frameMult)), _ === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(_, this.firstFrame, this.totalFrames)), _ === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(_, this)) }, AnimationItem.prototype.triggerRenderFrameError = function (_) { var j = new BMRenderFrameErrorEvent(_, this.currentFrame); this.triggerEvent("error", j), this.onError && this.onError.call(this, j) }, AnimationItem.prototype.triggerConfigError = function (_) { var j = new BMConfigErrorEvent(_, this.currentFrame); this.triggerEvent("error", j), this.onError && this.onError.call(this, j) }; var animationManager = function () { var _ = {}, j = [], $ = 0, _e = 0, et = 0, tt = !0, rt = !1; function nt(Pt) { for (var kt = 0, vt = Pt.target; kt < _e;)j[kt].animation === vt && (j.splice(kt, 1), kt -= 1, _e -= 1, vt.isPaused || ft()), kt += 1 } function it(Pt, kt) { if (!Pt) return null; for (var vt = 0; vt < _e;) { if (j[vt].elem === Pt && j[vt].elem !== null) return j[vt].animation; vt += 1 } var Et = new AnimationItem; return at(Et, Pt), Et.setData(Pt, kt), Et } function st() { var Pt, kt = j.length, vt = []; for (Pt = 0; Pt < kt; Pt += 1)vt.push(j[Pt].animation); return vt } function ot() { et += 1, Mt() } function ft() { et -= 1 } function at(Pt, kt) { Pt.addEventListener("destroy", nt), Pt.addEventListener("_active", ot), Pt.addEventListener("_idle", ft), j.push({ elem: kt, animation: Pt }), _e += 1 } function dt(Pt) { var kt = new AnimationItem; return at(kt, null), kt.setParams(Pt), kt } function pt(Pt, kt) { var vt; for (vt = 0; vt < _e; vt += 1)j[vt].animation.setSpeed(Pt, kt) } function ht(Pt, kt) { var vt; for (vt = 0; vt < _e; vt += 1)j[vt].animation.setDirection(Pt, kt) } function xt(Pt) { var kt; for (kt = 0; kt < _e; kt += 1)j[kt].animation.play(Pt) } function ct(Pt) { var kt = Pt - $, vt; for (vt = 0; vt < _e; vt += 1)j[vt].animation.advanceTime(kt); $ = Pt, et && !rt ? window.requestAnimationFrame(ct) : tt = !0 } function ut(Pt) { $ = Pt, window.requestAnimationFrame(ct) } function lt(Pt) { var kt; for (kt = 0; kt < _e; kt += 1)j[kt].animation.pause(Pt) } function mt(Pt, kt, vt) { var Et; for (Et = 0; Et < _e; Et += 1)j[Et].animation.goToAndStop(Pt, kt, vt) } function yt(Pt) { var kt; for (kt = 0; kt < _e; kt += 1)j[kt].animation.stop(Pt) } function gt(Pt) { var kt; for (kt = 0; kt < _e; kt += 1)j[kt].animation.togglePause(Pt) } function St(Pt) { var kt; for (kt = _e - 1; kt >= 0; kt -= 1)j[kt].animation.destroy(Pt) } function bt(Pt, kt, vt) { var Et = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Ct, wt = Et.length; for (Ct = 0; Ct < wt; Ct += 1)vt && Et[Ct].setAttribute("data-bm-type", vt), it(Et[Ct], Pt); if (kt && wt === 0) { vt || (vt = "svg"); var Tt = document.getElementsByTagName("body")[0]; Tt.innerText = ""; var jt = createTag("div"); jt.style.width = "100%", jt.style.height = "100%", jt.setAttribute("data-bm-type", vt), Tt.appendChild(jt), it(jt, Pt) } } function _t() { var Pt; for (Pt = 0; Pt < _e; Pt += 1)j[Pt].animation.resize() } function Mt() { !rt && et && tt && (window.requestAnimationFrame(ut), tt = !1) } function It() { rt = !0 } function Rt() { rt = !1, Mt() } function Lt(Pt, kt) { var vt; for (vt = 0; vt < _e; vt += 1)j[vt].animation.setVolume(Pt, kt) } function Vt(Pt) { var kt; for (kt = 0; kt < _e; kt += 1)j[kt].animation.mute(Pt) } function At(Pt) { var kt; for (kt = 0; kt < _e; kt += 1)j[kt].animation.unmute(Pt) } return _.registerAnimation = it, _.loadAnimation = dt, _.setSpeed = pt, _.setDirection = ht, _.play = xt, _.pause = lt, _.stop = yt, _.togglePause = gt, _.searchAnimations = bt, _.resize = _t, _.goToAndStop = mt, _.destroy = St, _.freeze = It, _.unfreeze = Rt, _.setVolume = Lt, _.mute = Vt, _.unmute = At, _.getRegisteredAnimations = st, _ }(), BezierFactory = function () { var _ = {}; _.getBezierEasing = $; var j = {}; function $(ut, lt, mt, yt, gt) { var St = gt || ("bez_" + ut + "_" + lt + "_" + mt + "_" + yt).replace(/\./g, "p"); if (j[St]) return j[St]; var bt = new ct([ut, lt, mt, yt]); return j[St] = bt, bt } var _e = 4, et = .001, tt = 1e-7, rt = 10, nt = 11, it = 1 / (nt - 1), st = typeof Float32Array == "function"; function ot(ut, lt) { return 1 - 3 * lt + 3 * ut } function ft(ut, lt) { return 3 * lt - 6 * ut } function at(ut) { return 3 * ut } function dt(ut, lt, mt) { return ((ot(lt, mt) * ut + ft(lt, mt)) * ut + at(lt)) * ut } function pt(ut, lt, mt) { return 3 * ot(lt, mt) * ut * ut + 2 * ft(lt, mt) * ut + at(lt) } function ht(ut, lt, mt, yt, gt) { var St, bt, _t = 0; do bt = lt + (mt - lt) / 2, St = dt(bt, yt, gt) - ut, St > 0 ? mt = bt : lt = bt; while (Math.abs(St) > tt && ++_t < rt); return bt } function xt(ut, lt, mt, yt) { for (var gt = 0; gt < _e; ++gt) { var St = pt(lt, mt, yt); if (St === 0) return lt; var bt = dt(lt, mt, yt) - ut; lt -= bt / St } return lt } function ct(ut) { this._p = ut, this._mSampleValues = st ? new Float32Array(nt) : new Array(nt), this._precomputed = !1, this.get = this.get.bind(this) } return ct.prototype = { get: function (lt) { var mt = this._p[0], yt = this._p[1], gt = this._p[2], St = this._p[3]; return this._precomputed || this._precompute(), mt === yt && gt === St ? lt : lt === 0 ? 0 : lt === 1 ? 1 : dt(this._getTForX(lt), yt, St) }, _precompute: function () { var lt = this._p[0], mt = this._p[1], yt = this._p[2], gt = this._p[3]; this._precomputed = !0, (lt !== mt || yt !== gt) && this._calcSampleValues() }, _calcSampleValues: function () { for (var lt = this._p[0], mt = this._p[2], yt = 0; yt < nt; ++yt)this._mSampleValues[yt] = dt(yt * it, lt, mt) }, _getTForX: function (lt) { for (var mt = this._p[0], yt = this._p[2], gt = this._mSampleValues, St = 0, bt = 1, _t = nt - 1; bt !== _t && gt[bt] <= lt; ++bt)St += it; --bt; var Mt = (lt - gt[bt]) / (gt[bt + 1] - gt[bt]), It = St + Mt * it, Rt = pt(It, mt, yt); return Rt >= et ? xt(lt, It, mt, yt) : Rt === 0 ? It : ht(lt, St, St + it, mt, yt) } }, _ }(), pooling = function () { function _(j) { return j.concat(createSizedArray(j.length)) } return { double: _ } }(), poolFactory = function () { return function (_, j, $) { var _e = 0, et = _, tt = createSizedArray(et), rt = { newElement: nt, release: it }; function nt() { var st; return _e ? (_e -= 1, st = tt[_e]) : st = j(), st } function it(st) { _e === et && (tt = pooling.double(tt), et *= 2), $ && $(st), tt[_e] = st, _e += 1 } return rt } }(), bezierLengthPool = function () { function _() { return { addedLength: 0, percents: createTypedArray("float32", getDefaultCurveSegments()), lengths: createTypedArray("float32", getDefaultCurveSegments()) } } return poolFactory(8, _) }(), segmentsLengthPool = function () { function _() { return { lengths: [], totalLength: 0 } } function j($) { var _e, et = $.lengths.length; for (_e = 0; _e < et; _e += 1)bezierLengthPool.release($.lengths[_e]); $.lengths.length = 0 } return poolFactory(8, _, j) }(); function bezFunction() { var _ = Math; function j(at, dt, pt, ht, xt, ct) { var ut = at * ht + dt * xt + pt * ct - xt * ht - ct * at - pt * dt; return ut > -.001 && ut < .001 } function $(at, dt, pt, ht, xt, ct, ut, lt, mt) { if (pt === 0 && ct === 0 && mt === 0) return j(at, dt, ht, xt, ut, lt); var yt = _.sqrt(_.pow(ht - at, 2) + _.pow(xt - dt, 2) + _.pow(ct - pt, 2)), gt = _.sqrt(_.pow(ut - at, 2) + _.pow(lt - dt, 2) + _.pow(mt - pt, 2)), St = _.sqrt(_.pow(ut - ht, 2) + _.pow(lt - xt, 2) + _.pow(mt - ct, 2)), bt; return yt > gt ? yt > St ? bt = yt - gt - St : bt = St - gt - yt : St > gt ? bt = St - gt - yt : bt = gt - yt - St, bt > -1e-4 && bt < 1e-4 } var _e = function () { return function (at, dt, pt, ht) { var xt = getDefaultCurveSegments(), ct, ut, lt, mt, yt, gt = 0, St, bt = [], _t = [], Mt = bezierLengthPool.newElement(); for (lt = pt.length, ct = 0; ct < xt; ct += 1) { for (yt = ct / (xt - 1), St = 0, ut = 0; ut < lt; ut += 1)mt = bmPow(1 - yt, 3) * at[ut] + 3 * bmPow(1 - yt, 2) * yt * pt[ut] + 3 * (1 - yt) * bmPow(yt, 2) * ht[ut] + bmPow(yt, 3) * dt[ut], bt[ut] = mt, _t[ut] !== null && (St += bmPow(bt[ut] - _t[ut], 2)), _t[ut] = bt[ut]; St && (St = bmSqrt(St), gt += St), Mt.percents[ct] = yt, Mt.lengths[ct] = gt } return Mt.addedLength = gt, Mt } }(); function et(at) { var dt = segmentsLengthPool.newElement(), pt = at.c, ht = at.v, xt = at.o, ct = at.i, ut, lt = at._length, mt = dt.lengths, yt = 0; for (ut = 0; ut < lt - 1; ut += 1)mt[ut] = _e(ht[ut], ht[ut + 1], xt[ut], ct[ut + 1]), yt += mt[ut].addedLength; return pt && lt && (mt[ut] = _e(ht[ut], ht[0], xt[ut], ct[0]), yt += mt[ut].addedLength), dt.totalLength = yt, dt } function tt(at) { this.segmentLength = 0, this.points = new Array(at) } function rt(at, dt) { this.partialLength = at, this.point = dt } var nt = function () { var at = {}; return function (dt, pt, ht, xt) { var ct = (dt[0] + "_" + dt[1] + "_" + pt[0] + "_" + pt[1] + "_" + ht[0] + "_" + ht[1] + "_" + xt[0] + "_" + xt[1]).replace(/\./g, "p"); if (!at[ct]) { var ut = getDefaultCurveSegments(), lt, mt, yt, gt, St, bt = 0, _t, Mt, It = null; dt.length === 2 && (dt[0] !== pt[0] || dt[1] !== pt[1]) && j(dt[0], dt[1], pt[0], pt[1], dt[0] + ht[0], dt[1] + ht[1]) && j(dt[0], dt[1], pt[0], pt[1], pt[0] + xt[0], pt[1] + xt[1]) && (ut = 2); var Rt = new tt(ut); for (yt = ht.length, lt = 0; lt < ut; lt += 1) { for (Mt = createSizedArray(yt), St = lt / (ut - 1), _t = 0, mt = 0; mt < yt; mt += 1)gt = bmPow(1 - St, 3) * dt[mt] + 3 * bmPow(1 - St, 2) * St * (dt[mt] + ht[mt]) + 3 * (1 - St) * bmPow(St, 2) * (pt[mt] + xt[mt]) + bmPow(St, 3) * pt[mt], Mt[mt] = gt, It !== null && (_t += bmPow(Mt[mt] - It[mt], 2)); _t = bmSqrt(_t), bt += _t, Rt.points[lt] = new rt(_t, Mt), It = Mt } Rt.segmentLength = bt, at[ct] = Rt } return at[ct] } }(); function it(at, dt) { var pt = dt.percents, ht = dt.lengths, xt = pt.length, ct = bmFloor((xt - 1) * at), ut = at * dt.addedLength, lt = 0; if (ct === xt - 1 || ct === 0 || ut === ht[ct]) return pt[ct]; for (var mt = ht[ct] > ut ? -1 : 1, yt = !0; yt;)if (ht[ct] <= ut && ht[ct + 1] > ut ? (lt = (ut - ht[ct]) / (ht[ct + 1] - ht[ct]), yt = !1) : ct += mt, ct < 0 || ct >= xt - 1) { if (ct === xt - 1) return pt[ct]; yt = !1 } return pt[ct] + (pt[ct + 1] - pt[ct]) * lt } function st(at, dt, pt, ht, xt, ct) { var ut = it(xt, ct), lt = 1 - ut, mt = _.round((lt * lt * lt * at[0] + (ut * lt * lt + lt * ut * lt + lt * lt * ut) * pt[0] + (ut * ut * lt + lt * ut * ut + ut * lt * ut) * ht[0] + ut * ut * ut * dt[0]) * 1e3) / 1e3, yt = _.round((lt * lt * lt * at[1] + (ut * lt * lt + lt * ut * lt + lt * lt * ut) * pt[1] + (ut * ut * lt + lt * ut * ut + ut * lt * ut) * ht[1] + ut * ut * ut * dt[1]) * 1e3) / 1e3; return [mt, yt] } var ot = createTypedArray("float32", 8); function ft(at, dt, pt, ht, xt, ct, ut) { xt < 0 ? xt = 0 : xt > 1 && (xt = 1); var lt = it(xt, ut); ct = ct > 1 ? 1 : ct; var mt = it(ct, ut), yt, gt = at.length, St = 1 - lt, bt = 1 - mt, _t = St * St * St, Mt = lt * St * St * 3, It = lt * lt * St * 3, Rt = lt * lt * lt, Lt = St * St * bt, Vt = lt * St * bt + St * lt * bt + St * St * mt, At = lt * lt * bt + St * lt * mt + lt * St * mt, Pt = lt * lt * mt, kt = St * bt * bt, vt = lt * bt * bt + St * mt * bt + St * bt * mt, Et = lt * mt * bt + St * mt * mt + lt * bt * mt, Ct = lt * mt * mt, wt = bt * bt * bt, Tt = mt * bt * bt + bt * mt * bt + bt * bt * mt, jt = mt * mt * bt + bt * mt * mt + mt * bt * mt, Ft = mt * mt * mt; for (yt = 0; yt < gt; yt += 1)ot[yt * 4] = _.round((_t * at[yt] + Mt * pt[yt] + It * ht[yt] + Rt * dt[yt]) * 1e3) / 1e3, ot[yt * 4 + 1] = _.round((Lt * at[yt] + Vt * pt[yt] + At * ht[yt] + Pt * dt[yt]) * 1e3) / 1e3, ot[yt * 4 + 2] = _.round((kt * at[yt] + vt * pt[yt] + Et * ht[yt] + Ct * dt[yt]) * 1e3) / 1e3, ot[yt * 4 + 3] = _.round((wt * at[yt] + Tt * pt[yt] + jt * ht[yt] + Ft * dt[yt]) * 1e3) / 1e3; return ot } return { getSegmentsLength: et, getNewSegment: ft, getPointInSegment: st, buildBezierData: nt, pointOnLine2D: j, pointOnLine3D: $ } } var bez = bezFunction(), initFrame = initialDefaultFrame, mathAbs = Math.abs; function interpolateValue(_, j) { var $ = this.offsetTime, _e; this.propType === "multidimensional" && (_e = createTypedArray("float32", this.pv.length)); for (var et = j.lastIndex, tt = et, rt = this.keyframes.length - 1, nt = !0, it, st, ot; nt;) { if (it = this.keyframes[tt], st = this.keyframes[tt + 1], tt === rt - 1 && _ >= st.t - $) { it.h && (it = st), et = 0; break } if (st.t - $ > _) { et = tt; break } tt < rt - 1 ? tt += 1 : (et = 0, nt = !1) } ot = this.keyframesMetadata[tt] || {}; var ft, at, dt, pt, ht, xt, ct = st.t - $, ut = it.t - $, lt; if (it.to) { ot.bezierData || (ot.bezierData = bez.buildBezierData(it.s, st.s || it.e, it.to, it.ti)); var mt = ot.bezierData; if (_ >= ct || _ < ut) { var yt = _ >= ct ? mt.points.length - 1 : 0; for (at = mt.points[yt].point.length, ft = 0; ft < at; ft += 1)_e[ft] = mt.points[yt].point[ft] } else { ot.__fnct ? xt = ot.__fnct : (xt = BezierFactory.getBezierEasing(it.o.x, it.o.y, it.i.x, it.i.y, it.n).get, ot.__fnct = xt), dt = xt((_ - ut) / (ct - ut)); var gt = mt.segmentLength * dt, St, bt = j.lastFrame < _ && j._lastKeyframeIndex === tt ? j._lastAddedLength : 0; for (ht = j.lastFrame < _ && j._lastKeyframeIndex === tt ? j._lastPoint : 0, nt = !0, pt = mt.points.length; nt;) { if (bt += mt.points[ht].partialLength, gt === 0 || dt === 0 || ht === mt.points.length - 1) { for (at = mt.points[ht].point.length, ft = 0; ft < at; ft += 1)_e[ft] = mt.points[ht].point[ft]; break } else if (gt >= bt && gt < bt + mt.points[ht + 1].partialLength) { for (St = (gt - bt) / mt.points[ht + 1].partialLength, at = mt.points[ht].point.length, ft = 0; ft < at; ft += 1)_e[ft] = mt.points[ht].point[ft] + (mt.points[ht + 1].point[ft] - mt.points[ht].point[ft]) * St; break } ht < pt - 1 ? ht += 1 : nt = !1 } j._lastPoint = ht, j._lastAddedLength = bt - mt.points[ht].partialLength, j._lastKeyframeIndex = tt } } else { var _t, Mt, It, Rt, Lt; if (rt = it.s.length, lt = st.s || it.e, this.sh && it.h !== 1) if (_ >= ct) _e[0] = lt[0], _e[1] = lt[1], _e[2] = lt[2]; else if (_ <= ut) _e[0] = it.s[0], _e[1] = it.s[1], _e[2] = it.s[2]; else { var Vt = createQuaternion(it.s), At = createQuaternion(lt), Pt = (_ - ut) / (ct - ut); quaternionToEuler(_e, slerp(Vt, At, Pt)) } else for (tt = 0; tt < rt; tt += 1)it.h !== 1 && (_ >= ct ? dt = 1 : _ < ut ? dt = 0 : (it.o.x.constructor === Array ? (ot.__fnct || (ot.__fnct = []), ot.__fnct[tt] ? xt = ot.__fnct[tt] : (_t = it.o.x[tt] === void 0 ? it.o.x[0] : it.o.x[tt], Mt = it.o.y[tt] === void 0 ? it.o.y[0] : it.o.y[tt], It = it.i.x[tt] === void 0 ? it.i.x[0] : it.i.x[tt], Rt = it.i.y[tt] === void 0 ? it.i.y[0] : it.i.y[tt], xt = BezierFactory.getBezierEasing(_t, Mt, It, Rt).get, ot.__fnct[tt] = xt)) : ot.__fnct ? xt = ot.__fnct : (_t = it.o.x, Mt = it.o.y, It = it.i.x, Rt = it.i.y, xt = BezierFactory.getBezierEasing(_t, Mt, It, Rt).get, it.keyframeMetadata = xt), dt = xt((_ - ut) / (ct - ut)))), lt = st.s || it.e, Lt = it.h === 1 ? it.s[tt] : it.s[tt] + (lt[tt] - it.s[tt]) * dt, this.propType === "multidimensional" ? _e[tt] = Lt : _e = Lt } return j.lastIndex = et, _e } function slerp(_, j, $) { var _e = [], et = _[0], tt = _[1], rt = _[2], nt = _[3], it = j[0], st = j[1], ot = j[2], ft = j[3], at, dt, pt, ht, xt; return dt = et * it + tt * st + rt * ot + nt * ft, dt < 0 && (dt = -dt, it = -it, st = -st, ot = -ot, ft = -ft), 1 - dt > 1e-6 ? (at = Math.acos(dt), pt = Math.sin(at), ht = Math.sin((1 - $) * at) / pt, xt = Math.sin($ * at) / pt) : (ht = 1 - $, xt = $), _e[0] = ht * et + xt * it, _e[1] = ht * tt + xt * st, _e[2] = ht * rt + xt * ot, _e[3] = ht * nt + xt * ft, _e } function quaternionToEuler(_, j) { var $ = j[0], _e = j[1], et = j[2], tt = j[3], rt = Math.atan2(2 * _e * tt - 2 * $ * et, 1 - 2 * _e * _e - 2 * et * et), nt = Math.asin(2 * $ * _e + 2 * et * tt), it = Math.atan2(2 * $ * tt - 2 * _e * et, 1 - 2 * $ * $ - 2 * et * et); _[0] = rt / degToRads, _[1] = nt / degToRads, _[2] = it / degToRads } function createQuaternion(_) { var j = _[0] * degToRads, $ = _[1] * degToRads, _e = _[2] * degToRads, et = Math.cos(j / 2), tt = Math.cos($ / 2), rt = Math.cos(_e / 2), nt = Math.sin(j / 2), it = Math.sin($ / 2), st = Math.sin(_e / 2), ot = et * tt * rt - nt * it * st, ft = nt * it * rt + et * tt * st, at = nt * tt * rt + et * it * st, dt = et * it * rt - nt * tt * st; return [ft, at, dt, ot] } function getValueAtCurrentTime() { var _ = this.comp.renderedFrame - this.offsetTime, j = this.keyframes[0].t - this.offsetTime, $ = this.keyframes[this.keyframes.length - 1].t - this.offsetTime; if (!(_ === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= $ && _ >= $ || this._caching.lastFrame < j && _ < j))) { this._caching.lastFrame >= _ && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0); var _e = this.interpolateValue(_, this._caching); this.pv = _e } return this._caching.lastFrame = _, this.pv } function setVValue(_) { var j; if (this.propType === "unidimensional") j = _ * this.mult, mathAbs(this.v - j) > 1e-5 && (this.v = j, this._mdf = !0); else for (var $ = 0, _e = this.v.length; $ < _e;)j = _[$] * this.mult, mathAbs(this.v[$] - j) > 1e-5 && (this.v[$] = j, this._mdf = !0), $ += 1 } function processEffectsSequence() { if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) { if (this.lock) { this.setVValue(this.pv); return } this.lock = !0, this._mdf = this._isFirstFrame; var _, j = this.effectsSequence.length, $ = this.kf ? this.pv : this.data.k; for (_ = 0; _ < j; _ += 1)$ = this.effectsSequence[_]($); this.setVValue($), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId } } function addEffect(_) { this.effectsSequence.push(_), this.container.addDynamicProperty(this) } function ValueProperty(_, j, $, _e) { this.propType = "unidimensional", this.mult = $ || 1, this.data = j, this.v = $ ? j.k * $ : j.k, this.pv = j.k, this._mdf = !1, this.elem = _, this.container = _e, this.comp = _.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect } function MultiDimensionalProperty(_, j, $, _e) { this.propType = "multidimensional", this.mult = $ || 1, this.data = j, this._mdf = !1, this.elem = _, this.container = _e, this.comp = _.comp, this.k = !1, this.kf = !1, this.frameId = -1; var et, tt = j.k.length; for (this.v = createTypedArray("float32", tt), this.pv = createTypedArray("float32", tt), this.vel = createTypedArray("float32", tt), et = 0; et < tt; et += 1)this.v[et] = j.k[et] * this.mult, this.pv[et] = j.k[et]; this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect } function KeyframedValueProperty(_, j, $, _e) { this.propType = "unidimensional", this.keyframes = j.k, this.keyframesMetadata = [], this.offsetTime = _.data.st, this.frameId = -1, this._caching = { lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1 }, this.k = !0, this.kf = !0, this.data = j, this.mult = $ || 1, this.elem = _, this.container = _e, this.comp = _.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect } function KeyframedMultidimensionalProperty(_, j, $, _e) { this.propType = "multidimensional"; var et, tt = j.k.length, rt, nt, it, st; for (et = 0; et < tt - 1; et += 1)j.k[et].to && j.k[et].s && j.k[et + 1] && j.k[et + 1].s && (rt = j.k[et].s, nt = j.k[et + 1].s, it = j.k[et].to, st = j.k[et].ti, (rt.length === 2 && !(rt[0] === nt[0] && rt[1] === nt[1]) && bez.pointOnLine2D(rt[0], rt[1], nt[0], nt[1], rt[0] + it[0], rt[1] + it[1]) && bez.pointOnLine2D(rt[0], rt[1], nt[0], nt[1], nt[0] + st[0], nt[1] + st[1]) || rt.length === 3 && !(rt[0] === nt[0] && rt[1] === nt[1] && rt[2] === nt[2]) && bez.pointOnLine3D(rt[0], rt[1], rt[2], nt[0], nt[1], nt[2], rt[0] + it[0], rt[1] + it[1], rt[2] + it[2]) && bez.pointOnLine3D(rt[0], rt[1], rt[2], nt[0], nt[1], nt[2], nt[0] + st[0], nt[1] + st[1], nt[2] + st[2])) && (j.k[et].to = null, j.k[et].ti = null), rt[0] === nt[0] && rt[1] === nt[1] && it[0] === 0 && it[1] === 0 && st[0] === 0 && st[1] === 0 && (rt.length === 2 || rt[2] === nt[2] && it[2] === 0 && st[2] === 0) && (j.k[et].to = null, j.k[et].ti = null)); this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = j, this.keyframes = j.k, this.keyframesMetadata = [], this.offsetTime = _.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = $ || 1, this.elem = _, this.container = _e, this.comp = _.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1; var ot = j.k[0].s.length; for (this.v = createTypedArray("float32", ot), this.pv = createTypedArray("float32", ot), et = 0; et < ot; et += 1)this.v[et] = initFrame, this.pv[et] = initFrame; this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray("float32", ot) }, this.addEffect = addEffect } var PropertyFactory = function () { function _($, _e, et, tt, rt) { _e.sid && (_e = $.globalData.slotManager.getProp(_e)); var nt; if (!_e.k.length) nt = new ValueProperty($, _e, tt, rt); else if (typeof _e.k[0] == "number") nt = new MultiDimensionalProperty($, _e, tt, rt); else switch (et) { case 0: nt = new KeyframedValueProperty($, _e, tt, rt); break; case 1: nt = new KeyframedMultidimensionalProperty($, _e, tt, rt); break }return nt.effectsSequence.length && rt.addDynamicProperty(nt), nt } var j = { getProp: _ }; return j }(); function DynamicPropertyContainer() { } DynamicPropertyContainer.prototype = { addDynamicProperty: function (j) { this.dynamicProperties.indexOf(j) === -1 && (this.dynamicProperties.push(j), this.container.addDynamicProperty(this), this._isAnimated = !0) }, iterateDynamicProperties: function () { this._mdf = !1; var j, $ = this.dynamicProperties.length; for (j = 0; j < $; j += 1)this.dynamicProperties[j].getValue(), this.dynamicProperties[j]._mdf && (this._mdf = !0) }, initDynamicPropertyContainer: function (j) { this.container = j, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1 } }; var pointPool = function () { function _() { return createTypedArray("float32", 2) } return poolFactory(8, _) }(); function ShapePath() { this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength) } ShapePath.prototype.setPathData = function (_, j) { this.c = _, this.setLength(j); for (var $ = 0; $ < j;)this.v[$] = pointPool.newElement(), this.o[$] = pointPool.newElement(), this.i[$] = pointPool.newElement(), $ += 1 }, ShapePath.prototype.setLength = function (_) { for (; this._maxLength < _;)this.doubleArrayLength(); this._length = _ }, ShapePath.prototype.doubleArrayLength = function () { this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2 }, ShapePath.prototype.setXYAt = function (_, j, $, _e, et) { var tt; switch (this._length = Math.max(this._length, _e + 1), this._length >= this._maxLength && this.doubleArrayLength(), $) { case "v": tt = this.v; break; case "i": tt = this.i; break; case "o": tt = this.o; break; default: tt = []; break }(!tt[_e] || tt[_e] && !et) && (tt[_e] = pointPool.newElement()), tt[_e][0] = _, tt[_e][1] = j }, ShapePath.prototype.setTripleAt = function (_, j, $, _e, et, tt, rt, nt) { this.setXYAt(_, j, "v", rt, nt), this.setXYAt($, _e, "o", rt, nt), this.setXYAt(et, tt, "i", rt, nt) }, ShapePath.prototype.reverse = function () { var _ = new ShapePath; _.setPathData(this.c, this._length); var j = this.v, $ = this.o, _e = this.i, et = 0; this.c && (_.setTripleAt(j[0][0], j[0][1], _e[0][0], _e[0][1], $[0][0], $[0][1], 0, !1), et = 1); var tt = this._length - 1, rt = this._length, nt; for (nt = et; nt < rt; nt += 1)_.setTripleAt(j[tt][0], j[tt][1], _e[tt][0], _e[tt][1], $[tt][0], $[tt][1], nt, !1), tt -= 1; return _ }, ShapePath.prototype.length = function () { return this._length }; var shapePool = function () { function _() { return new ShapePath } function j(et) { var tt = et._length, rt; for (rt = 0; rt < tt; rt += 1)pointPool.release(et.v[rt]), pointPool.release(et.i[rt]), pointPool.release(et.o[rt]), et.v[rt] = null, et.i[rt] = null, et.o[rt] = null; et._length = 0, et.c = !1 } function $(et) { var tt = _e.newElement(), rt, nt = et._length === void 0 ? et.v.length : et._length; for (tt.setLength(nt), tt.c = et.c, rt = 0; rt < nt; rt += 1)tt.setTripleAt(et.v[rt][0], et.v[rt][1], et.o[rt][0], et.o[rt][1], et.i[rt][0], et.i[rt][1], rt); return tt } var _e = poolFactory(4, _, j); return _e.clone = $, _e }(); function ShapeCollection() { this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength) } ShapeCollection.prototype.addShape = function (_) { this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = _, this._length += 1 }, ShapeCollection.prototype.releaseShapes = function () { var _; for (_ = 0; _ < this._length; _ += 1)shapePool.release(this.shapes[_]); this._length = 0 }; var shapeCollectionPool = function () { var _ = { newShapeCollection: et, release: tt }, j = 0, $ = 4, _e = createSizedArray($); function et() { var rt; return j ? (j -= 1, rt = _e[j]) : rt = new ShapeCollection, rt } function tt(rt) { var nt, it = rt._length; for (nt = 0; nt < it; nt += 1)shapePool.release(rt.shapes[nt]); rt._length = 0, j === $ && (_e = pooling.double(_e), $ *= 2), _e[j] = rt, j += 1 } return _ }(), ShapePropertyFactory = function () { var _ = -999999; function j(ct, ut, lt) { var mt = lt.lastIndex, yt, gt, St, bt, _t, Mt, It, Rt, Lt, Vt = this.keyframes; if (ct < Vt[0].t - this.offsetTime) yt = Vt[0].s[0], St = !0, mt = 0; else if (ct >= Vt[Vt.length - 1].t - this.offsetTime) yt = Vt[Vt.length - 1].s ? Vt[Vt.length - 1].s[0] : Vt[Vt.length - 2].e[0], St = !0; else { for (var At = mt, Pt = Vt.length - 1, kt = !0, vt, Et, Ct; kt && (vt = Vt[At], Et = Vt[At + 1], !(Et.t - this.offsetTime > ct));)At < Pt - 1 ? At += 1 : kt = !1; if (Ct = this.keyframesMetadata[At] || {}, St = vt.h === 1, mt = At, !St) { if (ct >= Et.t - this.offsetTime) Rt = 1; else if (ct < vt.t - this.offsetTime) Rt = 0; else { var wt; Ct.__fnct ? wt = Ct.__fnct : (wt = BezierFactory.getBezierEasing(vt.o.x, vt.o.y, vt.i.x, vt.i.y).get, Ct.__fnct = wt), Rt = wt((ct - (vt.t - this.offsetTime)) / (Et.t - this.offsetTime - (vt.t - this.offsetTime))) } gt = Et.s ? Et.s[0] : vt.e[0] } yt = vt.s[0] } for (Mt = ut._length, It = yt.i[0].length, lt.lastIndex = mt, bt = 0; bt < Mt; bt += 1)for (_t = 0; _t < It; _t += 1)Lt = St ? yt.i[bt][_t] : yt.i[bt][_t] + (gt.i[bt][_t] - yt.i[bt][_t]) * Rt, ut.i[bt][_t] = Lt, Lt = St ? yt.o[bt][_t] : yt.o[bt][_t] + (gt.o[bt][_t] - yt.o[bt][_t]) * Rt, ut.o[bt][_t] = Lt, Lt = St ? yt.v[bt][_t] : yt.v[bt][_t] + (gt.v[bt][_t] - yt.v[bt][_t]) * Rt, ut.v[bt][_t] = Lt } function $() { var ct = this.comp.renderedFrame - this.offsetTime, ut = this.keyframes[0].t - this.offsetTime, lt = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, mt = this._caching.lastFrame; return mt !== _ && (mt < ut && ct < ut || mt > lt && ct > lt) || (this._caching.lastIndex = mt < ct ? this._caching.lastIndex : 0, this.interpolateShape(ct, this.pv, this._caching)), this._caching.lastFrame = ct, this.pv } function _e() { this.paths = this.localShapeCollection } function et(ct, ut) { if (ct._length !== ut._length || ct.c !== ut.c) return !1; var lt, mt = ct._length; for (lt = 0; lt < mt; lt += 1)if (ct.v[lt][0] !== ut.v[lt][0] || ct.v[lt][1] !== ut.v[lt][1] || ct.o[lt][0] !== ut.o[lt][0] || ct.o[lt][1] !== ut.o[lt][1] || ct.i[lt][0] !== ut.i[lt][0] || ct.i[lt][1] !== ut.i[lt][1]) return !1; return !0 } function tt(ct) { et(this.v, ct) || (this.v = shapePool.clone(ct), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection) } function rt() { if (this.elem.globalData.frameId !== this.frameId) { if (!this.effectsSequence.length) { this._mdf = !1; return } if (this.lock) { this.setVValue(this.pv); return } this.lock = !0, this._mdf = !1; var ct; this.kf ? ct = this.pv : this.data.ks ? ct = this.data.ks.k : ct = this.data.pt.k; var ut, lt = this.effectsSequence.length; for (ut = 0; ut < lt; ut += 1)ct = this.effectsSequence[ut](ct); this.setVValue(ct), this.lock = !1, this.frameId = this.elem.globalData.frameId } } function nt(ct, ut, lt) { this.propType = "shape", this.comp = ct.comp, this.container = ct, this.elem = ct, this.data = ut, this.k = !1, this.kf = !1, this._mdf = !1; var mt = lt === 3 ? ut.pt.k : ut.ks.k; this.v = shapePool.clone(mt), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = _e, this.effectsSequence = [] } function it(ct) { this.effectsSequence.push(ct), this.container.addDynamicProperty(this) } nt.prototype.interpolateShape = j, nt.prototype.getValue = rt, nt.prototype.setVValue = tt, nt.prototype.addEffect = it; function st(ct, ut, lt) { this.propType = "shape", this.comp = ct.comp, this.elem = ct, this.container = ct, this.offsetTime = ct.data.st, this.keyframes = lt === 3 ? ut.pt.k : ut.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0; var mt = this.keyframes[0].s[0].i.length; this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, mt), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = _, this.reset = _e, this._caching = { lastFrame: _, lastIndex: 0 }, this.effectsSequence = [$.bind(this)] } st.prototype.getValue = rt, st.prototype.interpolateShape = j, st.prototype.setVValue = tt, st.prototype.addEffect = it; var ot = function () { var ct = roundCorner; function ut(lt, mt) { this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = mt.d, this.elem = lt, this.comp = lt.comp, this.frameId = -1, this.initDynamicPropertyContainer(lt), this.p = PropertyFactory.getProp(lt, mt.p, 1, 0, this), this.s = PropertyFactory.getProp(lt, mt.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath()) } return ut.prototype = { reset: _e, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath()) }, convertEllToPath: function () { var mt = this.p.v[0], yt = this.p.v[1], gt = this.s.v[0] / 2, St = this.s.v[1] / 2, bt = this.d !== 3, _t = this.v; _t.v[0][0] = mt, _t.v[0][1] = yt - St, _t.v[1][0] = bt ? mt + gt : mt - gt, _t.v[1][1] = yt, _t.v[2][0] = mt, _t.v[2][1] = yt + St, _t.v[3][0] = bt ? mt - gt : mt + gt, _t.v[3][1] = yt, _t.i[0][0] = bt ? mt - gt * ct : mt + gt * ct, _t.i[0][1] = yt - St, _t.i[1][0] = bt ? mt + gt : mt - gt, _t.i[1][1] = yt - St * ct, _t.i[2][0] = bt ? mt + gt * ct : mt - gt * ct, _t.i[2][1] = yt + St, _t.i[3][0] = bt ? mt - gt : mt + gt, _t.i[3][1] = yt + St * ct, _t.o[0][0] = bt ? mt + gt * ct : mt - gt * ct, _t.o[0][1] = yt - St, _t.o[1][0] = bt ? mt + gt : mt - gt, _t.o[1][1] = yt + St * ct, _t.o[2][0] = bt ? mt - gt * ct : mt + gt * ct, _t.o[2][1] = yt + St, _t.o[3][0] = bt ? mt - gt : mt + gt, _t.o[3][1] = yt - St * ct } }, extendPrototype([DynamicPropertyContainer], ut), ut }(), ft = function () { function ct(ut, lt) { this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = ut, this.comp = ut.comp, this.data = lt, this.frameId = -1, this.d = lt.d, this.initDynamicPropertyContainer(ut), lt.sy === 1 ? (this.ir = PropertyFactory.getProp(ut, lt.ir, 0, 0, this), this.is = PropertyFactory.getProp(ut, lt.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(ut, lt.pt, 0, 0, this), this.p = PropertyFactory.getProp(ut, lt.p, 1, 0, this), this.r = PropertyFactory.getProp(ut, lt.r, 0, degToRads, this), this.or = PropertyFactory.getProp(ut, lt.or, 0, 0, this), this.os = PropertyFactory.getProp(ut, lt.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath()) } return ct.prototype = { reset: _e, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath()) }, convertStarToPath: function () { var lt = Math.floor(this.pt.v) * 2, mt = Math.PI * 2 / lt, yt = !0, gt = this.or.v, St = this.ir.v, bt = this.os.v, _t = this.is.v, Mt = 2 * Math.PI * gt / (lt * 2), It = 2 * Math.PI * St / (lt * 2), Rt, Lt, Vt, At, Pt = -Math.PI / 2; Pt += this.r.v; var kt = this.data.d === 3 ? -1 : 1; for (this.v._length = 0, Rt = 0; Rt < lt; Rt += 1) { Lt = yt ? gt : St, Vt = yt ? bt : _t, At = yt ? Mt : It; var vt = Lt * Math.cos(Pt), Et = Lt * Math.sin(Pt), Ct = vt === 0 && Et === 0 ? 0 : Et / Math.sqrt(vt * vt + Et * Et), wt = vt === 0 && Et === 0 ? 0 : -vt / Math.sqrt(vt * vt + Et * Et); vt += +this.p.v[0], Et += +this.p.v[1], this.v.setTripleAt(vt, Et, vt - Ct * At * Vt * kt, Et - wt * At * Vt * kt, vt + Ct * At * Vt * kt, Et + wt * At * Vt * kt, Rt, !0), yt = !yt, Pt += mt * kt } }, convertPolygonToPath: function () { var lt = Math.floor(this.pt.v), mt = Math.PI * 2 / lt, yt = this.or.v, gt = this.os.v, St = 2 * Math.PI * yt / (lt * 4), bt, _t = -Math.PI * .5, Mt = this.data.d === 3 ? -1 : 1; for (_t += this.r.v, this.v._length = 0, bt = 0; bt < lt; bt += 1) { var It = yt * Math.cos(_t), Rt = yt * Math.sin(_t), Lt = It === 0 && Rt === 0 ? 0 : Rt / Math.sqrt(It * It + Rt * Rt), Vt = It === 0 && Rt === 0 ? 0 : -It / Math.sqrt(It * It + Rt * Rt); It += +this.p.v[0], Rt += +this.p.v[1], this.v.setTripleAt(It, Rt, It - Lt * St * gt * Mt, Rt - Vt * St * gt * Mt, It + Lt * St * gt * Mt, Rt + Vt * St * gt * Mt, bt, !0), _t += mt * Mt } this.paths.length = 0, this.paths[0] = this.v } }, extendPrototype([DynamicPropertyContainer], ct), ct }(), at = function () { function ct(ut, lt) { this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = ut, this.comp = ut.comp, this.frameId = -1, this.d = lt.d, this.initDynamicPropertyContainer(ut), this.p = PropertyFactory.getProp(ut, lt.p, 1, 0, this), this.s = PropertyFactory.getProp(ut, lt.s, 1, 0, this), this.r = PropertyFactory.getProp(ut, lt.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath()) } return ct.prototype = { convertRectToPath: function () { var lt = this.p.v[0], mt = this.p.v[1], yt = this.s.v[0] / 2, gt = this.s.v[1] / 2, St = bmMin(yt, gt, this.r.v), bt = St * (1 - roundCorner); this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(lt + yt, mt - gt + St, lt + yt, mt - gt + St, lt + yt, mt - gt + bt, 0, !0), this.v.setTripleAt(lt + yt, mt + gt - St, lt + yt, mt + gt - bt, lt + yt, mt + gt - St, 1, !0), St !== 0 ? (this.v.setTripleAt(lt + yt - St, mt + gt, lt + yt - St, mt + gt, lt + yt - bt, mt + gt, 2, !0), this.v.setTripleAt(lt - yt + St, mt + gt, lt - yt + bt, mt + gt, lt - yt + St, mt + gt, 3, !0), this.v.setTripleAt(lt - yt, mt + gt - St, lt - yt, mt + gt - St, lt - yt, mt + gt - bt, 4, !0), this.v.setTripleAt(lt - yt, mt - gt + St, lt - yt, mt - gt + bt, lt - yt, mt - gt + St, 5, !0), this.v.setTripleAt(lt - yt + St, mt - gt, lt - yt + St, mt - gt, lt - yt + bt, mt - gt, 6, !0), this.v.setTripleAt(lt + yt - St, mt - gt, lt + yt - bt, mt - gt, lt + yt - St, mt - gt, 7, !0)) : (this.v.setTripleAt(lt - yt, mt + gt, lt - yt + bt, mt + gt, lt - yt, mt + gt, 2), this.v.setTripleAt(lt - yt, mt - gt, lt - yt, mt - gt + bt, lt - yt, mt - gt, 3))) : (this.v.setTripleAt(lt + yt, mt - gt + St, lt + yt, mt - gt + bt, lt + yt, mt - gt + St, 0, !0), St !== 0 ? (this.v.setTripleAt(lt + yt - St, mt - gt, lt + yt - St, mt - gt, lt + yt - bt, mt - gt, 1, !0), this.v.setTripleAt(lt - yt + St, mt - gt, lt - yt + bt, mt - gt, lt - yt + St, mt - gt, 2, !0), this.v.setTripleAt(lt - yt, mt - gt + St, lt - yt, mt - gt + St, lt - yt, mt - gt + bt, 3, !0), this.v.setTripleAt(lt - yt, mt + gt - St, lt - yt, mt + gt - bt, lt - yt, mt + gt - St, 4, !0), this.v.setTripleAt(lt - yt + St, mt + gt, lt - yt + St, mt + gt, lt - yt + bt, mt + gt, 5, !0), this.v.setTripleAt(lt + yt - St, mt + gt, lt + yt - bt, mt + gt, lt + yt - St, mt + gt, 6, !0), this.v.setTripleAt(lt + yt, mt + gt - St, lt + yt, mt + gt - St, lt + yt, mt + gt - bt, 7, !0)) : (this.v.setTripleAt(lt - yt, mt - gt, lt - yt + bt, mt - gt, lt - yt, mt - gt, 1, !0), this.v.setTripleAt(lt - yt, mt + gt, lt - yt, mt + gt - bt, lt - yt, mt + gt, 2, !0), this.v.setTripleAt(lt + yt, mt + gt, lt + yt - bt, mt + gt, lt + yt, mt + gt, 3, !0))) }, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath()) }, reset: _e }, extendPrototype([DynamicPropertyContainer], ct), ct }(); function dt(ct, ut, lt) { var mt; if (lt === 3 || lt === 4) { var yt = lt === 3 ? ut.pt : ut.ks, gt = yt.k; gt.length ? mt = new st(ct, ut, lt) : mt = new nt(ct, ut, lt) } else lt === 5 ? mt = new at(ct, ut) : lt === 6 ? mt = new ot(ct, ut) : lt === 7 && (mt = new ft(ct, ut)); return mt.k && ct.addDynamicProperty(mt), mt } function pt() { return nt } function ht() { return st } var xt = {}; return xt.getShapeProp = dt, xt.getConstructorFunction = pt, xt.getKeyframedConstructorFunction = ht, xt }();/*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */var Matrix = function () { var _ = Math.cos, j = Math.sin, $ = Math.tan, _e = Math.round; function et() { return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this } function tt(vt) { if (vt === 0) return this; var Et = _(vt), Ct = j(vt); return this._t(Et, -Ct, 0, 0, Ct, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function rt(vt) { if (vt === 0) return this; var Et = _(vt), Ct = j(vt); return this._t(1, 0, 0, 0, 0, Et, -Ct, 0, 0, Ct, Et, 0, 0, 0, 0, 1) } function nt(vt) { if (vt === 0) return this; var Et = _(vt), Ct = j(vt); return this._t(Et, 0, Ct, 0, 0, 1, 0, 0, -Ct, 0, Et, 0, 0, 0, 0, 1) } function it(vt) { if (vt === 0) return this; var Et = _(vt), Ct = j(vt); return this._t(Et, -Ct, 0, 0, Ct, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function st(vt, Et) { return this._t(1, Et, vt, 1, 0, 0) } function ot(vt, Et) { return this.shear($(vt), $(Et)) } function ft(vt, Et) { var Ct = _(Et), wt = j(Et); return this._t(Ct, wt, 0, 0, -wt, Ct, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, $(vt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(Ct, -wt, 0, 0, wt, Ct, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function at(vt, Et, Ct) { return !Ct && Ct !== 0 && (Ct = 1), vt === 1 && Et === 1 && Ct === 1 ? this : this._t(vt, 0, 0, 0, 0, Et, 0, 0, 0, 0, Ct, 0, 0, 0, 0, 1) } function dt(vt, Et, Ct, wt, Tt, jt, Ft, Dt, Ot, Nt, Yt, Xt, Kt, Ht, qt, zt) { return this.props[0] = vt, this.props[1] = Et, this.props[2] = Ct, this.props[3] = wt, this.props[4] = Tt, this.props[5] = jt, this.props[6] = Ft, this.props[7] = Dt, this.props[8] = Ot, this.props[9] = Nt, this.props[10] = Yt, this.props[11] = Xt, this.props[12] = Kt, this.props[13] = Ht, this.props[14] = qt, this.props[15] = zt, this } function pt(vt, Et, Ct) { return Ct = Ct || 0, vt !== 0 || Et !== 0 || Ct !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vt, Et, Ct, 1) : this } function ht(vt, Et, Ct, wt, Tt, jt, Ft, Dt, Ot, Nt, Yt, Xt, Kt, Ht, qt, zt) { var $t = this.props; if (vt === 1 && Et === 0 && Ct === 0 && wt === 0 && Tt === 0 && jt === 1 && Ft === 0 && Dt === 0 && Ot === 0 && Nt === 0 && Yt === 1 && Xt === 0) return $t[12] = $t[12] * vt + $t[15] * Kt, $t[13] = $t[13] * jt + $t[15] * Ht, $t[14] = $t[14] * Yt + $t[15] * qt, $t[15] *= zt, this._identityCalculated = !1, this; var Jt = $t[0], er = $t[1], Qt = $t[2], Gt = $t[3], Bt = $t[4], Wt = $t[5], Ut = $t[6], Zt = $t[7], nr = $t[8], tr = $t[9], ir = $t[10], rr = $t[11], sr = $t[12], or = $t[13], ar = $t[14], lr = $t[15]; return $t[0] = Jt * vt + er * Tt + Qt * Ot + Gt * Kt, $t[1] = Jt * Et + er * jt + Qt * Nt + Gt * Ht, $t[2] = Jt * Ct + er * Ft + Qt * Yt + Gt * qt, $t[3] = Jt * wt + er * Dt + Qt * Xt + Gt * zt, $t[4] = Bt * vt + Wt * Tt + Ut * Ot + Zt * Kt, $t[5] = Bt * Et + Wt * jt + Ut * Nt + Zt * Ht, $t[6] = Bt * Ct + Wt * Ft + Ut * Yt + Zt * qt, $t[7] = Bt * wt + Wt * Dt + Ut * Xt + Zt * zt, $t[8] = nr * vt + tr * Tt + ir * Ot + rr * Kt, $t[9] = nr * Et + tr * jt + ir * Nt + rr * Ht, $t[10] = nr * Ct + tr * Ft + ir * Yt + rr * qt, $t[11] = nr * wt + tr * Dt + ir * Xt + rr * zt, $t[12] = sr * vt + or * Tt + ar * Ot + lr * Kt, $t[13] = sr * Et + or * jt + ar * Nt + lr * Ht, $t[14] = sr * Ct + or * Ft + ar * Yt + lr * qt, $t[15] = sr * wt + or * Dt + ar * Xt + lr * zt, this._identityCalculated = !1, this } function xt(vt) { var Et = vt.props; return this.transform(Et[0], Et[1], Et[2], Et[3], Et[4], Et[5], Et[6], Et[7], Et[8], Et[9], Et[10], Et[11], Et[12], Et[13], Et[14], Et[15]) } function ct() { return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity } function ut(vt) { for (var Et = 0; Et < 16;) { if (vt.props[Et] !== this.props[Et]) return !1; Et += 1 } return !0 } function lt(vt) { var Et; for (Et = 0; Et < 16; Et += 1)vt.props[Et] = this.props[Et]; return vt } function mt(vt) { var Et; for (Et = 0; Et < 16; Et += 1)this.props[Et] = vt[Et] } function yt(vt, Et, Ct) { return { x: vt * this.props[0] + Et * this.props[4] + Ct * this.props[8] + this.props[12], y: vt * this.props[1] + Et * this.props[5] + Ct * this.props[9] + this.props[13], z: vt * this.props[2] + Et * this.props[6] + Ct * this.props[10] + this.props[14] } } function gt(vt, Et, Ct) { return vt * this.props[0] + Et * this.props[4] + Ct * this.props[8] + this.props[12] } function St(vt, Et, Ct) { return vt * this.props[1] + Et * this.props[5] + Ct * this.props[9] + this.props[13] } function bt(vt, Et, Ct) { return vt * this.props[2] + Et * this.props[6] + Ct * this.props[10] + this.props[14] } function _t() { var vt = this.props[0] * this.props[5] - this.props[1] * this.props[4], Et = this.props[5] / vt, Ct = -this.props[1] / vt, wt = -this.props[4] / vt, Tt = this.props[0] / vt, jt = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / vt, Ft = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / vt, Dt = new Matrix; return Dt.props[0] = Et, Dt.props[1] = Ct, Dt.props[4] = wt, Dt.props[5] = Tt, Dt.props[12] = jt, Dt.props[13] = Ft, Dt } function Mt(vt) { var Et = this.getInverseMatrix(); return Et.applyToPointArray(vt[0], vt[1], vt[2] || 0) } function It(vt) { var Et, Ct = vt.length, wt = []; for (Et = 0; Et < Ct; Et += 1)wt[Et] = Mt(vt[Et]); return wt } function Rt(vt, Et, Ct) { var wt = createTypedArray("float32", 6); if (this.isIdentity()) wt[0] = vt[0], wt[1] = vt[1], wt[2] = Et[0], wt[3] = Et[1], wt[4] = Ct[0], wt[5] = Ct[1]; else { var Tt = this.props[0], jt = this.props[1], Ft = this.props[4], Dt = this.props[5], Ot = this.props[12], Nt = this.props[13]; wt[0] = vt[0] * Tt + vt[1] * Ft + Ot, wt[1] = vt[0] * jt + vt[1] * Dt + Nt, wt[2] = Et[0] * Tt + Et[1] * Ft + Ot, wt[3] = Et[0] * jt + Et[1] * Dt + Nt, wt[4] = Ct[0] * Tt + Ct[1] * Ft + Ot, wt[5] = Ct[0] * jt + Ct[1] * Dt + Nt } return wt } function Lt(vt, Et, Ct) { var wt; return this.isIdentity() ? wt = [vt, Et, Ct] : wt = [vt * this.props[0] + Et * this.props[4] + Ct * this.props[8] + this.props[12], vt * this.props[1] + Et * this.props[5] + Ct * this.props[9] + this.props[13], vt * this.props[2] + Et * this.props[6] + Ct * this.props[10] + this.props[14]], wt } function Vt(vt, Et) { if (this.isIdentity()) return vt + "," + Et; var Ct = this.props; return Math.round((vt * Ct[0] + Et * Ct[4] + Ct[12]) * 100) / 100 + "," + Math.round((vt * Ct[1] + Et * Ct[5] + Ct[13]) * 100) / 100 } function At() { for (var vt = 0, Et = this.props, Ct = "matrix3d(", wt = 1e4; vt < 16;)Ct += _e(Et[vt] * wt) / wt, Ct += vt === 15 ? ")" : ",", vt += 1; return Ct } function Pt(vt) { var Et = 1e4; return vt < 1e-6 && vt > 0 || vt > -1e-6 && vt < 0 ? _e(vt * Et) / Et : vt } function kt() { var vt = this.props, Et = Pt(vt[0]), Ct = Pt(vt[1]), wt = Pt(vt[4]), Tt = Pt(vt[5]), jt = Pt(vt[12]), Ft = Pt(vt[13]); return "matrix(" + Et + "," + Ct + "," + wt + "," + Tt + "," + jt + "," + Ft + ")" } return function () { this.reset = et, this.rotate = tt, this.rotateX = rt, this.rotateY = nt, this.rotateZ = it, this.skew = ot, this.skewFromAxis = ft, this.shear = st, this.scale = at, this.setTransform = dt, this.translate = pt, this.transform = ht, this.multiply = xt, this.applyToPoint = yt, this.applyToX = gt, this.applyToY = St, this.applyToZ = bt, this.applyToPointArray = Lt, this.applyToTriplePoints = Rt, this.applyToPointStringified = Vt, this.toCSS = At, this.to2dCSS = kt, this.clone = lt, this.cloneFromProps = mt, this.equals = ut, this.inversePoints = It, this.inversePoint = Mt, this.getInverseMatrix = _t, this._t = this.transform, this.isIdentity = ct, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset() } }(); function _typeof$3(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function ($) { return typeof $ } : _typeof$3 = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof$3(_) } var lottie = {}; function setLocation(_) { setLocationHref(_) } function searchAnimations() { animationManager.searchAnimations() } function setSubframeRendering(_) { setSubframeEnabled(_) } function setPrefix(_) { setIdPrefix(_) } function loadAnimation(_) { return animationManager.loadAnimation(_) } function setQuality(_) { if (typeof _ == "string") switch (_) { case "high": setDefaultCurveSegments(200); break; default: case "medium": setDefaultCurveSegments(50); break; case "low": setDefaultCurveSegments(10); break } else !isNaN(_) && _ > 1 && setDefaultCurveSegments(_) } function inBrowser() { return typeof navigator < "u" } function installPlugin(_, j) { _ === "expressions" && setExpressionsPlugin(j) } function getFactory(_) { switch (_) { case "propertyFactory": return PropertyFactory; case "shapePropertyFactory": return ShapePropertyFactory; case "matrix": return Matrix; default: return null } } lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2"; function checkReady() { document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations()) } function getQueryVariable(_) { for (var j = queryString.split("&"), $ = 0; $ < j.length; $ += 1) { var _e = j[$].split("="); if (decodeURIComponent(_e[0]) == _) return decodeURIComponent(_e[1]) } return null } var queryString = ""; { var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || { src: "" }; queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer") } var readyStateCheckInterval = setInterval(checkReady, 100); try { _typeof$3(exports) !== "object" && (window.bodymovin = lottie) } catch (_) { } var ShapeModifiers = function () { var _ = {}, j = {}; _.registerModifier = $, _.getModifier = _e; function $(et, tt) { j[et] || (j[et] = tt) } function _e(et, tt, rt) { return new j[et](tt, rt) } return _ }(); function ShapeModifier() { } ShapeModifier.prototype.initModifierProperties = function () { }, ShapeModifier.prototype.addShapeToModifier = function () { }, ShapeModifier.prototype.addShape = function (_) { if (!this.closed) { _.sh.container.addDynamicProperty(_.sh); var j = { shape: _.sh, data: _, localShapeCollection: shapeCollectionPool.newShapeCollection() }; this.shapes.push(j), this.addShapeToModifier(j), this._isAnimated && _.setAsAnimated() } }, ShapeModifier.prototype.init = function (_, j) { this.shapes = [], this.elem = _, this.initDynamicPropertyContainer(_), this.initModifierProperties(_, j), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, ShapeModifier.prototype.processKeys = function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties()) }, extendPrototype([DynamicPropertyContainer], ShapeModifier); function TrimModifier() { } extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (_, j) { this.s = PropertyFactory.getProp(_, j.s, 0, .01, this), this.e = PropertyFactory.getProp(_, j.e, 0, .01, this), this.o = PropertyFactory.getProp(_, j.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = j.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length }, TrimModifier.prototype.addShapeToModifier = function (_) { _.pathsData = [] }, TrimModifier.prototype.calculateShapeEdges = function (_, j, $, _e, et) { var tt = []; j <= 1 ? tt.push({ s: _, e: j }) : _ >= 1 ? tt.push({ s: _ - 1, e: j - 1 }) : (tt.push({ s: _, e: 1 }), tt.push({ s: 0, e: j - 1 })); var rt = [], nt, it = tt.length, st; for (nt = 0; nt < it; nt += 1)if (st = tt[nt], !(st.e * et < _e || st.s * et > _e + $)) { var ot, ft; st.s * et <= _e ? ot = 0 : ot = (st.s * et - _e) / $, st.e * et >= _e + $ ? ft = 1 : ft = (st.e * et - _e) / $, rt.push([ot, ft]) } return rt.length || rt.push([0, 0]), rt }, TrimModifier.prototype.releasePathsData = function (_) { var j, $ = _.length; for (j = 0; j < $; j += 1)segmentsLengthPool.release(_[j]); return _.length = 0, _ }, TrimModifier.prototype.processShapes = function (_) { var j, $; if (this._mdf || _) { var _e = this.o.v % 360 / 360; if (_e < 0 && (_e += 1), this.s.v > 1 ? j = 1 + _e : this.s.v < 0 ? j = 0 + _e : j = this.s.v + _e, this.e.v > 1 ? $ = 1 + _e : this.e.v < 0 ? $ = 0 + _e : $ = this.e.v + _e, j > $) { var et = j; j = $, $ = et } j = Math.round(j * 1e4) * 1e-4, $ = Math.round($ * 1e4) * 1e-4, this.sValue = j, this.eValue = $ } else j = this.sValue, $ = this.eValue; var tt, rt, nt = this.shapes.length, it, st, ot, ft, at, dt = 0; if ($ === j) for (rt = 0; rt < nt; rt += 1)this.shapes[rt].localShapeCollection.releaseShapes(), this.shapes[rt].shape._mdf = !0, this.shapes[rt].shape.paths = this.shapes[rt].localShapeCollection, this._mdf && (this.shapes[rt].pathsData.length = 0); else if ($ === 1 && j === 0 || $ === 0 && j === 1) { if (this._mdf) for (rt = 0; rt < nt; rt += 1)this.shapes[rt].pathsData.length = 0, this.shapes[rt].shape._mdf = !0 } else { var pt = [], ht, xt; for (rt = 0; rt < nt; rt += 1)if (ht = this.shapes[rt], !ht.shape._mdf && !this._mdf && !_ && this.m !== 2) ht.shape.paths = ht.localShapeCollection; else { if (tt = ht.shape.paths, st = tt._length, at = 0, !ht.shape._mdf && ht.pathsData.length) at = ht.totalShapeLength; else { for (ot = this.releasePathsData(ht.pathsData), it = 0; it < st; it += 1)ft = bez.getSegmentsLength(tt.shapes[it]), ot.push(ft), at += ft.totalLength; ht.totalShapeLength = at, ht.pathsData = ot } dt += at, ht.shape._mdf = !0 } var ct = j, ut = $, lt = 0, mt; for (rt = nt - 1; rt >= 0; rt -= 1)if (ht = this.shapes[rt], ht.shape._mdf) { for (xt = ht.localShapeCollection, xt.releaseShapes(), this.m === 2 && nt > 1 ? (mt = this.calculateShapeEdges(j, $, ht.totalShapeLength, lt, dt), lt += ht.totalShapeLength) : mt = [[ct, ut]], st = mt.length, it = 0; it < st; it += 1) { ct = mt[it][0], ut = mt[it][1], pt.length = 0, ut <= 1 ? pt.push({ s: ht.totalShapeLength * ct, e: ht.totalShapeLength * ut }) : ct >= 1 ? pt.push({ s: ht.totalShapeLength * (ct - 1), e: ht.totalShapeLength * (ut - 1) }) : (pt.push({ s: ht.totalShapeLength * ct, e: ht.totalShapeLength }), pt.push({ s: 0, e: ht.totalShapeLength * (ut - 1) })); var yt = this.addShapes(ht, pt[0]); if (pt[0].s !== pt[0].e) { if (pt.length > 1) { var gt = ht.shape.paths.shapes[ht.shape.paths._length - 1]; if (gt.c) { var St = yt.pop(); this.addPaths(yt, xt), yt = this.addShapes(ht, pt[1], St) } else this.addPaths(yt, xt), yt = this.addShapes(ht, pt[1]) } this.addPaths(yt, xt) } } ht.shape.paths = xt } } }, TrimModifier.prototype.addPaths = function (_, j) { var $, _e = _.length; for ($ = 0; $ < _e; $ += 1)j.addShape(_[$]) }, TrimModifier.prototype.addSegment = function (_, j, $, _e, et, tt, rt) { et.setXYAt(j[0], j[1], "o", tt), et.setXYAt($[0], $[1], "i", tt + 1), rt && et.setXYAt(_[0], _[1], "v", tt), et.setXYAt(_e[0], _e[1], "v", tt + 1) }, TrimModifier.prototype.addSegmentFromArray = function (_, j, $, _e) { j.setXYAt(_[1], _[5], "o", $), j.setXYAt(_[2], _[6], "i", $ + 1), _e && j.setXYAt(_[0], _[4], "v", $), j.setXYAt(_[3], _[7], "v", $ + 1) }, TrimModifier.prototype.addShapes = function (_, j, $) { var _e = _.pathsData, et = _.shape.paths.shapes, tt, rt = _.shape.paths._length, nt, it, st = 0, ot, ft, at, dt, pt = [], ht, xt = !0; for ($ ? (ft = $._length, ht = $._length) : ($ = shapePool.newElement(), ft = 0, ht = 0), pt.push($), tt = 0; tt < rt; tt += 1) { for (at = _e[tt].lengths, $.c = et[tt].c, it = et[tt].c ? at.length : at.length + 1, nt = 1; nt < it; nt += 1)if (ot = at[nt - 1], st + ot.addedLength < j.s) st += ot.addedLength, $.c = !1; else if (st > j.e) { $.c = !1; break } else j.s <= st && j.e >= st + ot.addedLength ? (this.addSegment(et[tt].v[nt - 1], et[tt].o[nt - 1], et[tt].i[nt], et[tt].v[nt], $, ft, xt), xt = !1) : (dt = bez.getNewSegment(et[tt].v[nt - 1], et[tt].v[nt], et[tt].o[nt - 1], et[tt].i[nt], (j.s - st) / ot.addedLength, (j.e - st) / ot.addedLength, at[nt - 1]), this.addSegmentFromArray(dt, $, ft, xt), xt = !1, $.c = !1), st += ot.addedLength, ft += 1; if (et[tt].c && at.length) { if (ot = at[nt - 1], st <= j.e) { var ct = at[nt - 1].addedLength; j.s <= st && j.e >= st + ct ? (this.addSegment(et[tt].v[nt - 1], et[tt].o[nt - 1], et[tt].i[0], et[tt].v[0], $, ft, xt), xt = !1) : (dt = bez.getNewSegment(et[tt].v[nt - 1], et[tt].v[0], et[tt].o[nt - 1], et[tt].i[0], (j.s - st) / ct, (j.e - st) / ct, at[nt - 1]), this.addSegmentFromArray(dt, $, ft, xt), xt = !1, $.c = !1) } else $.c = !1; st += ot.addedLength, ft += 1 } if ($._length && ($.setXYAt($.v[ht][0], $.v[ht][1], "i", ht), $.setXYAt($.v[$._length - 1][0], $.v[$._length - 1][1], "o", $._length - 1)), st > j.e) break; tt < rt - 1 && ($ = shapePool.newElement(), xt = !0, pt.push($), ft = 0) } return pt }; function PuckerAndBloatModifier() { } extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (_, j) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(_, j.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length }, PuckerAndBloatModifier.prototype.processPath = function (_, j) { var $ = j / 100, _e = [0, 0], et = _._length, tt = 0; for (tt = 0; tt < et; tt += 1)_e[0] += _.v[tt][0], _e[1] += _.v[tt][1]; _e[0] /= et, _e[1] /= et; var rt = shapePool.newElement(); rt.c = _.c; var nt, it, st, ot, ft, at; for (tt = 0; tt < et; tt += 1)nt = _.v[tt][0] + (_e[0] - _.v[tt][0]) * $, it = _.v[tt][1] + (_e[1] - _.v[tt][1]) * $, st = _.o[tt][0] + (_e[0] - _.o[tt][0]) * -$, ot = _.o[tt][1] + (_e[1] - _.o[tt][1]) * -$, ft = _.i[tt][0] + (_e[0] - _.i[tt][0]) * -$, at = _.i[tt][1] + (_e[1] - _.i[tt][1]) * -$, rt.setTripleAt(nt, it, st, ot, ft, at, tt); return rt }, PuckerAndBloatModifier.prototype.processShapes = function (_) { var j, $, _e = this.shapes.length, et, tt, rt = this.amount.v; if (rt !== 0) { var nt, it; for ($ = 0; $ < _e; $ += 1) { if (nt = this.shapes[$], it = nt.localShapeCollection, !(!nt.shape._mdf && !this._mdf && !_)) for (it.releaseShapes(), nt.shape._mdf = !0, j = nt.shape.paths.shapes, tt = nt.shape.paths._length, et = 0; et < tt; et += 1)it.addShape(this.processPath(j[et], rt)); nt.shape.paths = nt.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; var TransformPropertyFactory = function () { var _ = [0, 0]; function j(it) { var st = this._mdf; this.iterateDynamicProperties(), this._mdf = this._mdf || st, this.a && it.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && it.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && it.skewFromAxis(-this.sk.v, this.sa.v), this.r ? it.rotate(-this.r.v) : it.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? it.translate(this.px.v, this.py.v, -this.pz.v) : it.translate(this.px.v, this.py.v, 0) : it.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } function $(it) { if (this.elem.globalData.frameId !== this.frameId) { if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || it) { var st; if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) { var ot, ft; if (st = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (ot = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / st, 0), ft = this.p.getValueAtTime(this.p.keyframes[0].t / st, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (ot = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / st, 0), ft = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / st, 0)) : (ot = this.p.pv, ft = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / st, this.p.offsetTime)); else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) { ot = [], ft = []; var at = this.px, dt = this.py; at._caching.lastFrame + at.offsetTime <= at.keyframes[0].t ? (ot[0] = at.getValueAtTime((at.keyframes[0].t + .01) / st, 0), ot[1] = dt.getValueAtTime((dt.keyframes[0].t + .01) / st, 0), ft[0] = at.getValueAtTime(at.keyframes[0].t / st, 0), ft[1] = dt.getValueAtTime(dt.keyframes[0].t / st, 0)) : at._caching.lastFrame + at.offsetTime >= at.keyframes[at.keyframes.length - 1].t ? (ot[0] = at.getValueAtTime(at.keyframes[at.keyframes.length - 1].t / st, 0), ot[1] = dt.getValueAtTime(dt.keyframes[dt.keyframes.length - 1].t / st, 0), ft[0] = at.getValueAtTime((at.keyframes[at.keyframes.length - 1].t - .01) / st, 0), ft[1] = dt.getValueAtTime((dt.keyframes[dt.keyframes.length - 1].t - .01) / st, 0)) : (ot = [at.pv, dt.pv], ft[0] = at.getValueAtTime((at._caching.lastFrame + at.offsetTime - .01) / st, at.offsetTime), ft[1] = dt.getValueAtTime((dt._caching.lastFrame + dt.offsetTime - .01) / st, dt.offsetTime)) } else ft = _, ot = ft; this.v.rotate(-Math.atan2(ot[1] - ft[1], ot[0] - ft[0])) } this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } this.frameId = this.elem.globalData.frameId } } function _e() { if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length) this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1; else return; if (!this.s.effectsSequence.length) this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2; else return; if (this.sk) if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3; else return; this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4) } function et() { } function tt(it) { this._addDynamicProperty(it), this.elem.addDynamicProperty(it), this._isDirty = !0 } function rt(it, st, ot) { if (this.elem = it, this.frameId = -1, this.propType = "transform", this.data = st, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(ot || it), st.p && st.p.s ? (this.px = PropertyFactory.getProp(it, st.p.x, 0, 0, this), this.py = PropertyFactory.getProp(it, st.p.y, 0, 0, this), st.p.z && (this.pz = PropertyFactory.getProp(it, st.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(it, st.p || { k: [0, 0, 0] }, 1, 0, this), st.rx) { if (this.rx = PropertyFactory.getProp(it, st.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(it, st.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(it, st.rz, 0, degToRads, this), st.or.k[0].ti) { var ft, at = st.or.k.length; for (ft = 0; ft < at; ft += 1)st.or.k[ft].to = null, st.or.k[ft].ti = null } this.or = PropertyFactory.getProp(it, st.or, 1, degToRads, this), this.or.sh = !0 } else this.r = PropertyFactory.getProp(it, st.r || { k: 0 }, 0, degToRads, this); st.sk && (this.sk = PropertyFactory.getProp(it, st.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(it, st.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(it, st.a || { k: [0, 0, 0] }, 1, 0, this), this.s = PropertyFactory.getProp(it, st.s || { k: [100, 100, 100] }, 1, .01, this), st.o ? this.o = PropertyFactory.getProp(it, st.o, 0, .01, it) : this.o = { _mdf: !1, v: 1 }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0) } rt.prototype = { applyToMatrix: j, getValue: $, precalculateMatrix: _e, autoOrient: et }, extendPrototype([DynamicPropertyContainer], rt), rt.prototype.addDynamicProperty = tt, rt.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty; function nt(it, st, ot) { return new rt(it, st, ot) } return { getTransformProperty: nt } }(); function RepeaterModifier() { } extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (_, j) { this.getValue = this.processKeys, this.c = PropertyFactory.getProp(_, j.c, 0, null, this), this.o = PropertyFactory.getProp(_, j.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(_, j.tr, this), this.so = PropertyFactory.getProp(_, j.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(_, j.tr.eo, 0, .01, this), this.data = j, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix }, RepeaterModifier.prototype.applyTransforms = function (_, j, $, _e, et, tt) { var rt = tt ? -1 : 1, nt = _e.s.v[0] + (1 - _e.s.v[0]) * (1 - et), it = _e.s.v[1] + (1 - _e.s.v[1]) * (1 - et); _.translate(_e.p.v[0] * rt * et, _e.p.v[1] * rt * et, _e.p.v[2]), j.translate(-_e.a.v[0], -_e.a.v[1], _e.a.v[2]), j.rotate(-_e.r.v * rt * et), j.translate(_e.a.v[0], _e.a.v[1], _e.a.v[2]), $.translate(-_e.a.v[0], -_e.a.v[1], _e.a.v[2]), $.scale(tt ? 1 / nt : nt, tt ? 1 / it : it), $.translate(_e.a.v[0], _e.a.v[1], _e.a.v[2]) }, RepeaterModifier.prototype.init = function (_, j, $, _e) { for (this.elem = _, this.arr = j, this.pos = $, this.elemsData = _e, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(_), this.initModifierProperties(_, j[$]); $ > 0;)$ -= 1, this._elements.unshift(j[$]); this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, RepeaterModifier.prototype.resetElements = function (_) { var j, $ = _.length; for (j = 0; j < $; j += 1)_[j]._processed = !1, _[j].ty === "gr" && this.resetElements(_[j].it) }, RepeaterModifier.prototype.cloneElements = function (_) { var j = JSON.parse(JSON.stringify(_)); return this.resetElements(j), j }, RepeaterModifier.prototype.changeGroupRender = function (_, j) { var $, _e = _.length; for ($ = 0; $ < _e; $ += 1)_[$]._render = j, _[$].ty === "gr" && this.changeGroupRender(_[$].it, j) }, RepeaterModifier.prototype.processShapes = function (_) { var j, $, _e, et, tt, rt = !1; if (this._mdf || _) { var nt = Math.ceil(this.c.v); if (this._groups.length < nt) { for (; this._groups.length < nt;) { var it = { it: this.cloneElements(this._elements), ty: "gr" }; it.it.push({ a: { a: 0, ix: 1, k: [0, 0] }, nm: "Transform", o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: "tr" }), this.arr.splice(0, 0, it), this._groups.splice(0, 0, it), this._currentCopies += 1 } this.elem.reloadShapes(), rt = !0 } tt = 0; var st; for (_e = 0; _e <= this._groups.length - 1; _e += 1) { if (st = tt < nt, this._groups[_e]._render = st, this.changeGroupRender(this._groups[_e].it, st), !st) { var ot = this.elemsData[_e].it, ft = ot[ot.length - 1]; ft.transform.op.v !== 0 ? (ft.transform.op._mdf = !0, ft.transform.op.v = 0) : ft.transform.op._mdf = !1 } tt += 1 } this._currentCopies = nt; var at = this.o.v, dt = at % 1, pt = at > 0 ? Math.floor(at) : Math.ceil(at), ht = this.pMatrix.props, xt = this.rMatrix.props, ct = this.sMatrix.props; this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset(); var ut = 0; if (at > 0) { for (; ut < pt;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), ut += 1; dt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, dt, !1), ut += dt) } else if (at < 0) { for (; ut > pt;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), ut -= 1; dt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -dt, !0), ut -= dt) } _e = this.data.m === 1 ? 0 : this._currentCopies - 1, et = this.data.m === 1 ? 1 : -1, tt = this._currentCopies; for (var lt, mt; tt;) { if (j = this.elemsData[_e].it, $ = j[j.length - 1].transform.mProps.v.props, mt = $.length, j[j.length - 1].transform.mProps._mdf = !0, j[j.length - 1].transform.op._mdf = !0, j[j.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (_e / (this._currentCopies - 1)), ut !== 0) { for ((_e !== 0 && et === 1 || _e !== this._currentCopies - 1 && et === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(xt[0], xt[1], xt[2], xt[3], xt[4], xt[5], xt[6], xt[7], xt[8], xt[9], xt[10], xt[11], xt[12], xt[13], xt[14], xt[15]), this.matrix.transform(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5], ct[6], ct[7], ct[8], ct[9], ct[10], ct[11], ct[12], ct[13], ct[14], ct[15]), this.matrix.transform(ht[0], ht[1], ht[2], ht[3], ht[4], ht[5], ht[6], ht[7], ht[8], ht[9], ht[10], ht[11], ht[12], ht[13], ht[14], ht[15]), lt = 0; lt < mt; lt += 1)$[lt] = this.matrix.props[lt]; this.matrix.reset() } else for (this.matrix.reset(), lt = 0; lt < mt; lt += 1)$[lt] = this.matrix.props[lt]; ut += 1, tt -= 1, _e += et } } else for (tt = this._currentCopies, _e = 0, et = 1; tt;)j = this.elemsData[_e].it, $ = j[j.length - 1].transform.mProps.v.props, j[j.length - 1].transform.mProps._mdf = !1, j[j.length - 1].transform.op._mdf = !1, tt -= 1, _e += et; return rt }, RepeaterModifier.prototype.addShape = function () { }; function RoundCornersModifier() { } extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (_, j) { this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(_, j.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length }, RoundCornersModifier.prototype.processPath = function (_, j) { var $ = shapePool.newElement(); $.c = _.c; var _e, et = _._length, tt, rt, nt, it, st, ot, ft = 0, at, dt, pt, ht, xt, ct; for (_e = 0; _e < et; _e += 1)tt = _.v[_e], nt = _.o[_e], rt = _.i[_e], tt[0] === nt[0] && tt[1] === nt[1] && tt[0] === rt[0] && tt[1] === rt[1] ? (_e === 0 || _e === et - 1) && !_.c ? ($.setTripleAt(tt[0], tt[1], nt[0], nt[1], rt[0], rt[1], ft), ft += 1) : (_e === 0 ? it = _.v[et - 1] : it = _.v[_e - 1], st = Math.sqrt(Math.pow(tt[0] - it[0], 2) + Math.pow(tt[1] - it[1], 2)), ot = st ? Math.min(st / 2, j) / st : 0, xt = tt[0] + (it[0] - tt[0]) * ot, at = xt, ct = tt[1] - (tt[1] - it[1]) * ot, dt = ct, pt = at - (at - tt[0]) * roundCorner, ht = dt - (dt - tt[1]) * roundCorner, $.setTripleAt(at, dt, pt, ht, xt, ct, ft), ft += 1, _e === et - 1 ? it = _.v[0] : it = _.v[_e + 1], st = Math.sqrt(Math.pow(tt[0] - it[0], 2) + Math.pow(tt[1] - it[1], 2)), ot = st ? Math.min(st / 2, j) / st : 0, pt = tt[0] + (it[0] - tt[0]) * ot, at = pt, ht = tt[1] + (it[1] - tt[1]) * ot, dt = ht, xt = at - (at - tt[0]) * roundCorner, ct = dt - (dt - tt[1]) * roundCorner, $.setTripleAt(at, dt, pt, ht, xt, ct, ft), ft += 1) : ($.setTripleAt(_.v[_e][0], _.v[_e][1], _.o[_e][0], _.o[_e][1], _.i[_e][0], _.i[_e][1], ft), ft += 1); return $ }, RoundCornersModifier.prototype.processShapes = function (_) { var j, $, _e = this.shapes.length, et, tt, rt = this.rd.v; if (rt !== 0) { var nt, it; for ($ = 0; $ < _e; $ += 1) { if (nt = this.shapes[$], it = nt.localShapeCollection, !(!nt.shape._mdf && !this._mdf && !_)) for (it.releaseShapes(), nt.shape._mdf = !0, j = nt.shape.paths.shapes, tt = nt.shape.paths._length, et = 0; et < tt; et += 1)it.addShape(this.processPath(j[et], rt)); nt.shape.paths = nt.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function floatEqual(_, j) { return Math.abs(_ - j) * 1e5 <= Math.min(Math.abs(_), Math.abs(j)) } function floatZero(_) { return Math.abs(_) <= 1e-5 } function lerp(_, j, $) { return _ * (1 - $) + j * $ } function lerpPoint(_, j, $) { return [lerp(_[0], j[0], $), lerp(_[1], j[1], $)] } function quadRoots(_, j, $) { if (_ === 0) return []; var _e = j * j - 4 * _ * $; if (_e < 0) return []; var et = -j / (2 * _); if (_e === 0) return [et]; var tt = Math.sqrt(_e) / (2 * _); return [et - tt, et + tt] } function polynomialCoefficients(_, j, $, _e) { return [-_ + 3 * j - 3 * $ + _e, 3 * _ - 6 * j + 3 * $, -3 * _ + 3 * j, _] } function singlePoint(_) { return new PolynomialBezier(_, _, _, _, !1) } function PolynomialBezier(_, j, $, _e, et) { et && pointEqual(_, j) && (j = lerpPoint(_, _e, 1 / 3)), et && pointEqual($, _e) && ($ = lerpPoint(_, _e, 2 / 3)); var tt = polynomialCoefficients(_[0], j[0], $[0], _e[0]), rt = polynomialCoefficients(_[1], j[1], $[1], _e[1]); this.a = [tt[0], rt[0]], this.b = [tt[1], rt[1]], this.c = [tt[2], rt[2]], this.d = [tt[3], rt[3]], this.points = [_, j, $, _e] } PolynomialBezier.prototype.point = function (_) { return [((this.a[0] * _ + this.b[0]) * _ + this.c[0]) * _ + this.d[0], ((this.a[1] * _ + this.b[1]) * _ + this.c[1]) * _ + this.d[1]] }, PolynomialBezier.prototype.derivative = function (_) { return [(3 * _ * this.a[0] + 2 * this.b[0]) * _ + this.c[0], (3 * _ * this.a[1] + 2 * this.b[1]) * _ + this.c[1]] }, PolynomialBezier.prototype.tangentAngle = function (_) { var j = this.derivative(_); return Math.atan2(j[1], j[0]) }, PolynomialBezier.prototype.normalAngle = function (_) { var j = this.derivative(_); return Math.atan2(j[0], j[1]) }, PolynomialBezier.prototype.inflectionPoints = function () { var _ = this.a[1] * this.b[0] - this.a[0] * this.b[1]; if (floatZero(_)) return []; var j = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / _, $ = j * j - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / _; if ($ < 0) return []; var _e = Math.sqrt($); return floatZero(_e) ? _e > 0 && _e < 1 ? [j] : [] : [j - _e, j + _e].filter(function (et) { return et > 0 && et < 1 }) }, PolynomialBezier.prototype.split = function (_) { if (_ <= 0) return [singlePoint(this.points[0]), this]; if (_ >= 1) return [this, singlePoint(this.points[this.points.length - 1])]; var j = lerpPoint(this.points[0], this.points[1], _), $ = lerpPoint(this.points[1], this.points[2], _), _e = lerpPoint(this.points[2], this.points[3], _), et = lerpPoint(j, $, _), tt = lerpPoint($, _e, _), rt = lerpPoint(et, tt, _); return [new PolynomialBezier(this.points[0], j, et, rt, !0), new PolynomialBezier(rt, tt, _e, this.points[3], !0)] }; function extrema(_, j) { var $ = _.points[0][j], _e = _.points[_.points.length - 1][j]; if ($ > _e) { var et = _e; _e = $, $ = et } for (var tt = quadRoots(3 * _.a[j], 2 * _.b[j], _.c[j]), rt = 0; rt < tt.length; rt += 1)if (tt[rt] > 0 && tt[rt] < 1) { var nt = _.point(tt[rt])[j]; nt < $ ? $ = nt : nt > _e && (_e = nt) } return { min: $, max: _e } } PolynomialBezier.prototype.bounds = function () { return { x: extrema(this, 0), y: extrema(this, 1) } }, PolynomialBezier.prototype.boundingBox = function () { var _ = this.bounds(); return { left: _.x.min, right: _.x.max, top: _.y.min, bottom: _.y.max, width: _.x.max - _.x.min, height: _.y.max - _.y.min, cx: (_.x.max + _.x.min) / 2, cy: (_.y.max + _.y.min) / 2 } }; function intersectData(_, j, $) { var _e = _.boundingBox(); return { cx: _e.cx, cy: _e.cy, width: _e.width, height: _e.height, bez: _, t: (j + $) / 2, t1: j, t2: $ } } function splitData(_) { var j = _.bez.split(.5); return [intersectData(j[0], _.t1, _.t), intersectData(j[1], _.t, _.t2)] } function boxIntersect(_, j) { return Math.abs(_.cx - j.cx) * 2 < _.width + j.width && Math.abs(_.cy - j.cy) * 2 < _.height + j.height } function intersectsImpl(_, j, $, _e, et, tt) { if (boxIntersect(_, j)) { if ($ >= tt || _.width <= _e && _.height <= _e && j.width <= _e && j.height <= _e) { et.push([_.t, j.t]); return } var rt = splitData(_), nt = splitData(j); intersectsImpl(rt[0], nt[0], $ + 1, _e, et, tt), intersectsImpl(rt[0], nt[1], $ + 1, _e, et, tt), intersectsImpl(rt[1], nt[0], $ + 1, _e, et, tt), intersectsImpl(rt[1], nt[1], $ + 1, _e, et, tt) } } PolynomialBezier.prototype.intersections = function (_, j, $) { j === void 0 && (j = 2), $ === void 0 && ($ = 7); var _e = []; return intersectsImpl(intersectData(this, 0, 1), intersectData(_, 0, 1), 0, j, _e, $), _e }, PolynomialBezier.shapeSegment = function (_, j) { var $ = (j + 1) % _.length(); return new PolynomialBezier(_.v[j], _.o[j], _.i[$], _.v[$], !0) }, PolynomialBezier.shapeSegmentInverted = function (_, j) { var $ = (j + 1) % _.length(); return new PolynomialBezier(_.v[$], _.i[$], _.o[j], _.v[j], !0) }; function crossProduct(_, j) { return [_[1] * j[2] - _[2] * j[1], _[2] * j[0] - _[0] * j[2], _[0] * j[1] - _[1] * j[0]] } function lineIntersection(_, j, $, _e) { var et = [_[0], _[1], 1], tt = [j[0], j[1], 1], rt = [$[0], $[1], 1], nt = [_e[0], _e[1], 1], it = crossProduct(crossProduct(et, tt), crossProduct(rt, nt)); return floatZero(it[2]) ? null : [it[0] / it[2], it[1] / it[2]] } function polarOffset(_, j, $) { return [_[0] + Math.cos(j) * $, _[1] - Math.sin(j) * $] } function pointDistance(_, j) { return Math.hypot(_[0] - j[0], _[1] - j[1]) } function pointEqual(_, j) { return floatEqual(_[0], j[0]) && floatEqual(_[1], j[1]) } function ZigZagModifier() { } extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function (_, j) { this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(_, j.s, 0, null, this), this.frequency = PropertyFactory.getProp(_, j.r, 0, null, this), this.pointsType = PropertyFactory.getProp(_, j.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0 }; function setPoint(_, j, $, _e, et, tt, rt) { var nt = $ - Math.PI / 2, it = $ + Math.PI / 2, st = j[0] + Math.cos($) * _e * et, ot = j[1] - Math.sin($) * _e * et; _.setTripleAt(st, ot, st + Math.cos(nt) * tt, ot - Math.sin(nt) * tt, st + Math.cos(it) * rt, ot - Math.sin(it) * rt, _.length()) } function getPerpendicularVector(_, j) { var $ = [j[0] - _[0], j[1] - _[1]], _e = -Math.PI * .5, et = [Math.cos(_e) * $[0] - Math.sin(_e) * $[1], Math.sin(_e) * $[0] + Math.cos(_e) * $[1]]; return et } function getProjectingAngle(_, j) { var $ = j === 0 ? _.length() - 1 : j - 1, _e = (j + 1) % _.length(), et = _.v[$], tt = _.v[_e], rt = getPerpendicularVector(et, tt); return Math.atan2(0, 1) - Math.atan2(rt[1], rt[0]) } function zigZagCorner(_, j, $, _e, et, tt, rt) { var nt = getProjectingAngle(j, $), it = j.v[$ % j._length], st = j.v[$ === 0 ? j._length - 1 : $ - 1], ot = j.v[($ + 1) % j._length], ft = tt === 2 ? Math.sqrt(Math.pow(it[0] - st[0], 2) + Math.pow(it[1] - st[1], 2)) : 0, at = tt === 2 ? Math.sqrt(Math.pow(it[0] - ot[0], 2) + Math.pow(it[1] - ot[1], 2)) : 0; setPoint(_, j.v[$ % j._length], nt, rt, _e, at / ((et + 1) * 2), ft / ((et + 1) * 2)) } function zigZagSegment(_, j, $, _e, et, tt) { for (var rt = 0; rt < _e; rt += 1) { var nt = (rt + 1) / (_e + 1), it = et === 2 ? Math.sqrt(Math.pow(j.points[3][0] - j.points[0][0], 2) + Math.pow(j.points[3][1] - j.points[0][1], 2)) : 0, st = j.normalAngle(nt), ot = j.point(nt); setPoint(_, ot, st, tt, $, it / ((_e + 1) * 2), it / ((_e + 1) * 2)), tt = -tt } return tt } ZigZagModifier.prototype.processPath = function (_, j, $, _e) { var et = _._length, tt = shapePool.newElement(); if (tt.c = _.c, _.c || (et -= 1), et === 0) return tt; var rt = -1, nt = PolynomialBezier.shapeSegment(_, 0); zigZagCorner(tt, _, 0, j, $, _e, rt); for (var it = 0; it < et; it += 1)rt = zigZagSegment(tt, nt, j, $, _e, -rt), it === et - 1 && !_.c ? nt = null : nt = PolynomialBezier.shapeSegment(_, (it + 1) % et), zigZagCorner(tt, _, it + 1, j, $, _e, rt); return tt }, ZigZagModifier.prototype.processShapes = function (_) { var j, $, _e = this.shapes.length, et, tt, rt = this.amplitude.v, nt = Math.max(0, Math.round(this.frequency.v)), it = this.pointsType.v; if (rt !== 0) { var st, ot; for ($ = 0; $ < _e; $ += 1) { if (st = this.shapes[$], ot = st.localShapeCollection, !(!st.shape._mdf && !this._mdf && !_)) for (ot.releaseShapes(), st.shape._mdf = !0, j = st.shape.paths.shapes, tt = st.shape.paths._length, et = 0; et < tt; et += 1)ot.addShape(this.processPath(j[et], rt, nt, it)); st.shape.paths = st.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function linearOffset(_, j, $) { var _e = Math.atan2(j[0] - _[0], j[1] - _[1]); return [polarOffset(_, _e, $), polarOffset(j, _e, $)] } function offsetSegment(_, j) { var $, _e, et, tt, rt, nt, it; it = linearOffset(_.points[0], _.points[1], j), $ = it[0], _e = it[1], it = linearOffset(_.points[1], _.points[2], j), et = it[0], tt = it[1], it = linearOffset(_.points[2], _.points[3], j), rt = it[0], nt = it[1]; var st = lineIntersection($, _e, et, tt); st === null && (st = _e); var ot = lineIntersection(rt, nt, et, tt); return ot === null && (ot = rt), new PolynomialBezier($, st, ot, nt) } function joinLines(_, j, $, _e, et) { var tt = j.points[3], rt = $.points[0]; if (_e === 3 || pointEqual(tt, rt)) return tt; if (_e === 2) { var nt = -j.tangentAngle(1), it = -$.tangentAngle(0) + Math.PI, st = lineIntersection(tt, polarOffset(tt, nt + Math.PI / 2, 100), rt, polarOffset(rt, nt + Math.PI / 2, 100)), ot = st ? pointDistance(st, tt) : pointDistance(tt, rt) / 2, ft = polarOffset(tt, nt, 2 * ot * roundCorner); return _.setXYAt(ft[0], ft[1], "o", _.length() - 1), ft = polarOffset(rt, it, 2 * ot * roundCorner), _.setTripleAt(rt[0], rt[1], rt[0], rt[1], ft[0], ft[1], _.length()), rt } var at = pointEqual(tt, j.points[2]) ? j.points[0] : j.points[2], dt = pointEqual(rt, $.points[1]) ? $.points[3] : $.points[1], pt = lineIntersection(at, tt, rt, dt); return pt && pointDistance(pt, tt) < et ? (_.setTripleAt(pt[0], pt[1], pt[0], pt[1], pt[0], pt[1], _.length()), pt) : tt } function getIntersection(_, j) { var $ = _.intersections(j); return $.length && floatEqual($[0][0], 1) && $.shift(), $.length ? $[0] : null } function pruneSegmentIntersection(_, j) { var $ = _.slice(), _e = j.slice(), et = getIntersection(_[_.length - 1], j[0]); return et && ($[_.length - 1] = _[_.length - 1].split(et[0])[0], _e[0] = j[0].split(et[1])[1]), _.length > 1 && j.length > 1 && (et = getIntersection(_[0], j[j.length - 1]), et) ? [[_[0].split(et[0])[0]], [j[j.length - 1].split(et[1])[1]]] : [$, _e] } function pruneIntersections(_) { for (var j, $ = 1; $ < _.length; $ += 1)j = pruneSegmentIntersection(_[$ - 1], _[$]), _[$ - 1] = j[0], _[$] = j[1]; return _.length > 1 && (j = pruneSegmentIntersection(_[_.length - 1], _[0]), _[_.length - 1] = j[0], _[0] = j[1]), _ } function offsetSegmentSplit(_, j) { var $ = _.inflectionPoints(), _e, et, tt, rt; if ($.length === 0) return [offsetSegment(_, j)]; if ($.length === 1 || floatEqual($[1], 1)) return tt = _.split($[0]), _e = tt[0], et = tt[1], [offsetSegment(_e, j), offsetSegment(et, j)]; tt = _.split($[0]), _e = tt[0]; var nt = ($[1] - $[0]) / (1 - $[0]); return tt = tt[1].split(nt), rt = tt[0], et = tt[1], [offsetSegment(_e, j), offsetSegment(rt, j), offsetSegment(et, j)] } function OffsetPathModifier() { } extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function (_, j) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(_, j.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(_, j.ml, 0, null, this), this.lineJoin = j.lj, this._isAnimated = this.amount.effectsSequence.length !== 0 }, OffsetPathModifier.prototype.processPath = function (_, j, $, _e) { var et = shapePool.newElement(); et.c = _.c; var tt = _.length(); _.c || (tt -= 1); var rt, nt, it, st = []; for (rt = 0; rt < tt; rt += 1)it = PolynomialBezier.shapeSegment(_, rt), st.push(offsetSegmentSplit(it, j)); if (!_.c) for (rt = tt - 1; rt >= 0; rt -= 1)it = PolynomialBezier.shapeSegmentInverted(_, rt), st.push(offsetSegmentSplit(it, j)); st = pruneIntersections(st); var ot = null, ft = null; for (rt = 0; rt < st.length; rt += 1) { var at = st[rt]; for (ft && (ot = joinLines(et, ft, at[0], $, _e)), ft = at[at.length - 1], nt = 0; nt < at.length; nt += 1)it = at[nt], ot && pointEqual(it.points[0], ot) ? et.setXYAt(it.points[1][0], it.points[1][1], "o", et.length() - 1) : et.setTripleAt(it.points[0][0], it.points[0][1], it.points[1][0], it.points[1][1], it.points[0][0], it.points[0][1], et.length()), et.setTripleAt(it.points[3][0], it.points[3][1], it.points[3][0], it.points[3][1], it.points[2][0], it.points[2][1], et.length()), ot = it.points[3] } return st.length && joinLines(et, ft, st[0][0], $, _e), et }, OffsetPathModifier.prototype.processShapes = function (_) { var j, $, _e = this.shapes.length, et, tt, rt = this.amount.v, nt = this.miterLimit.v, it = this.lineJoin; if (rt !== 0) { var st, ot; for ($ = 0; $ < _e; $ += 1) { if (st = this.shapes[$], ot = st.localShapeCollection, !(!st.shape._mdf && !this._mdf && !_)) for (ot.releaseShapes(), st.shape._mdf = !0, j = st.shape.paths.shapes, tt = st.shape.paths._length, et = 0; et < tt; et += 1)ot.addShape(this.processPath(j[et], rt, it, nt)); st.shape.paths = st.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function getFontProperties(_) { for (var j = _.fStyle ? _.fStyle.split(" ") : [], $ = "normal", _e = "normal", et = j.length, tt, rt = 0; rt < et; rt += 1)switch (tt = j[rt].toLowerCase(), tt) { case "italic": _e = "italic"; break; case "bold": $ = "700"; break; case "black": $ = "900"; break; case "medium": $ = "500"; break; case "regular": case "normal": $ = "400"; break; case "light": case "thin": $ = "200"; break }return { style: _e, weight: _.fWeight || $ } } var FontManager = function () { var _ = 5e3, j = { w: 0, size: 0, shapes: [], data: { shapes: [] } }, $ = []; $ = $.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]); var _e = 127988, et = 917631, tt = 917601, rt = 917626, nt = 65039, it = 8205, st = 127462, ot = 127487, ft = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"]; function at(Pt) { var kt = Pt.split(","), vt, Et = kt.length, Ct = []; for (vt = 0; vt < Et; vt += 1)kt[vt] !== "sans-serif" && kt[vt] !== "monospace" && Ct.push(kt[vt]); return Ct.join(",") } function dt(Pt, kt) { var vt = createTag("span"); vt.setAttribute("aria-hidden", !0), vt.style.fontFamily = kt; var Et = createTag("span"); Et.innerText = "giItT1WQy@!-/#", vt.style.position = "absolute", vt.style.left = "-10000px", vt.style.top = "-10000px", vt.style.fontSize = "300px", vt.style.fontVariant = "normal", vt.style.fontStyle = "normal", vt.style.fontWeight = "normal", vt.style.letterSpacing = "0", vt.appendChild(Et), document.body.appendChild(vt); var Ct = Et.offsetWidth; return Et.style.fontFamily = at(Pt) + ", " + kt, { node: Et, w: Ct, parent: vt } } function pt() { var Pt, kt = this.fonts.length, vt, Et, Ct = kt; for (Pt = 0; Pt < kt; Pt += 1)this.fonts[Pt].loaded ? Ct -= 1 : this.fonts[Pt].fOrigin === "n" || this.fonts[Pt].origin === 0 ? this.fonts[Pt].loaded = !0 : (vt = this.fonts[Pt].monoCase.node, Et = this.fonts[Pt].monoCase.w, vt.offsetWidth !== Et ? (Ct -= 1, this.fonts[Pt].loaded = !0) : (vt = this.fonts[Pt].sansCase.node, Et = this.fonts[Pt].sansCase.w, vt.offsetWidth !== Et && (Ct -= 1, this.fonts[Pt].loaded = !0)), this.fonts[Pt].loaded && (this.fonts[Pt].sansCase.parent.parentNode.removeChild(this.fonts[Pt].sansCase.parent), this.fonts[Pt].monoCase.parent.parentNode.removeChild(this.fonts[Pt].monoCase.parent))); Ct !== 0 && Date.now() - this.initTime < _ ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10) } function ht(Pt, kt) { var vt = document.body && kt ? "svg" : "canvas", Et, Ct = getFontProperties(Pt); if (vt === "svg") { var wt = createNS("text"); wt.style.fontSize = "100px", wt.setAttribute("font-family", Pt.fFamily), wt.setAttribute("font-style", Ct.style), wt.setAttribute("font-weight", Ct.weight), wt.textContent = "1", Pt.fClass ? (wt.style.fontFamily = "inherit", wt.setAttribute("class", Pt.fClass)) : wt.style.fontFamily = Pt.fFamily, kt.appendChild(wt), Et = wt } else { var Tt = new OffscreenCanvas(500, 500).getContext("2d"); Tt.font = Ct.style + " " + Ct.weight + " 100px " + Pt.fFamily, Et = Tt } function jt(Ft) { return vt === "svg" ? (Et.textContent = Ft, Et.getComputedTextLength()) : Et.measureText(Ft).width } return { measureText: jt } } function xt(Pt, kt) { if (!Pt) { this.isLoaded = !0; return } if (this.chars) { this.isLoaded = !0, this.fonts = Pt.list; return } if (!document.body) { this.isLoaded = !0, Pt.list.forEach(function (Yt) { Yt.helper = ht(Yt), Yt.cache = {} }), this.fonts = Pt.list; return } var vt = Pt.list, Et, Ct = vt.length, wt = Ct; for (Et = 0; Et < Ct; Et += 1) { var Tt = !0, jt, Ft; if (vt[Et].loaded = !1, vt[Et].monoCase = dt(vt[Et].fFamily, "monospace"), vt[Et].sansCase = dt(vt[Et].fFamily, "sans-serif"), !vt[Et].fPath) vt[Et].loaded = !0, wt -= 1; else if (vt[Et].fOrigin === "p" || vt[Et].origin === 3) { if (jt = document.querySelectorAll('style[f-forigin="p"][f-family="' + vt[Et].fFamily + '"], style[f-origin="3"][f-family="' + vt[Et].fFamily + '"]'), jt.length > 0 && (Tt = !1), Tt) { var Dt = createTag("style"); Dt.setAttribute("f-forigin", vt[Et].fOrigin), Dt.setAttribute("f-origin", vt[Et].origin), Dt.setAttribute("f-family", vt[Et].fFamily), Dt.type = "text/css", Dt.innerText = "@font-face {font-family: " + vt[Et].fFamily + "; font-style: normal; src: url('" + vt[Et].fPath + "');}", kt.appendChild(Dt) } } else if (vt[Et].fOrigin === "g" || vt[Et].origin === 1) { for (jt = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), Ft = 0; Ft < jt.length; Ft += 1)jt[Ft].href.indexOf(vt[Et].fPath) !== -1 && (Tt = !1); if (Tt) { var Ot = createTag("link"); Ot.setAttribute("f-forigin", vt[Et].fOrigin), Ot.setAttribute("f-origin", vt[Et].origin), Ot.type = "text/css", Ot.rel = "stylesheet", Ot.href = vt[Et].fPath, document.body.appendChild(Ot) } } else if (vt[Et].fOrigin === "t" || vt[Et].origin === 2) { for (jt = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), Ft = 0; Ft < jt.length; Ft += 1)vt[Et].fPath === jt[Ft].src && (Tt = !1); if (Tt) { var Nt = createTag("link"); Nt.setAttribute("f-forigin", vt[Et].fOrigin), Nt.setAttribute("f-origin", vt[Et].origin), Nt.setAttribute("rel", "stylesheet"), Nt.setAttribute("href", vt[Et].fPath), kt.appendChild(Nt) } } vt[Et].helper = ht(vt[Et], kt), vt[Et].cache = {}, this.fonts.push(vt[Et]) } wt === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100) } function ct(Pt) { if (Pt) { this.chars || (this.chars = []); var kt, vt = Pt.length, Et, Ct = this.chars.length, wt; for (kt = 0; kt < vt; kt += 1) { for (Et = 0, wt = !1; Et < Ct;)this.chars[Et].style === Pt[kt].style && this.chars[Et].fFamily === Pt[kt].fFamily && this.chars[Et].ch === Pt[kt].ch && (wt = !0), Et += 1; wt || (this.chars.push(Pt[kt]), Ct += 1) } } } function ut(Pt, kt, vt) { for (var Et = 0, Ct = this.chars.length; Et < Ct;) { if (this.chars[Et].ch === Pt && this.chars[Et].style === kt && this.chars[Et].fFamily === vt) return this.chars[Et]; Et += 1 } return (typeof Pt == "string" && Pt.charCodeAt(0) !== 13 || !Pt) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", Pt, kt, vt)), j } function lt(Pt, kt, vt) { var Et = this.getFontByName(kt), Ct = Pt; if (!Et.cache[Ct]) { var wt = Et.helper; if (Pt === " ") { var Tt = wt.measureText("|" + Pt + "|"), jt = wt.measureText("||"); Et.cache[Ct] = (Tt - jt) / 100 } else Et.cache[Ct] = wt.measureText(Pt) / 100 } return Et.cache[Ct] * vt } function mt(Pt) { for (var kt = 0, vt = this.fonts.length; kt < vt;) { if (this.fonts[kt].fName === Pt) return this.fonts[kt]; kt += 1 } return this.fonts[0] } function yt(Pt) { var kt = 0, vt = Pt.charCodeAt(0); if (vt >= 55296 && vt <= 56319) { var Et = Pt.charCodeAt(1); Et >= 56320 && Et <= 57343 && (kt = (vt - 55296) * 1024 + Et - 56320 + 65536) } return kt } function gt(Pt, kt) { var vt = Pt.toString(16) + kt.toString(16); return ft.indexOf(vt) !== -1 } function St(Pt) { return Pt === it } function bt(Pt) { return Pt === nt } function _t(Pt) { var kt = yt(Pt); return kt >= st && kt <= ot } function Mt(Pt) { return _t(Pt.substr(0, 2)) && _t(Pt.substr(2, 2)) } function It(Pt) { return $.indexOf(Pt) !== -1 } function Rt(Pt, kt) { var vt = yt(Pt.substr(kt, 2)); if (vt !== _e) return !1; var Et = 0; for (kt += 2; Et < 5;) { if (vt = yt(Pt.substr(kt, 2)), vt < tt || vt > rt) return !1; Et += 1, kt += 2 } return yt(Pt.substr(kt, 2)) === et } function Lt() { this.isLoaded = !0 } var Vt = function () { this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this) }; Vt.isModifier = gt, Vt.isZeroWidthJoiner = St, Vt.isFlagEmoji = Mt, Vt.isRegionalCode = _t, Vt.isCombinedCharacter = It, Vt.isRegionalFlag = Rt, Vt.isVariationSelector = bt, Vt.BLACK_FLAG_CODE_POINT = _e; var At = { addChars: ct, addFonts: xt, getCharData: ut, getFontByName: mt, measureText: lt, checkLoadedFonts: pt, setIsLoaded: Lt }; return Vt.prototype = At, Vt }(); function SlotManager(_) { this.animationData = _ } SlotManager.prototype.getProp = function (_) { return this.animationData.slots && this.animationData.slots[_.sid] ? Object.assign(_, this.animationData.slots[_.sid].p) : _ }; function slotFactory(_) { return new SlotManager(_) } function RenderableElement() { } RenderableElement.prototype = { initRenderable: function () { this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [] }, addRenderableComponent: function (j) { this.renderableComponents.indexOf(j) === -1 && this.renderableComponents.push(j) }, removeRenderableComponent: function (j) { this.renderableComponents.indexOf(j) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(j), 1) }, prepareRenderableFrame: function (j) { this.checkLayerLimits(j) }, checkTransparency: function () { this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show()) }, checkLayerLimits: function (j) { this.data.ip - this.data.st <= j && this.data.op - this.data.st > j ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide()) }, renderRenderable: function () { var j, $ = this.renderableComponents.length; for (j = 0; j < $; j += 1)this.renderableComponents[j].renderFrame(this._isFirstFrame) }, sourceRectAtTime: function () { return { top: 0, left: 0, width: 100, height: 100 } }, getLayerSize: function () { return this.data.ty === 5 ? { w: this.data.textData.width, h: this.data.textData.height } : { w: this.data.width, h: this.data.height } } }; var getBlendMode = function () { var _ = { 0: "source-over", 1: "multiply", 2: "screen", 3: "overlay", 4: "darken", 5: "lighten", 6: "color-dodge", 7: "color-burn", 8: "hard-light", 9: "soft-light", 10: "difference", 11: "exclusion", 12: "hue", 13: "saturation", 14: "color", 15: "luminosity" }; return function (j) { return _[j] || "" } }(); function SliderEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 0, 0, $) } function AngleEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 0, 0, $) } function ColorEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 1, 0, $) } function PointEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 1, 0, $) } function LayerIndexEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 0, 0, $) } function MaskIndexEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 0, 0, $) } function CheckboxEffect(_, j, $) { this.p = PropertyFactory.getProp(j, _.v, 0, 0, $) } function NoValueEffect() { this.p = {} } function EffectsManager(_, j) { var $ = _.ef || []; this.effectElements = []; var _e, et = $.length, tt; for (_e = 0; _e < et; _e += 1)tt = new GroupEffect($[_e], j), this.effectElements.push(tt) } function GroupEffect(_, j) { this.init(_, j) } extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (_, j) { this.data = _, this.effectElements = [], this.initDynamicPropertyContainer(j); var $, _e = this.data.ef.length, et, tt = this.data.ef; for ($ = 0; $ < _e; $ += 1) { switch (et = null, tt[$].ty) { case 0: et = new SliderEffect(tt[$], j, this); break; case 1: et = new AngleEffect(tt[$], j, this); break; case 2: et = new ColorEffect(tt[$], j, this); break; case 3: et = new PointEffect(tt[$], j, this); break; case 4: case 7: et = new CheckboxEffect(tt[$], j, this); break; case 10: et = new LayerIndexEffect(tt[$], j, this); break; case 11: et = new MaskIndexEffect(tt[$], j, this); break; case 5: et = new EffectsManager(tt[$], j); break; default: et = new NoValueEffect(tt[$]); break }et && this.effectElements.push(et) } }; function BaseElement() { } BaseElement.prototype = { checkMasks: function () { if (!this.data.hasMask) return !1; for (var j = 0, $ = this.data.masksProperties.length; j < $;) { if (this.data.masksProperties[j].mode !== "n" && this.data.masksProperties[j].cl !== !1) return !0; j += 1 } return !1 }, initExpressions: function () { var j = getExpressionInterfaces(); if (j) { var $ = j("layer"), _e = j("effects"), et = j("shape"), tt = j("text"), rt = j("comp"); this.layerInterface = $(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager); var nt = _e.createEffectsInterface(this, this.layerInterface); this.layerInterface.registerEffectsInterface(nt), this.data.ty === 0 || this.data.xt ? this.compInterface = rt(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = et(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = tt(this), this.layerInterface.text = this.layerInterface.textInterface) } }, setBlendMode: function () { var j = getBlendMode(this.data.bm), $ = this.baseElement || this.layerElement; $.style["mix-blend-mode"] = j }, initBaseData: function (j, $, _e) { this.globalData = $, this.comp = _e, this.data = j, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties) }, getType: function () { return this.type }, sourceRectAtTime: function () { } }; function FrameElement() { } FrameElement.prototype = { initFrame: function () { this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1 }, prepareProperties: function (j, $) { var _e, et = this.dynamicProperties.length; for (_e = 0; _e < et; _e += 1)($ || this._isParent && this.dynamicProperties[_e].propType === "transform") && (this.dynamicProperties[_e].getValue(), this.dynamicProperties[_e]._mdf && (this.globalData._mdf = !0, this._mdf = !0)) }, addDynamicProperty: function (j) { this.dynamicProperties.indexOf(j) === -1 && this.dynamicProperties.push(j) } }; function FootageElement(_, j, $) { this.initFrame(), this.initRenderable(), this.assetData = j.getAssetData(_.refId), this.footageData = j.imageLoader.getAsset(this.assetData), this.initBaseData(_, j, $) } FootageElement.prototype.prepareFrame = function () { }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () { return null }, FootageElement.prototype.renderFrame = function () { }, FootageElement.prototype.destroy = function () { }, FootageElement.prototype.initExpressions = function () { var _ = getExpressionInterfaces(); if (_) { var j = _("footage"); this.layerInterface = j(this) } }, FootageElement.prototype.getFootageData = function () { return this.footageData }; function AudioElement(_, j, $) { this.initFrame(), this.initRenderable(), this.assetData = j.getAssetData(_.refId), this.initBaseData(_, j, $), this._isPlaying = !1, this._canPlay = !1; var _e = this.globalData.getAssetsPath(this.assetData); this.audio = this.globalData.audioController.createAudio(_e), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = _.tm ? PropertyFactory.getProp(this, _.tm, 0, j.frameRate, this) : { _placeholder: !0 }, this.lv = PropertyFactory.getProp(this, _.au && _.au.lv ? _.au.lv : { k: [100] }, 1, .01, this) } AudioElement.prototype.prepareFrame = function (_) { if (this.prepareRenderableFrame(_, !0), this.prepareProperties(_, !0), this.tm._placeholder) this._currentTime = _ / this.data.sr; else { var j = this.tm.v; this._currentTime = j } this._volume = this.lv.v[0]; var $ = this._volume * this._volumeMultiplier; this._previousVolume !== $ && (this._previousVolume = $, this.audio.volume($)) }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () { this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0)) }, AudioElement.prototype.show = function () { }, AudioElement.prototype.hide = function () { this.audio.pause(), this._isPlaying = !1 }, AudioElement.prototype.pause = function () { this.audio.pause(), this._isPlaying = !1, this._canPlay = !1 }, AudioElement.prototype.resume = function () { this._canPlay = !0 }, AudioElement.prototype.setRate = function (_) { this.audio.rate(_) }, AudioElement.prototype.volume = function (_) { this._volumeMultiplier = _, this._previousVolume = _ * this._volume, this.audio.volume(this._previousVolume) }, AudioElement.prototype.getBaseElement = function () { return null }, AudioElement.prototype.destroy = function () { }, AudioElement.prototype.sourceRectAtTime = function () { }, AudioElement.prototype.initExpressions = function () { }; function BaseRenderer() { } BaseRenderer.prototype.checkLayers = function (_) { var j, $ = this.layers.length, _e; for (this.completeLayers = !0, j = $ - 1; j >= 0; j -= 1)this.elements[j] || (_e = this.layers[j], _e.ip - _e.st <= _ - this.layers[j].st && _e.op - _e.st > _ - this.layers[j].st && this.buildItem(j)), this.completeLayers = this.elements[j] ? this.completeLayers : !1; this.checkPendingElements() }, BaseRenderer.prototype.createItem = function (_) { switch (_.ty) { case 2: return this.createImage(_); case 0: return this.createComp(_); case 1: return this.createSolid(_); case 3: return this.createNull(_); case 4: return this.createShape(_); case 5: return this.createText(_); case 6: return this.createAudio(_); case 13: return this.createCamera(_); case 15: return this.createFootage(_); default: return this.createNull(_) } }, BaseRenderer.prototype.createCamera = function () { throw new Error("You're using a 3d camera. Try the html renderer.") }, BaseRenderer.prototype.createAudio = function (_) { return new AudioElement(_, this.globalData, this) }, BaseRenderer.prototype.createFootage = function (_) { return new FootageElement(_, this.globalData, this) }, BaseRenderer.prototype.buildAllItems = function () { var _, j = this.layers.length; for (_ = 0; _ < j; _ += 1)this.buildItem(_); this.checkPendingElements() }, BaseRenderer.prototype.includeLayers = function (_) { this.completeLayers = !1; var j, $ = _.length, _e, et = this.layers.length; for (j = 0; j < $; j += 1)for (_e = 0; _e < et;) { if (this.layers[_e].id === _[j].id) { this.layers[_e] = _[j]; break } _e += 1 } }, BaseRenderer.prototype.setProjectInterface = function (_) { this.globalData.projectInterface = _ }, BaseRenderer.prototype.initItems = function () { this.globalData.progressiveLoad || this.buildAllItems() }, BaseRenderer.prototype.buildElementParenting = function (_, j, $) { for (var _e = this.elements, et = this.layers, tt = 0, rt = et.length; tt < rt;)et[tt].ind == j && (!_e[tt] || _e[tt] === !0 ? (this.buildItem(tt), this.addPendingElement(_)) : ($.push(_e[tt]), _e[tt].setAsParent(), et[tt].parent !== void 0 ? this.buildElementParenting(_, et[tt].parent, $) : _.setHierarchy($))), tt += 1 }, BaseRenderer.prototype.addPendingElement = function (_) { this.pendingElements.push(_) }, BaseRenderer.prototype.searchExtraCompositions = function (_) { var j, $ = _.length; for (j = 0; j < $; j += 1)if (_[j].xt) { var _e = this.createComp(_[j]); _e.initExpressions(), this.globalData.projectInterface.registerComposition(_e) } }, BaseRenderer.prototype.getElementById = function (_) { var j, $ = this.elements.length; for (j = 0; j < $; j += 1)if (this.elements[j].data.ind === _) return this.elements[j]; return null }, BaseRenderer.prototype.getElementByPath = function (_) { var j = _.shift(), $; if (typeof j == "number") $ = this.elements[j]; else { var _e, et = this.elements.length; for (_e = 0; _e < et; _e += 1)if (this.elements[_e].data.nm === j) { $ = this.elements[_e]; break } } return _.length === 0 ? $ : $.getElementByPath(_) }, BaseRenderer.prototype.setupGlobalData = function (_, j) { this.globalData.fontManager = new FontManager, this.globalData.slotManager = slotFactory(_), this.globalData.fontManager.addChars(_.chars), this.globalData.fontManager.addFonts(_.fonts, j), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = _.fr, this.globalData.nm = _.nm, this.globalData.compSize = { w: _.w, h: _.h } }; var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" }; function TransformElement() { } TransformElement.prototype = { initTransform: function () { var j = new Matrix; this.finalTransform = { mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 }, _matMdf: !1, _localMatMdf: !1, _opMdf: !1, mat: j, localMat: j, localOpacity: 1 }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty }, renderTransform: function () { if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) { var j, $ = this.finalTransform.mat, _e = 0, et = this.hierarchy.length; if (!this.finalTransform._matMdf) for (; _e < et;) { if (this.hierarchy[_e].finalTransform.mProp._mdf) { this.finalTransform._matMdf = !0; break } _e += 1 } if (this.finalTransform._matMdf) for (j = this.finalTransform.mProp.v.props, $.cloneFromProps(j), _e = 0; _e < et; _e += 1)$.multiply(this.hierarchy[_e].finalTransform.mProp.v) } this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v) }, renderLocalTransform: function () { if (this.localTransforms) { var j = 0, $ = this.localTransforms.length; if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf) for (; j < $;)this.localTransforms[j]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[j]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), j += 1; if (this.finalTransform._localMatMdf) { var _e = this.finalTransform.localMat; for (this.localTransforms[0].matrix.clone(_e), j = 1; j < $; j += 1) { var et = this.localTransforms[j].matrix; _e.multiply(et) } _e.multiply(this.finalTransform.mat) } if (this.finalTransform._opMdf) { var tt = this.finalTransform.localOpacity; for (j = 0; j < $; j += 1)tt *= this.localTransforms[j].opacity * .01; this.finalTransform.localOpacity = tt } } }, searchEffectTransforms: function () { if (this.renderableEffectsManager) { var j = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT); if (j.length) { this.localTransforms = [], this.finalTransform.localMat = new Matrix; var $ = 0, _e = j.length; for ($ = 0; $ < _e; $ += 1)this.localTransforms.push(j[$]) } } }, globalToLocal: function (j) { var $ = []; $.push(this.finalTransform); for (var _e = !0, et = this.comp; _e;)et.finalTransform ? (et.data.hasMask && $.splice(0, 0, et.finalTransform), et = et.comp) : _e = !1; var tt, rt = $.length, nt; for (tt = 0; tt < rt; tt += 1)nt = $[tt].mat.applyToPointArray(0, 0, 0), j = [j[0] - nt[0], j[1] - nt[1], 0]; return j }, mHelper: new Matrix }; function MaskElement(_, j, $) { this.data = _, this.element = j, this.globalData = $, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null; var _e = this.globalData.defs, et, tt = this.masksProperties ? this.masksProperties.length : 0; this.viewData = createSizedArray(tt), this.solidPath = ""; var rt, nt = this.masksProperties, it = 0, st = [], ot, ft, at = createElementID(), dt, pt, ht, xt, ct = "clipPath", ut = "clip-path"; for (et = 0; et < tt; et += 1)if ((nt[et].mode !== "a" && nt[et].mode !== "n" || nt[et].inv || nt[et].o.k !== 100 || nt[et].o.x) && (ct = "mask", ut = "mask"), (nt[et].mode === "s" || nt[et].mode === "i") && it === 0 ? (dt = createNS("rect"), dt.setAttribute("fill", "#ffffff"), dt.setAttribute("width", this.element.comp.data.w || 0), dt.setAttribute("height", this.element.comp.data.h || 0), st.push(dt)) : dt = null, rt = createNS("path"), nt[et].mode === "n") this.viewData[et] = { op: PropertyFactory.getProp(this.element, nt[et].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, nt[et], 3), elem: rt, lastPath: "" }, _e.appendChild(rt); else { it += 1, rt.setAttribute("fill", nt[et].mode === "s" ? "#000000" : "#ffffff"), rt.setAttribute("clip-rule", "nonzero"); var lt; if (nt[et].x.k !== 0 ? (ct = "mask", ut = "mask", xt = PropertyFactory.getProp(this.element, nt[et].x, 0, null, this.element), lt = createElementID(), pt = createNS("filter"), pt.setAttribute("id", lt), ht = createNS("feMorphology"), ht.setAttribute("operator", "erode"), ht.setAttribute("in", "SourceGraphic"), ht.setAttribute("radius", "0"), pt.appendChild(ht), _e.appendChild(pt), rt.setAttribute("stroke", nt[et].mode === "s" ? "#000000" : "#ffffff")) : (ht = null, xt = null), this.storedData[et] = { elem: rt, x: xt, expan: ht, lastPath: "", lastOperator: "", filterId: lt, lastRadius: 0 }, nt[et].mode === "i") { ft = st.length; var mt = createNS("g"); for (ot = 0; ot < ft; ot += 1)mt.appendChild(st[ot]); var yt = createNS("mask"); yt.setAttribute("mask-type", "alpha"), yt.setAttribute("id", at + "_" + it), yt.appendChild(rt), _e.appendChild(yt), mt.setAttribute("mask", "url(" + getLocationHref() + "#" + at + "_" + it + ")"), st.length = 0, st.push(mt) } else st.push(rt); nt[et].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[et] = { elem: rt, lastPath: "", op: PropertyFactory.getProp(this.element, nt[et].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, nt[et], 3), invRect: dt }, this.viewData[et].prop.k || this.drawPath(nt[et], this.viewData[et].prop.v, this.viewData[et]) } for (this.maskElement = createNS(ct), tt = st.length, et = 0; et < tt; et += 1)this.maskElement.appendChild(st[et]); it > 0 && (this.maskElement.setAttribute("id", at), this.element.maskedElement.setAttribute(ut, "url(" + getLocationHref() + "#" + at + ")"), _e.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this) } MaskElement.prototype.getMaskProperty = function (_) { return this.viewData[_].prop }, MaskElement.prototype.renderFrame = function (_) { var j = this.element.finalTransform.mat, $, _e = this.masksProperties.length; for ($ = 0; $ < _e; $ += 1)if ((this.viewData[$].prop._mdf || _) && this.drawPath(this.masksProperties[$], this.viewData[$].prop.v, this.viewData[$]), (this.viewData[$].op._mdf || _) && this.viewData[$].elem.setAttribute("fill-opacity", this.viewData[$].op.v), this.masksProperties[$].mode !== "n" && (this.viewData[$].invRect && (this.element.finalTransform.mProp._mdf || _) && this.viewData[$].invRect.setAttribute("transform", j.getInverseMatrix().to2dCSS()), this.storedData[$].x && (this.storedData[$].x._mdf || _))) { var et = this.storedData[$].expan; this.storedData[$].x.v < 0 ? (this.storedData[$].lastOperator !== "erode" && (this.storedData[$].lastOperator = "erode", this.storedData[$].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[$].filterId + ")")), et.setAttribute("radius", -this.storedData[$].x.v)) : (this.storedData[$].lastOperator !== "dilate" && (this.storedData[$].lastOperator = "dilate", this.storedData[$].elem.setAttribute("filter", null)), this.storedData[$].elem.setAttribute("stroke-width", this.storedData[$].x.v * 2)) } }, MaskElement.prototype.getMaskelement = function () { return this.maskElement }, MaskElement.prototype.createLayerSolidPath = function () { var _ = "M0,0 "; return _ += " h" + this.globalData.compSize.w, _ += " v" + this.globalData.compSize.h, _ += " h-" + this.globalData.compSize.w, _ += " v-" + this.globalData.compSize.h + " ", _ }, MaskElement.prototype.drawPath = function (_, j, $) { var _e = " M" + j.v[0][0] + "," + j.v[0][1], et, tt; for (tt = j._length, et = 1; et < tt; et += 1)_e += " C" + j.o[et - 1][0] + "," + j.o[et - 1][1] + " " + j.i[et][0] + "," + j.i[et][1] + " " + j.v[et][0] + "," + j.v[et][1]; if (j.c && tt > 1 && (_e += " C" + j.o[et - 1][0] + "," + j.o[et - 1][1] + " " + j.i[0][0] + "," + j.i[0][1] + " " + j.v[0][0] + "," + j.v[0][1]), $.lastPath !== _e) { var rt = ""; $.elem && (j.c && (rt = _.inv ? this.solidPath + _e : _e), $.elem.setAttribute("d", rt)), $.lastPath = _e } }, MaskElement.prototype.destroy = function () { this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null }; var filtersFactory = function () { var _ = {}; _.createFilter = j, _.createAlphaToLuminanceFilter = $; function j(_e, et) { var tt = createNS("filter"); return tt.setAttribute("id", _e), et !== !0 && (tt.setAttribute("filterUnits", "objectBoundingBox"), tt.setAttribute("x", "0%"), tt.setAttribute("y", "0%"), tt.setAttribute("width", "100%"), tt.setAttribute("height", "100%")), tt } function $() { var _e = createNS("feColorMatrix"); return _e.setAttribute("type", "matrix"), _e.setAttribute("color-interpolation-filters", "sRGB"), _e.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), _e } return _ }(), featureSupport = function () { var _ = { maskType: !0, svgLumaHidden: !0, offscreenCanvas: typeof OffscreenCanvas < "u" }; return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (_.maskType = !1), /firefox/i.test(navigator.userAgent) && (_.svgLumaHidden = !1), _ }(), registeredEffects$1 = {}, idPrefix = "filter_result_"; function SVGEffects(_) { var j, $ = "SourceGraphic", _e = _.data.ef ? _.data.ef.length : 0, et = createElementID(), tt = filtersFactory.createFilter(et, !0), rt = 0; this.filters = []; var nt; for (j = 0; j < _e; j += 1) { nt = null; var it = _.data.ef[j].ty; if (registeredEffects$1[it]) { var st = registeredEffects$1[it].effect; nt = new st(tt, _.effectsManager.effectElements[j], _, idPrefix + rt, $), $ = idPrefix + rt, registeredEffects$1[it].countsAsEffect && (rt += 1) } nt && this.filters.push(nt) } rt && (_.globalData.defs.appendChild(tt), _.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + et + ")")), this.filters.length && _.addRenderableComponent(this) } SVGEffects.prototype.renderFrame = function (_) { var j, $ = this.filters.length; for (j = 0; j < $; j += 1)this.filters[j].renderFrame(_) }, SVGEffects.prototype.getEffects = function (_) { var j, $ = this.filters.length, _e = []; for (j = 0; j < $; j += 1)this.filters[j].type === _ && _e.push(this.filters[j]); return _e }; function registerEffect$1(_, j, $) { registeredEffects$1[_] = { effect: j, countsAsEffect: $ } } function SVGBaseElement() { } SVGBaseElement.prototype = { initRendererElement: function () { this.layerElement = createNS("g") }, createContainerElements: function () { this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1; var j = null; if (this.data.td) { this.matteMasks = {}; var $ = createNS("g"); $.setAttribute("id", this.layerId), $.appendChild(this.layerElement), j = $, this.globalData.defs.appendChild($) } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), j = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement; if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) { var _e = createNS("clipPath"), et = createNS("path"); et.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z"); var tt = createElementID(); if (_e.setAttribute("id", tt), _e.appendChild(et), this.globalData.defs.appendChild(_e), this.checkMasks()) { var rt = createNS("g"); rt.setAttribute("clip-path", "url(" + getLocationHref() + "#" + tt + ")"), rt.appendChild(this.layerElement), this.transformedElement = rt, j ? j.appendChild(this.transformedElement) : this.baseElement = this.transformedElement } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + tt + ")") } this.data.bm !== 0 && this.setBlendMode() }, renderElement: function () { this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity) }, destroyBaseElement: function () { this.layerElement = null, this.matteElement = null, this.maskManager.destroy() }, getBaseElement: function () { return this.data.hd ? null : this.baseElement }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms() }, getMatte: function (j) { if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[j]) { var $ = this.layerId + "_" + j, _e, et, tt, rt; if (j === 1 || j === 3) { var nt = createNS("mask"); nt.setAttribute("id", $), nt.setAttribute("mask-type", j === 3 ? "luminance" : "alpha"), tt = createNS("use"), tt.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), nt.appendChild(tt), this.globalData.defs.appendChild(nt), !featureSupport.maskType && j === 1 && (nt.setAttribute("mask-type", "luminance"), _e = createElementID(), et = filtersFactory.createFilter(_e), this.globalData.defs.appendChild(et), et.appendChild(filtersFactory.createAlphaToLuminanceFilter()), rt = createNS("g"), rt.appendChild(tt), nt.appendChild(rt), rt.setAttribute("filter", "url(" + getLocationHref() + "#" + _e + ")")) } else if (j === 2) { var it = createNS("mask"); it.setAttribute("id", $), it.setAttribute("mask-type", "alpha"); var st = createNS("g"); it.appendChild(st), _e = createElementID(), et = filtersFactory.createFilter(_e); var ot = createNS("feComponentTransfer"); ot.setAttribute("in", "SourceGraphic"), et.appendChild(ot); var ft = createNS("feFuncA"); ft.setAttribute("type", "table"), ft.setAttribute("tableValues", "1.0 0.0"), ot.appendChild(ft), this.globalData.defs.appendChild(et); var at = createNS("rect"); at.setAttribute("width", this.comp.data.w), at.setAttribute("height", this.comp.data.h), at.setAttribute("x", "0"), at.setAttribute("y", "0"), at.setAttribute("fill", "#ffffff"), at.setAttribute("opacity", "0"), st.setAttribute("filter", "url(" + getLocationHref() + "#" + _e + ")"), st.appendChild(at), tt = createNS("use"), tt.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), st.appendChild(tt), featureSupport.maskType || (it.setAttribute("mask-type", "luminance"), et.appendChild(filtersFactory.createAlphaToLuminanceFilter()), rt = createNS("g"), st.appendChild(at), rt.appendChild(this.layerElement), st.appendChild(rt)), this.globalData.defs.appendChild(it) } this.matteMasks[j] = $ } return this.matteMasks[j] }, setMatte: function (j) { this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + j + ")") } }; function HierarchyElement() { } HierarchyElement.prototype = { initHierarchy: function () { this.hierarchy = [], this._isParent = !1, this.checkParenting() }, setHierarchy: function (j) { this.hierarchy = j }, setAsParent: function () { this._isParent = !0 }, checkParenting: function () { this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, []) } }; function RenderableDOMElement() { } (function () { var _ = { initElement: function ($, _e, et) { this.initFrame(), this.initBaseData($, _e, et), this.initTransform($, _e, et), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide() }, hide: function () { if (!this.hidden && (!this.isInRange || this.isTransparent)) { var $ = this.baseElement || this.layerElement; $.style.display = "none", this.hidden = !0 } }, show: function () { if (this.isInRange && !this.isTransparent) { if (!this.data.hd) { var $ = this.baseElement || this.layerElement; $.style.display = "block" } this.hidden = !1, this._isFirstFrame = !0 } }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, renderInnerContent: function () { }, prepareFrame: function ($) { this._mdf = !1, this.prepareRenderableFrame($), this.prepareProperties($, this.isInRange), this.checkTransparency() }, destroy: function () { this.innerElem = null, this.destroyBaseElement() } }; extendPrototype([RenderableElement, createProxyFunction(_)], RenderableDOMElement) })(); function IImageElement(_, j, $) { this.assetData = j.getAssetData(_.refId), this.assetData && this.assetData.sid && (this.assetData = j.slotManager.getProp(this.assetData)), this.initElement(_, j, $), this.sourceRect = { top: 0, left: 0, width: this.assetData.w, height: this.assetData.h } } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () { var _ = this.globalData.getAssetsPath(this.assetData); this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", _), this.layerElement.appendChild(this.innerElem) }, IImageElement.prototype.sourceRectAtTime = function () { return this.sourceRect }; function ProcessedElement(_, j) { this.elem = _, this.pos = j } function IShapeElement() { } IShapeElement.prototype = { addShapeToModifiers: function (j) { var $, _e = this.shapeModifiers.length; for ($ = 0; $ < _e; $ += 1)this.shapeModifiers[$].addShape(j) }, isShapeInAnimatedModifiers: function (j) { for (var $ = 0, _e = this.shapeModifiers.length; $ < _e;)if (this.shapeModifiers[$].isAnimatedWithShape(j)) return !0; return !1 }, renderModifiers: function () { if (this.shapeModifiers.length) { var j, $ = this.shapes.length; for (j = 0; j < $; j += 1)this.shapes[j].sh.reset(); $ = this.shapeModifiers.length; var _e; for (j = $ - 1; j >= 0 && (_e = this.shapeModifiers[j].processShapes(this._isFirstFrame), !_e); j -= 1); } }, searchProcessedElement: function (j) { for (var $ = this.processedElements, _e = 0, et = $.length; _e < et;) { if ($[_e].elem === j) return $[_e].pos; _e += 1 } return 0 }, addProcessedElement: function (j, $) { for (var _e = this.processedElements, et = _e.length; et;)if (et -= 1, _e[et].elem === j) { _e[et].pos = $; return } _e.push(new ProcessedElement(j, $)) }, prepareFrame: function (j) { this.prepareRenderableFrame(j), this.prepareProperties(j, this.isInRange) } }; var lineCapEnum = { 1: "butt", 2: "round", 3: "square" }, lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" }; function SVGShapeData(_, j, $) { this.caches = [], this.styles = [], this.transformers = _, this.lStr = "", this.sh = $, this.lvl = j, this._isAnimated = !!$.k; for (var _e = 0, et = _.length; _e < et;) { if (_[_e].mProps.dynamicProperties.length) { this._isAnimated = !0; break } _e += 1 } } SVGShapeData.prototype.setAsAnimated = function () { this._isAnimated = !0 }; function SVGStyleData(_, j) { this.data = _, this.type = _.ty, this.d = "", this.lvl = j, this._mdf = !1, this.closed = _.hd === !0, this.pElem = createNS("path"), this.msElem = null } SVGStyleData.prototype.reset = function () { this.d = "", this._mdf = !1 }; function DashProperty(_, j, $, _e) { this.elem = _, this.frameId = -1, this.dataProps = createSizedArray(j.length), this.renderer = $, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", j.length ? j.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(_e); var et, tt = j.length || 0, rt; for (et = 0; et < tt; et += 1)rt = PropertyFactory.getProp(_, j[et].v, 0, 0, this), this.k = rt.k || this.k, this.dataProps[et] = { n: j[et].n, p: rt }; this.k || this.getValue(!0), this._isAnimated = this.k } DashProperty.prototype.getValue = function (_) { if (!(this.elem.globalData.frameId === this.frameId && !_) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || _, this._mdf)) { var j = 0, $ = this.dataProps.length; for (this.renderer === "svg" && (this.dashStr = ""), j = 0; j < $; j += 1)this.dataProps[j].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[j].p.v : this.dashArray[j] = this.dataProps[j].p.v : this.dashoffset[0] = this.dataProps[j].p.v } }, extendPrototype([DynamicPropertyContainer], DashProperty); function SVGStrokeStyleData(_, j, $) { this.initDynamicPropertyContainer(_), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(_, j.o, 0, .01, this), this.w = PropertyFactory.getProp(_, j.w, 0, null, this), this.d = new DashProperty(_, j.d || {}, "svg", this), this.c = PropertyFactory.getProp(_, j.c, 1, 255, this), this.style = $, this._isAnimated = !!this._isAnimated } extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData); function SVGFillStyleData(_, j, $) { this.initDynamicPropertyContainer(_), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(_, j.o, 0, .01, this), this.c = PropertyFactory.getProp(_, j.c, 1, 255, this), this.style = $ } extendPrototype([DynamicPropertyContainer], SVGFillStyleData); function SVGNoStyleData(_, j, $) { this.initDynamicPropertyContainer(_), this.getValue = this.iterateDynamicProperties, this.style = $ } extendPrototype([DynamicPropertyContainer], SVGNoStyleData); function GradientProperty(_, j, $) { this.data = j, this.c = createTypedArray("uint8c", j.p * 4); var _e = j.k.k[0].s ? j.k.k[0].s.length - j.p * 4 : j.k.k.length - j.p * 4; this.o = createTypedArray("float32", _e), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = _e, this.initDynamicPropertyContainer($), this.prop = PropertyFactory.getProp(_, j.k, 1, null, this), this.k = this.prop.k, this.getValue(!0) } GradientProperty.prototype.comparePoints = function (_, j) { for (var $ = 0, _e = this.o.length / 2, et; $ < _e;) { if (et = Math.abs(_[$ * 4] - _[j * 4 + $ * 2]), et > .01) return !1; $ += 1 } return !0 }, GradientProperty.prototype.checkCollapsable = function () { if (this.o.length / 2 !== this.c.length / 4) return !1; if (this.data.k.k[0].s) for (var _ = 0, j = this.data.k.k.length; _ < j;) { if (!this.comparePoints(this.data.k.k[_].s, this.data.p)) return !1; _ += 1 } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1; return !0 }, GradientProperty.prototype.getValue = function (_) { if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || _) { var j, $ = this.data.p * 4, _e, et; for (j = 0; j < $; j += 1)_e = j % 4 === 0 ? 100 : 255, et = Math.round(this.prop.v[j] * _e), this.c[j] !== et && (this.c[j] = et, this._cmdf = !_); if (this.o.length) for ($ = this.prop.v.length, j = this.data.p * 4; j < $; j += 1)_e = j % 2 === 0 ? 100 : 1, et = j % 2 === 0 ? Math.round(this.prop.v[j] * 100) : this.prop.v[j], this.o[j - this.data.p * 4] !== et && (this.o[j - this.data.p * 4] = et, this._omdf = !_); this._mdf = !_ } }, extendPrototype([DynamicPropertyContainer], GradientProperty); function SVGGradientFillStyleData(_, j, $) { this.initDynamicPropertyContainer(_), this.getValue = this.iterateDynamicProperties, this.initGradientData(_, j, $) } SVGGradientFillStyleData.prototype.initGradientData = function (_, j, $) { this.o = PropertyFactory.getProp(_, j.o, 0, .01, this), this.s = PropertyFactory.getProp(_, j.s, 1, null, this), this.e = PropertyFactory.getProp(_, j.e, 1, null, this), this.h = PropertyFactory.getProp(_, j.h || { k: 0 }, 0, .01, this), this.a = PropertyFactory.getProp(_, j.a || { k: 0 }, 0, degToRads, this), this.g = new GradientProperty(_, j.g, this), this.style = $, this.stops = [], this.setGradientData($.pElem, j), this.setGradientOpacity(j, $), this._isAnimated = !!this._isAnimated }, SVGGradientFillStyleData.prototype.setGradientData = function (_, j) { var $ = createElementID(), _e = createNS(j.t === 1 ? "linearGradient" : "radialGradient"); _e.setAttribute("id", $), _e.setAttribute("spreadMethod", "pad"), _e.setAttribute("gradientUnits", "userSpaceOnUse"); var et = [], tt, rt, nt; for (nt = j.g.p * 4, rt = 0; rt < nt; rt += 4)tt = createNS("stop"), _e.appendChild(tt), et.push(tt); _.setAttribute(j.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + $ + ")"), this.gf = _e, this.cst = et }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (_, j) { if (this.g._hasOpacity && !this.g._collapsable) { var $, _e, et, tt = createNS("mask"), rt = createNS("path"); tt.appendChild(rt); var nt = createElementID(), it = createElementID(); tt.setAttribute("id", it); var st = createNS(_.t === 1 ? "linearGradient" : "radialGradient"); st.setAttribute("id", nt), st.setAttribute("spreadMethod", "pad"), st.setAttribute("gradientUnits", "userSpaceOnUse"), et = _.g.k.k[0].s ? _.g.k.k[0].s.length : _.g.k.k.length; var ot = this.stops; for (_e = _.g.p * 4; _e < et; _e += 2)$ = createNS("stop"), $.setAttribute("stop-color", "rgb(255,255,255)"), st.appendChild($), ot.push($); rt.setAttribute(_.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + nt + ")"), _.ty === "gs" && (rt.setAttribute("stroke-linecap", lineCapEnum[_.lc || 2]), rt.setAttribute("stroke-linejoin", lineJoinEnum[_.lj || 2]), _.lj === 1 && rt.setAttribute("stroke-miterlimit", _.ml)), this.of = st, this.ms = tt, this.ost = ot, this.maskId = it, j.msElem = rt } }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData); function SVGGradientStrokeStyleData(_, j, $) { this.initDynamicPropertyContainer(_), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(_, j.w, 0, null, this), this.d = new DashProperty(_, j.d || {}, "svg", this), this.initGradientData(_, j, $), this._isAnimated = !!this._isAnimated } extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData); function ShapeGroupData() { this.it = [], this.prevViewData = [], this.gr = createNS("g") } function SVGTransformData(_, j, $) { this.transform = { mProps: _, op: j, container: $ }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length } var buildShapeString = function (j, $, _e, et) { if ($ === 0) return ""; var tt = j.o, rt = j.i, nt = j.v, it, st = " M" + et.applyToPointStringified(nt[0][0], nt[0][1]); for (it = 1; it < $; it += 1)st += " C" + et.applyToPointStringified(tt[it - 1][0], tt[it - 1][1]) + " " + et.applyToPointStringified(rt[it][0], rt[it][1]) + " " + et.applyToPointStringified(nt[it][0], nt[it][1]); return _e && $ && (st += " C" + et.applyToPointStringified(tt[it - 1][0], tt[it - 1][1]) + " " + et.applyToPointStringified(rt[0][0], rt[0][1]) + " " + et.applyToPointStringified(nt[0][0], nt[0][1]), st += "z"), st }, SVGElementsRenderer = function () { var _ = new Matrix, j = new Matrix, $ = { createRenderFunction: _e }; function _e(ft) { switch (ft.ty) { case "fl": return nt; case "gf": return st; case "gs": return it; case "st": return ot; case "sh": case "el": case "rc": case "sr": return rt; case "tr": return et; case "no": return tt; default: return null } } function et(ft, at, dt) { (dt || at.transform.op._mdf) && at.transform.container.setAttribute("opacity", at.transform.op.v), (dt || at.transform.mProps._mdf) && at.transform.container.setAttribute("transform", at.transform.mProps.v.to2dCSS()) } function tt() { } function rt(ft, at, dt) { var pt, ht, xt, ct, ut, lt, mt = at.styles.length, yt = at.lvl, gt, St, bt, _t; for (lt = 0; lt < mt; lt += 1) { if (ct = at.sh._mdf || dt, at.styles[lt].lvl < yt) { for (St = j.reset(), bt = yt - at.styles[lt].lvl, _t = at.transformers.length - 1; !ct && bt > 0;)ct = at.transformers[_t].mProps._mdf || ct, bt -= 1, _t -= 1; if (ct) for (bt = yt - at.styles[lt].lvl, _t = at.transformers.length - 1; bt > 0;)St.multiply(at.transformers[_t].mProps.v), bt -= 1, _t -= 1 } else St = _; if (gt = at.sh.paths, ht = gt._length, ct) { for (xt = "", pt = 0; pt < ht; pt += 1)ut = gt.shapes[pt], ut && ut._length && (xt += buildShapeString(ut, ut._length, ut.c, St)); at.caches[lt] = xt } else xt = at.caches[lt]; at.styles[lt].d += ft.hd === !0 ? "" : xt, at.styles[lt]._mdf = ct || at.styles[lt]._mdf } } function nt(ft, at, dt) { var pt = at.style; (at.c._mdf || dt) && pt.pElem.setAttribute("fill", "rgb(" + bmFloor(at.c.v[0]) + "," + bmFloor(at.c.v[1]) + "," + bmFloor(at.c.v[2]) + ")"), (at.o._mdf || dt) && pt.pElem.setAttribute("fill-opacity", at.o.v) } function it(ft, at, dt) { st(ft, at, dt), ot(ft, at, dt) } function st(ft, at, dt) { var pt = at.gf, ht = at.g._hasOpacity, xt = at.s.v, ct = at.e.v; if (at.o._mdf || dt) { var ut = ft.ty === "gf" ? "fill-opacity" : "stroke-opacity"; at.style.pElem.setAttribute(ut, at.o.v) } if (at.s._mdf || dt) { var lt = ft.t === 1 ? "x1" : "cx", mt = lt === "x1" ? "y1" : "cy"; pt.setAttribute(lt, xt[0]), pt.setAttribute(mt, xt[1]), ht && !at.g._collapsable && (at.of.setAttribute(lt, xt[0]), at.of.setAttribute(mt, xt[1])) } var yt, gt, St, bt; if (at.g._cmdf || dt) { yt = at.cst; var _t = at.g.c; for (St = yt.length, gt = 0; gt < St; gt += 1)bt = yt[gt], bt.setAttribute("offset", _t[gt * 4] + "%"), bt.setAttribute("stop-color", "rgb(" + _t[gt * 4 + 1] + "," + _t[gt * 4 + 2] + "," + _t[gt * 4 + 3] + ")") } if (ht && (at.g._omdf || dt)) { var Mt = at.g.o; for (at.g._collapsable ? yt = at.cst : yt = at.ost, St = yt.length, gt = 0; gt < St; gt += 1)bt = yt[gt], at.g._collapsable || bt.setAttribute("offset", Mt[gt * 2] + "%"), bt.setAttribute("stop-opacity", Mt[gt * 2 + 1]) } if (ft.t === 1) (at.e._mdf || dt) && (pt.setAttribute("x2", ct[0]), pt.setAttribute("y2", ct[1]), ht && !at.g._collapsable && (at.of.setAttribute("x2", ct[0]), at.of.setAttribute("y2", ct[1]))); else { var It; if ((at.s._mdf || at.e._mdf || dt) && (It = Math.sqrt(Math.pow(xt[0] - ct[0], 2) + Math.pow(xt[1] - ct[1], 2)), pt.setAttribute("r", It), ht && !at.g._collapsable && at.of.setAttribute("r", It)), at.e._mdf || at.h._mdf || at.a._mdf || dt) { It || (It = Math.sqrt(Math.pow(xt[0] - ct[0], 2) + Math.pow(xt[1] - ct[1], 2))); var Rt = Math.atan2(ct[1] - xt[1], ct[0] - xt[0]), Lt = at.h.v; Lt >= 1 ? Lt = .99 : Lt <= -1 && (Lt = -.99); var Vt = It * Lt, At = Math.cos(Rt + at.a.v) * Vt + xt[0], Pt = Math.sin(Rt + at.a.v) * Vt + xt[1]; pt.setAttribute("fx", At), pt.setAttribute("fy", Pt), ht && !at.g._collapsable && (at.of.setAttribute("fx", At), at.of.setAttribute("fy", Pt)) } } } function ot(ft, at, dt) { var pt = at.style, ht = at.d; ht && (ht._mdf || dt) && ht.dashStr && (pt.pElem.setAttribute("stroke-dasharray", ht.dashStr), pt.pElem.setAttribute("stroke-dashoffset", ht.dashoffset[0])), at.c && (at.c._mdf || dt) && pt.pElem.setAttribute("stroke", "rgb(" + bmFloor(at.c.v[0]) + "," + bmFloor(at.c.v[1]) + "," + bmFloor(at.c.v[2]) + ")"), (at.o._mdf || dt) && pt.pElem.setAttribute("stroke-opacity", at.o.v), (at.w._mdf || dt) && (pt.pElem.setAttribute("stroke-width", at.w.v), pt.msElem && pt.msElem.setAttribute("stroke-width", at.w.v)) } return $ }(); function SVGShapeElement(_, j, $) { this.shapes = [], this.shapesData = _.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(_, j, $), this.prevViewData = [] } extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () { }, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () { }, SVGShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes() }, SVGShapeElement.prototype.filterUniqueShapes = function () { var _, j = this.shapes.length, $, _e, et = this.stylesList.length, tt, rt = [], nt = !1; for (_e = 0; _e < et; _e += 1) { for (tt = this.stylesList[_e], nt = !1, rt.length = 0, _ = 0; _ < j; _ += 1)$ = this.shapes[_], $.styles.indexOf(tt) !== -1 && (rt.push($), nt = $._isAnimated || nt); rt.length > 1 && nt && this.setShapesAsAnimated(rt) } }, SVGShapeElement.prototype.setShapesAsAnimated = function (_) { var j, $ = _.length; for (j = 0; j < $; j += 1)_[j].setAsAnimated() }, SVGShapeElement.prototype.createStyleElement = function (_, j) { var $, _e = new SVGStyleData(_, j), et = _e.pElem; if (_.ty === "st") $ = new SVGStrokeStyleData(this, _, _e); else if (_.ty === "fl") $ = new SVGFillStyleData(this, _, _e); else if (_.ty === "gf" || _.ty === "gs") { var tt = _.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData; $ = new tt(this, _, _e), this.globalData.defs.appendChild($.gf), $.maskId && (this.globalData.defs.appendChild($.ms), this.globalData.defs.appendChild($.of), et.setAttribute("mask", "url(" + getLocationHref() + "#" + $.maskId + ")")) } else _.ty === "no" && ($ = new SVGNoStyleData(this, _, _e)); return (_.ty === "st" || _.ty === "gs") && (et.setAttribute("stroke-linecap", lineCapEnum[_.lc || 2]), et.setAttribute("stroke-linejoin", lineJoinEnum[_.lj || 2]), et.setAttribute("fill-opacity", "0"), _.lj === 1 && et.setAttribute("stroke-miterlimit", _.ml)), _.r === 2 && et.setAttribute("fill-rule", "evenodd"), _.ln && et.setAttribute("id", _.ln), _.cl && et.setAttribute("class", _.cl), _.bm && (et.style["mix-blend-mode"] = getBlendMode(_.bm)), this.stylesList.push(_e), this.addToAnimatedContents(_, $), $ }, SVGShapeElement.prototype.createGroupElement = function (_) { var j = new ShapeGroupData; return _.ln && j.gr.setAttribute("id", _.ln), _.cl && j.gr.setAttribute("class", _.cl), _.bm && (j.gr.style["mix-blend-mode"] = getBlendMode(_.bm)), j }, SVGShapeElement.prototype.createTransformElement = function (_, j) { var $ = TransformPropertyFactory.getTransformProperty(this, _, this), _e = new SVGTransformData($, $.o, j); return this.addToAnimatedContents(_, _e), _e }, SVGShapeElement.prototype.createShapeElement = function (_, j, $) { var _e = 4; _.ty === "rc" ? _e = 5 : _.ty === "el" ? _e = 6 : _.ty === "sr" && (_e = 7); var et = ShapePropertyFactory.getShapeProp(this, _, _e, this), tt = new SVGShapeData(j, $, et); return this.shapes.push(tt), this.addShapeToModifiers(tt), this.addToAnimatedContents(_, tt), tt }, SVGShapeElement.prototype.addToAnimatedContents = function (_, j) { for (var $ = 0, _e = this.animatedContents.length; $ < _e;) { if (this.animatedContents[$].element === j) return; $ += 1 } this.animatedContents.push({ fn: SVGElementsRenderer.createRenderFunction(_), element: j, data: _ }) }, SVGShapeElement.prototype.setElementStyles = function (_) { var j = _.styles, $, _e = this.stylesList.length; for ($ = 0; $ < _e; $ += 1)this.stylesList[$].closed || j.push(this.stylesList[$]) }, SVGShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; var _, j = this.itemsData.length; for (_ = 0; _ < j; _ += 1)this.prevViewData[_] = this.itemsData[_]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), j = this.dynamicProperties.length, _ = 0; _ < j; _ += 1)this.dynamicProperties[_].getValue(); this.renderModifiers() }, SVGShapeElement.prototype.searchShapes = function (_, j, $, _e, et, tt, rt) { var nt = [].concat(tt), it, st = _.length - 1, ot, ft, at = [], dt = [], pt, ht, xt; for (it = st; it >= 0; it -= 1) { if (xt = this.searchProcessedElement(_[it]), xt ? j[it] = $[xt - 1] : _[it]._render = rt, _[it].ty === "fl" || _[it].ty === "st" || _[it].ty === "gf" || _[it].ty === "gs" || _[it].ty === "no") xt ? j[it].style.closed = !1 : j[it] = this.createStyleElement(_[it], et), _[it]._render && j[it].style.pElem.parentNode !== _e && _e.appendChild(j[it].style.pElem), at.push(j[it].style); else if (_[it].ty === "gr") { if (!xt) j[it] = this.createGroupElement(_[it]); else for (ft = j[it].it.length, ot = 0; ot < ft; ot += 1)j[it].prevViewData[ot] = j[it].it[ot]; this.searchShapes(_[it].it, j[it].it, j[it].prevViewData, j[it].gr, et + 1, nt, rt), _[it]._render && j[it].gr.parentNode !== _e && _e.appendChild(j[it].gr) } else _[it].ty === "tr" ? (xt || (j[it] = this.createTransformElement(_[it], _e)), pt = j[it].transform, nt.push(pt)) : _[it].ty === "sh" || _[it].ty === "rc" || _[it].ty === "el" || _[it].ty === "sr" ? (xt || (j[it] = this.createShapeElement(_[it], nt, et)), this.setElementStyles(j[it])) : _[it].ty === "tm" || _[it].ty === "rd" || _[it].ty === "ms" || _[it].ty === "pb" || _[it].ty === "zz" || _[it].ty === "op" ? (xt ? (ht = j[it], ht.closed = !1) : (ht = ShapeModifiers.getModifier(_[it].ty), ht.init(this, _[it]), j[it] = ht, this.shapeModifiers.push(ht)), dt.push(ht)) : _[it].ty === "rp" && (xt ? (ht = j[it], ht.closed = !0) : (ht = ShapeModifiers.getModifier(_[it].ty), j[it] = ht, ht.init(this, _, it, j), this.shapeModifiers.push(ht), rt = !1), dt.push(ht)); this.addProcessedElement(_[it], it + 1) } for (st = at.length, it = 0; it < st; it += 1)at[it].closed = !0; for (st = dt.length, it = 0; it < st; it += 1)dt[it].closed = !0 }, SVGShapeElement.prototype.renderInnerContent = function () { this.renderModifiers(); var _, j = this.stylesList.length; for (_ = 0; _ < j; _ += 1)this.stylesList[_].reset(); for (this.renderShape(), _ = 0; _ < j; _ += 1)(this.stylesList[_]._mdf || this._isFirstFrame) && (this.stylesList[_].msElem && (this.stylesList[_].msElem.setAttribute("d", this.stylesList[_].d), this.stylesList[_].d = "M0 0" + this.stylesList[_].d), this.stylesList[_].pElem.setAttribute("d", this.stylesList[_].d || "M0 0")) }, SVGShapeElement.prototype.renderShape = function () { var _, j = this.animatedContents.length, $; for (_ = 0; _ < j; _ += 1)$ = this.animatedContents[_], (this._isFirstFrame || $.element._isAnimated) && $.data !== !0 && $.fn($.data, $.element, this._isFirstFrame) }, SVGShapeElement.prototype.destroy = function () { this.destroyBaseElement(), this.shapesData = null, this.itemsData = null }; function LetterProps(_, j, $, _e, et, tt) { this.o = _, this.sw = j, this.sc = $, this.fc = _e, this.m = et, this.p = tt, this._mdf = { o: !0, sw: !!j, sc: !!$, fc: !!_e, m: !0, p: !0 } } LetterProps.prototype.update = function (_, j, $, _e, et, tt) { this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1; var rt = !1; return this.o !== _ && (this.o = _, this._mdf.o = !0, rt = !0), this.sw !== j && (this.sw = j, this._mdf.sw = !0, rt = !0), this.sc !== $ && (this.sc = $, this._mdf.sc = !0, rt = !0), this.fc !== _e && (this.fc = _e, this._mdf.fc = !0, rt = !0), this.m !== et && (this.m = et, this._mdf.m = !0, rt = !0), tt.length && (this.p[0] !== tt[0] || this.p[1] !== tt[1] || this.p[4] !== tt[4] || this.p[5] !== tt[5] || this.p[12] !== tt[12] || this.p[13] !== tt[13]) && (this.p = tt, this._mdf.p = !0, rt = !0), rt }; function TextProperty(_, j) { this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, j.d && j.d.sid && (j.d = _.globalData.slotManager.getProp(j.d)), this.data = j, this.elem = _, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = { ascent: 0, boxWidth: this.defaultBoxWidth, f: "", fStyle: "", fWeight: "", fc: "", j: "", justifyOffset: "", l: [], lh: 0, lineWidths: [], ls: "", of: "", s: "", sc: "", sw: 0, t: 0, tr: 0, sz: 0, ps: null, fillColorAnim: !1, strokeColorAnim: !1, strokeWidthAnim: !1, yOffset: 0, finalSize: 0, finalText: [], finalLineHeight: 0, __complete: !1 }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData) } TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (_, j) { for (var $ in j) Object.prototype.hasOwnProperty.call(j, $) && (_[$] = j[$]); return _ }, TextProperty.prototype.setCurrentData = function (_) { _.__complete || this.completeTextData(_), this.currentData = _, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0 }, TextProperty.prototype.searchProperty = function () { return this.searchKeyframes() }, TextProperty.prototype.searchKeyframes = function () { return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf }, TextProperty.prototype.addEffect = function (_) { this.effectsSequence.push(_), this.elem.addDynamicProperty(this) }, TextProperty.prototype.getValue = function (_) { if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_)) { this.currentData.t = this.data.d.k[this.keysIndex].s.t; var j = this.currentData, $ = this.keysIndex; if (this.lock) { this.setCurrentData(this.currentData); return } this.lock = !0, this._mdf = !1; var _e, et = this.effectsSequence.length, tt = _ || this.data.d.k[this.keysIndex].s; for (_e = 0; _e < et; _e += 1)$ !== this.keysIndex ? tt = this.effectsSequence[_e](tt, tt.t) : tt = this.effectsSequence[_e](this.currentData, tt.t); j !== tt && this.setCurrentData(tt), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId } }, TextProperty.prototype.getKeyframeValue = function () { for (var _ = this.data.d.k, j = this.elem.comp.renderedFrame, $ = 0, _e = _.length; $ <= _e - 1 && !($ === _e - 1 || _[$ + 1].t > j);)$ += 1; return this.keysIndex !== $ && (this.keysIndex = $), this.data.d.k[this.keysIndex].s }, TextProperty.prototype.buildFinalText = function (_) { for (var j = [], $ = 0, _e = _.length, et, tt, rt = !1, nt = !1, it = ""; $ < _e;)rt = nt, nt = !1, et = _.charCodeAt($), it = _.charAt($), FontManager.isCombinedCharacter(et) ? rt = !0 : et >= 55296 && et <= 56319 ? FontManager.isRegionalFlag(_, $) ? it = _.substr($, 14) : (tt = _.charCodeAt($ + 1), tt >= 56320 && tt <= 57343 && (FontManager.isModifier(et, tt) ? (it = _.substr($, 2), rt = !0) : FontManager.isFlagEmoji(_.substr($, 4)) ? it = _.substr($, 4) : it = _.substr($, 2))) : et > 56319 ? (tt = _.charCodeAt($ + 1), FontManager.isVariationSelector(et) && (rt = !0)) : FontManager.isZeroWidthJoiner(et) && (rt = !0, nt = !0), rt ? (j[j.length - 1] += it, rt = !1) : j.push(it), $ += it.length; return j }, TextProperty.prototype.completeTextData = function (_) { _.__complete = !0; var j = this.elem.globalData.fontManager, $ = this.data, _e = [], et, tt, rt, nt = 0, it, st = $.m.g, ot = 0, ft = 0, at = 0, dt = [], pt = 0, ht = 0, xt, ct, ut = j.getFontByName(_.f), lt, mt = 0, yt = getFontProperties(ut); _.fWeight = yt.weight, _.fStyle = yt.style, _.finalSize = _.s, _.finalText = this.buildFinalText(_.t), tt = _.finalText.length, _.finalLineHeight = _.lh; var gt = _.tr / 1e3 * _.finalSize, St; if (_.sz) for (var bt = !0, _t = _.sz[0], Mt = _.sz[1], It, Rt; bt;) { Rt = this.buildFinalText(_.t), It = 0, pt = 0, tt = Rt.length, gt = _.tr / 1e3 * _.finalSize; var Lt = -1; for (et = 0; et < tt; et += 1)St = Rt[et].charCodeAt(0), rt = !1, Rt[et] === " " ? Lt = et : (St === 13 || St === 3) && (pt = 0, rt = !0, It += _.finalLineHeight || _.finalSize * 1.2), j.chars ? (lt = j.getCharData(Rt[et], ut.fStyle, ut.fFamily), mt = rt ? 0 : lt.w * _.finalSize / 100) : mt = j.measureText(Rt[et], _.f, _.finalSize), pt + mt > _t && Rt[et] !== " " ? (Lt === -1 ? tt += 1 : et = Lt, It += _.finalLineHeight || _.finalSize * 1.2, Rt.splice(et, Lt === et ? 1 : 0, "\r"), Lt = -1, pt = 0) : (pt += mt, pt += gt); It += ut.ascent * _.finalSize / 100, this.canResize && _.finalSize > this.minimumFontSize && Mt < It ? (_.finalSize -= 1, _.finalLineHeight = _.finalSize * _.lh / _.s) : (_.finalText = Rt, tt = _.finalText.length, bt = !1) } pt = -gt, mt = 0; var Vt = 0, At; for (et = 0; et < tt; et += 1)if (rt = !1, At = _.finalText[et], St = At.charCodeAt(0), St === 13 || St === 3 ? (Vt = 0, dt.push(pt), ht = pt > ht ? pt : ht, pt = -2 * gt, it = "", rt = !0, at += 1) : it = At, j.chars ? (lt = j.getCharData(At, ut.fStyle, j.getFontByName(_.f).fFamily), mt = rt ? 0 : lt.w * _.finalSize / 100) : mt = j.measureText(it, _.f, _.finalSize), At === " " ? Vt += mt + gt : (pt += mt + gt + Vt, Vt = 0), _e.push({ l: mt, an: mt, add: ot, n: rt, anIndexes: [], val: it, line: at, animatorJustifyOffset: 0 }), st == 2) { if (ot += mt, it === "" || it === " " || et === tt - 1) { for ((it === "" || it === " ") && (ot -= mt); ft <= et;)_e[ft].an = ot, _e[ft].ind = nt, _e[ft].extra = mt, ft += 1; nt += 1, ot = 0 } } else if (st == 3) { if (ot += mt, it === "" || et === tt - 1) { for (it === "" && (ot -= mt); ft <= et;)_e[ft].an = ot, _e[ft].ind = nt, _e[ft].extra = mt, ft += 1; ot = 0, nt += 1 } } else _e[nt].ind = nt, _e[nt].extra = 0, nt += 1; if (_.l = _e, ht = pt > ht ? pt : ht, dt.push(pt), _.sz) _.boxWidth = _.sz[0], _.justifyOffset = 0; else switch (_.boxWidth = ht, _.j) { case 1: _.justifyOffset = -_.boxWidth; break; case 2: _.justifyOffset = -_.boxWidth / 2; break; default: _.justifyOffset = 0 }_.lineWidths = dt; var Pt = $.a, kt, vt; ct = Pt.length; var Et, Ct, wt = []; for (xt = 0; xt < ct; xt += 1) { for (kt = Pt[xt], kt.a.sc && (_.strokeColorAnim = !0), kt.a.sw && (_.strokeWidthAnim = !0), (kt.a.fc || kt.a.fh || kt.a.fs || kt.a.fb) && (_.fillColorAnim = !0), Ct = 0, Et = kt.s.b, et = 0; et < tt; et += 1)vt = _e[et], vt.anIndexes[xt] = Ct, (Et == 1 && vt.val !== "" || Et == 2 && vt.val !== "" && vt.val !== " " || Et == 3 && (vt.n || vt.val == " " || et == tt - 1) || Et == 4 && (vt.n || et == tt - 1)) && (kt.s.rn === 1 && wt.push(Ct), Ct += 1); $.a[xt].s.totalChars = Ct; var Tt = -1, jt; if (kt.s.rn === 1) for (et = 0; et < tt; et += 1)vt = _e[et], Tt != vt.anIndexes[xt] && (Tt = vt.anIndexes[xt], jt = wt.splice(Math.floor(Math.random() * wt.length), 1)[0]), vt.anIndexes[xt] = jt } _.yOffset = _.finalLineHeight || _.finalSize * 1.2, _.ls = _.ls || 0, _.ascent = ut.ascent * _.finalSize / 100 }, TextProperty.prototype.updateDocumentData = function (_, j) { j = j === void 0 ? this.keysIndex : j; var $ = this.copyData({}, this.data.d.k[j].s); $ = this.copyData($, _), this.data.d.k[j].s = $, this.recalculate(j), this.setCurrentData($), this.elem.addDynamicProperty(this) }, TextProperty.prototype.recalculate = function (_) { var j = this.data.d.k[_].s; j.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(j) }, TextProperty.prototype.canResizeFont = function (_) { this.canResize = _, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }, TextProperty.prototype.setMinimumFontSize = function (_) { this.minimumFontSize = Math.floor(_) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }; var TextSelectorProp = function () { var _ = Math.max, j = Math.min, $ = Math.floor; function _e(tt, rt) { this._currentTextLength = -1, this.k = !1, this.data = rt, this.elem = tt, this.comp = tt.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(tt), this.s = PropertyFactory.getProp(tt, rt.s || { k: 0 }, 0, 0, this), "e" in rt ? this.e = PropertyFactory.getProp(tt, rt.e, 0, 0, this) : this.e = { v: 100 }, this.o = PropertyFactory.getProp(tt, rt.o || { k: 0 }, 0, 0, this), this.xe = PropertyFactory.getProp(tt, rt.xe || { k: 0 }, 0, 0, this), this.ne = PropertyFactory.getProp(tt, rt.ne || { k: 0 }, 0, 0, this), this.sm = PropertyFactory.getProp(tt, rt.sm || { k: 100 }, 0, 0, this), this.a = PropertyFactory.getProp(tt, rt.a, 0, .01, this), this.dynamicProperties.length || this.getValue() } _e.prototype = { getMult: function (rt) { this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue(); var nt = 0, it = 0, st = 1, ot = 1; this.ne.v > 0 ? nt = this.ne.v / 100 : it = -this.ne.v / 100, this.xe.v > 0 ? st = 1 - this.xe.v / 100 : ot = 1 + this.xe.v / 100; var ft = BezierFactory.getBezierEasing(nt, it, st, ot).get, at = 0, dt = this.finalS, pt = this.finalE, ht = this.data.sh; if (ht === 2) pt === dt ? at = rt >= pt ? 1 : 0 : at = _(0, j(.5 / (pt - dt) + (rt - dt) / (pt - dt), 1)), at = ft(at); else if (ht === 3) pt === dt ? at = rt >= pt ? 0 : 1 : at = 1 - _(0, j(.5 / (pt - dt) + (rt - dt) / (pt - dt), 1)), at = ft(at); else if (ht === 4) pt === dt ? at = 0 : (at = _(0, j(.5 / (pt - dt) + (rt - dt) / (pt - dt), 1)), at < .5 ? at *= 2 : at = 1 - 2 * (at - .5)), at = ft(at); else if (ht === 5) { if (pt === dt) at = 0; else { var xt = pt - dt; rt = j(_(0, rt + .5 - dt), pt - dt); var ct = -xt / 2 + rt, ut = xt / 2; at = Math.sqrt(1 - ct * ct / (ut * ut)) } at = ft(at) } else ht === 6 ? (pt === dt ? at = 0 : (rt = j(_(0, rt + .5 - dt), pt - dt), at = (1 + Math.cos(Math.PI + Math.PI * 2 * rt / (pt - dt))) / 2), at = ft(at)) : (rt >= $(dt) && (rt - dt < 0 ? at = _(0, j(j(pt, 1) - (dt - rt), 1)) : at = _(0, j(pt - rt, 1))), at = ft(at)); if (this.sm.v !== 100) { var lt = this.sm.v * .01; lt === 0 && (lt = 1e-8); var mt = .5 - lt * .5; at < mt ? at = 0 : (at = (at - mt) / lt, at > 1 && (at = 1)) } return at * this.a.v }, getValue: function (rt) { this.iterateDynamicProperties(), this._mdf = rt || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, rt && this.data.r === 2 && (this.e.v = this._currentTextLength); var nt = this.data.r === 2 ? 1 : 100 / this.data.totalChars, it = this.o.v / nt, st = this.s.v / nt + it, ot = this.e.v / nt + it; if (st > ot) { var ft = st; st = ot, ot = ft } this.finalS = st, this.finalE = ot } }, extendPrototype([DynamicPropertyContainer], _e); function et(tt, rt, nt) { return new _e(tt, rt) } return { getTextSelectorProp: et } }(); function TextAnimatorDataProperty(_, j, $) { var _e = { propType: !1 }, et = PropertyFactory.getProp, tt = j.a; this.a = { r: tt.r ? et(_, tt.r, 0, degToRads, $) : _e, rx: tt.rx ? et(_, tt.rx, 0, degToRads, $) : _e, ry: tt.ry ? et(_, tt.ry, 0, degToRads, $) : _e, sk: tt.sk ? et(_, tt.sk, 0, degToRads, $) : _e, sa: tt.sa ? et(_, tt.sa, 0, degToRads, $) : _e, s: tt.s ? et(_, tt.s, 1, .01, $) : _e, a: tt.a ? et(_, tt.a, 1, 0, $) : _e, o: tt.o ? et(_, tt.o, 0, .01, $) : _e, p: tt.p ? et(_, tt.p, 1, 0, $) : _e, sw: tt.sw ? et(_, tt.sw, 0, 0, $) : _e, sc: tt.sc ? et(_, tt.sc, 1, 0, $) : _e, fc: tt.fc ? et(_, tt.fc, 1, 0, $) : _e, fh: tt.fh ? et(_, tt.fh, 0, 0, $) : _e, fs: tt.fs ? et(_, tt.fs, 0, .01, $) : _e, fb: tt.fb ? et(_, tt.fb, 0, .01, $) : _e, t: tt.t ? et(_, tt.t, 0, 0, $) : _e }, this.s = TextSelectorProp.getTextSelectorProp(_, j.s, $), this.s.t = j.s.t } function TextAnimatorProperty(_, j, $) { this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = _, this._renderType = j, this._elem = $, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = { alignment: {} }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer($) } TextAnimatorProperty.prototype.searchProperties = function () { var _, j = this._textData.a.length, $, _e = PropertyFactory.getProp; for (_ = 0; _ < j; _ += 1)$ = this._textData.a[_], this._animatorsData[_] = new TextAnimatorDataProperty(this._elem, $, this); this._textData.p && "m" in this._textData.p ? (this._pathData = { a: _e(this._elem, this._textData.p.a, 0, 0, this), f: _e(this._elem, this._textData.p.f, 0, 0, this), l: _e(this._elem, this._textData.p.l, 0, 0, this), r: _e(this._elem, this._textData.p.r, 0, 0, this), p: _e(this._elem, this._textData.p.p, 0, 0, this), m: this._elem.maskManager.getMaskProperty(this._textData.p.m) }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = _e(this._elem, this._textData.m.a, 1, 0, this) }, TextAnimatorProperty.prototype.getMeasures = function (_, j) { if (this.lettersChangedFlag = j, !(!this._mdf && !this._isFirstFrame && !j && (!this._hasMaskedPath || !this._pathData.m._mdf))) { this._isFirstFrame = !1; var $ = this._moreOptions.alignment.v, _e = this._animatorsData, et = this._textData, tt = this.mHelper, rt = this._renderType, nt = this.renderedLetters.length, it, st, ot, ft, at = _.l, dt, pt, ht, xt, ct, ut, lt, mt, yt, gt, St, bt, _t, Mt, It; if (this._hasMaskedPath) { if (It = this._pathData.m, !this._pathData.n || this._pathData._mdf) { var Rt = It.v; this._pathData.r.v && (Rt = Rt.reverse()), dt = { tLength: 0, segments: [] }, ft = Rt._length - 1; var Lt; for (bt = 0, ot = 0; ot < ft; ot += 1)Lt = bez.buildBezierData(Rt.v[ot], Rt.v[ot + 1], [Rt.o[ot][0] - Rt.v[ot][0], Rt.o[ot][1] - Rt.v[ot][1]], [Rt.i[ot + 1][0] - Rt.v[ot + 1][0], Rt.i[ot + 1][1] - Rt.v[ot + 1][1]]), dt.tLength += Lt.segmentLength, dt.segments.push(Lt), bt += Lt.segmentLength; ot = ft, It.v.c && (Lt = bez.buildBezierData(Rt.v[ot], Rt.v[0], [Rt.o[ot][0] - Rt.v[ot][0], Rt.o[ot][1] - Rt.v[ot][1]], [Rt.i[0][0] - Rt.v[0][0], Rt.i[0][1] - Rt.v[0][1]]), dt.tLength += Lt.segmentLength, dt.segments.push(Lt), bt += Lt.segmentLength), this._pathData.pi = dt } if (dt = this._pathData.pi, pt = this._pathData.f.v, lt = 0, ut = 1, xt = 0, ct = !0, gt = dt.segments, pt < 0 && It.v.c) for (dt.tLength < Math.abs(pt) && (pt = -Math.abs(pt) % dt.tLength), lt = gt.length - 1, yt = gt[lt].points, ut = yt.length - 1; pt < 0;)pt += yt[ut].partialLength, ut -= 1, ut < 0 && (lt -= 1, yt = gt[lt].points, ut = yt.length - 1); yt = gt[lt].points, mt = yt[ut - 1], ht = yt[ut], St = ht.partialLength } ft = at.length, it = 0, st = 0; var Vt = _.finalSize * 1.2 * .714, At = !0, Pt, kt, vt, Et, Ct; Et = _e.length; var wt, Tt = -1, jt, Ft, Dt, Ot = pt, Nt = lt, Yt = ut, Xt = -1, Kt, Ht, qt, zt, $t, Jt, er, Qt, Gt = "", Bt = this.defaultPropsArray, Wt; if (_.j === 2 || _.j === 1) { var Ut = 0, Zt = 0, nr = _.j === 2 ? -.5 : -1, tr = 0, ir = !0; for (ot = 0; ot < ft; ot += 1)if (at[ot].n) { for (Ut && (Ut += Zt); tr < ot;)at[tr].animatorJustifyOffset = Ut, tr += 1; Ut = 0, ir = !0 } else { for (vt = 0; vt < Et; vt += 1)Pt = _e[vt].a, Pt.t.propType && (ir && _.j === 2 && (Zt += Pt.t.v * nr), kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), wt.length ? Ut += Pt.t.v * wt[0] * nr : Ut += Pt.t.v * wt * nr); ir = !1 } for (Ut && (Ut += Zt); tr < ot;)at[tr].animatorJustifyOffset = Ut, tr += 1 } for (ot = 0; ot < ft; ot += 1) { if (tt.reset(), Kt = 1, at[ot].n) it = 0, st += _.yOffset, st += At ? 1 : 0, pt = Ot, At = !1, this._hasMaskedPath && (lt = Nt, ut = Yt, yt = gt[lt].points, mt = yt[ut - 1], ht = yt[ut], St = ht.partialLength, xt = 0), Gt = "", Qt = "", Jt = "", Wt = "", Bt = this.defaultPropsArray; else { if (this._hasMaskedPath) { if (Xt !== at[ot].line) { switch (_.j) { case 1: pt += bt - _.lineWidths[at[ot].line]; break; case 2: pt += (bt - _.lineWidths[at[ot].line]) / 2; break }Xt = at[ot].line } Tt !== at[ot].ind && (at[Tt] && (pt += at[Tt].extra), pt += at[ot].an / 2, Tt = at[ot].ind), pt += $[0] * at[ot].an * .005; var rr = 0; for (vt = 0; vt < Et; vt += 1)Pt = _e[vt].a, Pt.p.propType && (kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), wt.length ? rr += Pt.p.v[0] * wt[0] : rr += Pt.p.v[0] * wt), Pt.a.propType && (kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), wt.length ? rr += Pt.a.v[0] * wt[0] : rr += Pt.a.v[0] * wt); for (ct = !0, this._pathData.a.v && (pt = at[0].an * .5 + (bt - this._pathData.f.v - at[0].an * .5 - at[at.length - 1].an * .5) * Tt / (ft - 1), pt += this._pathData.f.v); ct;)xt + St >= pt + rr || !yt ? (_t = (pt + rr - xt) / ht.partialLength, Ft = mt.point[0] + (ht.point[0] - mt.point[0]) * _t, Dt = mt.point[1] + (ht.point[1] - mt.point[1]) * _t, tt.translate(-$[0] * at[ot].an * .005, -($[1] * Vt) * .01), ct = !1) : yt && (xt += ht.partialLength, ut += 1, ut >= yt.length && (ut = 0, lt += 1, gt[lt] ? yt = gt[lt].points : It.v.c ? (ut = 0, lt = 0, yt = gt[lt].points) : (xt -= ht.partialLength, yt = null)), yt && (mt = ht, ht = yt[ut], St = ht.partialLength)); jt = at[ot].an / 2 - at[ot].add, tt.translate(-jt, 0, 0) } else jt = at[ot].an / 2 - at[ot].add, tt.translate(-jt, 0, 0), tt.translate(-$[0] * at[ot].an * .005, -$[1] * Vt * .01, 0); for (vt = 0; vt < Et; vt += 1)Pt = _e[vt].a, Pt.t.propType && (kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), (it !== 0 || _.j !== 0) && (this._hasMaskedPath ? wt.length ? pt += Pt.t.v * wt[0] : pt += Pt.t.v * wt : wt.length ? it += Pt.t.v * wt[0] : it += Pt.t.v * wt)); for (_.strokeWidthAnim && (qt = _.sw || 0), _.strokeColorAnim && (_.sc ? Ht = [_.sc[0], _.sc[1], _.sc[2]] : Ht = [0, 0, 0]), _.fillColorAnim && _.fc && (zt = [_.fc[0], _.fc[1], _.fc[2]]), vt = 0; vt < Et; vt += 1)Pt = _e[vt].a, Pt.a.propType && (kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), wt.length ? tt.translate(-Pt.a.v[0] * wt[0], -Pt.a.v[1] * wt[1], Pt.a.v[2] * wt[2]) : tt.translate(-Pt.a.v[0] * wt, -Pt.a.v[1] * wt, Pt.a.v[2] * wt)); for (vt = 0; vt < Et; vt += 1)Pt = _e[vt].a, Pt.s.propType && (kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), wt.length ? tt.scale(1 + (Pt.s.v[0] - 1) * wt[0], 1 + (Pt.s.v[1] - 1) * wt[1], 1) : tt.scale(1 + (Pt.s.v[0] - 1) * wt, 1 + (Pt.s.v[1] - 1) * wt, 1)); for (vt = 0; vt < Et; vt += 1) { if (Pt = _e[vt].a, kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), Pt.sk.propType && (wt.length ? tt.skewFromAxis(-Pt.sk.v * wt[0], Pt.sa.v * wt[1]) : tt.skewFromAxis(-Pt.sk.v * wt, Pt.sa.v * wt)), Pt.r.propType && (wt.length ? tt.rotateZ(-Pt.r.v * wt[2]) : tt.rotateZ(-Pt.r.v * wt)), Pt.ry.propType && (wt.length ? tt.rotateY(Pt.ry.v * wt[1]) : tt.rotateY(Pt.ry.v * wt)), Pt.rx.propType && (wt.length ? tt.rotateX(Pt.rx.v * wt[0]) : tt.rotateX(Pt.rx.v * wt)), Pt.o.propType && (wt.length ? Kt += (Pt.o.v * wt[0] - Kt) * wt[0] : Kt += (Pt.o.v * wt - Kt) * wt), _.strokeWidthAnim && Pt.sw.propType && (wt.length ? qt += Pt.sw.v * wt[0] : qt += Pt.sw.v * wt), _.strokeColorAnim && Pt.sc.propType) for ($t = 0; $t < 3; $t += 1)wt.length ? Ht[$t] += (Pt.sc.v[$t] - Ht[$t]) * wt[0] : Ht[$t] += (Pt.sc.v[$t] - Ht[$t]) * wt; if (_.fillColorAnim && _.fc) { if (Pt.fc.propType) for ($t = 0; $t < 3; $t += 1)wt.length ? zt[$t] += (Pt.fc.v[$t] - zt[$t]) * wt[0] : zt[$t] += (Pt.fc.v[$t] - zt[$t]) * wt; Pt.fh.propType && (wt.length ? zt = addHueToRGB(zt, Pt.fh.v * wt[0]) : zt = addHueToRGB(zt, Pt.fh.v * wt)), Pt.fs.propType && (wt.length ? zt = addSaturationToRGB(zt, Pt.fs.v * wt[0]) : zt = addSaturationToRGB(zt, Pt.fs.v * wt)), Pt.fb.propType && (wt.length ? zt = addBrightnessToRGB(zt, Pt.fb.v * wt[0]) : zt = addBrightnessToRGB(zt, Pt.fb.v * wt)) } } for (vt = 0; vt < Et; vt += 1)Pt = _e[vt].a, Pt.p.propType && (kt = _e[vt].s, wt = kt.getMult(at[ot].anIndexes[vt], et.a[vt].s.totalChars), this._hasMaskedPath ? wt.length ? tt.translate(0, Pt.p.v[1] * wt[0], -Pt.p.v[2] * wt[1]) : tt.translate(0, Pt.p.v[1] * wt, -Pt.p.v[2] * wt) : wt.length ? tt.translate(Pt.p.v[0] * wt[0], Pt.p.v[1] * wt[1], -Pt.p.v[2] * wt[2]) : tt.translate(Pt.p.v[0] * wt, Pt.p.v[1] * wt, -Pt.p.v[2] * wt)); if (_.strokeWidthAnim && (Jt = qt < 0 ? 0 : qt), _.strokeColorAnim && (er = "rgb(" + Math.round(Ht[0] * 255) + "," + Math.round(Ht[1] * 255) + "," + Math.round(Ht[2] * 255) + ")"), _.fillColorAnim && _.fc && (Qt = "rgb(" + Math.round(zt[0] * 255) + "," + Math.round(zt[1] * 255) + "," + Math.round(zt[2] * 255) + ")"), this._hasMaskedPath) { if (tt.translate(0, -_.ls), tt.translate(0, $[1] * Vt * .01 + st, 0), this._pathData.p.v) { Mt = (ht.point[1] - mt.point[1]) / (ht.point[0] - mt.point[0]); var sr = Math.atan(Mt) * 180 / Math.PI; ht.point[0] < mt.point[0] && (sr += 180), tt.rotate(-sr * Math.PI / 180) } tt.translate(Ft, Dt, 0), pt -= $[0] * at[ot].an * .005, at[ot + 1] && Tt !== at[ot + 1].ind && (pt += at[ot].an / 2, pt += _.tr * .001 * _.finalSize) } else { switch (tt.translate(it, st, 0), _.ps && tt.translate(_.ps[0], _.ps[1] + _.ascent, 0), _.j) { case 1: tt.translate(at[ot].animatorJustifyOffset + _.justifyOffset + (_.boxWidth - _.lineWidths[at[ot].line]), 0, 0); break; case 2: tt.translate(at[ot].animatorJustifyOffset + _.justifyOffset + (_.boxWidth - _.lineWidths[at[ot].line]) / 2, 0, 0); break }tt.translate(0, -_.ls), tt.translate(jt, 0, 0), tt.translate($[0] * at[ot].an * .005, $[1] * Vt * .01, 0), it += at[ot].l + _.tr * .001 * _.finalSize } rt === "html" ? Gt = tt.toCSS() : rt === "svg" ? Gt = tt.to2dCSS() : Bt = [tt.props[0], tt.props[1], tt.props[2], tt.props[3], tt.props[4], tt.props[5], tt.props[6], tt.props[7], tt.props[8], tt.props[9], tt.props[10], tt.props[11], tt.props[12], tt.props[13], tt.props[14], tt.props[15]], Wt = Kt } nt <= ot ? (Ct = new LetterProps(Wt, Jt, er, Qt, Gt, Bt), this.renderedLetters.push(Ct), nt += 1, this.lettersChangedFlag = !0) : (Ct = this.renderedLetters[ot], this.lettersChangedFlag = Ct.update(Wt, Jt, er, Qt, Gt, Bt) || this.lettersChangedFlag) } } }, TextAnimatorProperty.prototype.getValue = function () { this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties()) }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty); function ITextElement() { } ITextElement.prototype.initElement = function (_, j, $) { this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(_, j, $), this.textProperty = new TextProperty(this, _.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(_.t, this.renderType, this), this.initTransform(_, j, $), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties) }, ITextElement.prototype.prepareFrame = function (_) { this._mdf = !1, this.prepareRenderableFrame(_), this.prepareProperties(_, this.isInRange) }, ITextElement.prototype.createPathShape = function (_, j) { var $, _e = j.length, et, tt = ""; for ($ = 0; $ < _e; $ += 1)j[$].ty === "sh" && (et = j[$].ks.k, tt += buildShapeString(et, et.i.length, !0, _)); return tt }, ITextElement.prototype.updateDocumentData = function (_, j) { this.textProperty.updateDocumentData(_, j) }, ITextElement.prototype.canResizeFont = function (_) { this.textProperty.canResizeFont(_) }, ITextElement.prototype.setMinimumFontSize = function (_) { this.textProperty.setMinimumFontSize(_) }, ITextElement.prototype.applyTextPropertiesToMatrix = function (_, j, $, _e, et) { switch (_.ps && j.translate(_.ps[0], _.ps[1] + _.ascent, 0), j.translate(0, -_.ls, 0), _.j) { case 1: j.translate(_.justifyOffset + (_.boxWidth - _.lineWidths[$]), 0, 0); break; case 2: j.translate(_.justifyOffset + (_.boxWidth - _.lineWidths[$]) / 2, 0, 0); break }j.translate(_e, et, 0) }, ITextElement.prototype.buildColor = function (_) { return "rgb(" + Math.round(_[0] * 255) + "," + Math.round(_[1] * 255) + "," + Math.round(_[2] * 255) + ")" }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () { }, ITextElement.prototype.validateText = function () { (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1) }; var emptyShapeData = { shapes: [] }; function SVGTextLottieElement(_, j, $) { this.textSpans = [], this.renderType = "svg", this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () { this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text")) }, SVGTextLottieElement.prototype.buildTextContents = function (_) { for (var j = 0, $ = _.length, _e = [], et = ""; j < $;)_[j] === "\r" || _[j] === "" ? (_e.push(et), et = "") : et += _[j], j += 1; return _e.push(et), _e }, SVGTextLottieElement.prototype.buildShapeData = function (_, j) { if (_.shapes && _.shapes.length) { var $ = _.shapes[0]; if ($.it) { var _e = $.it[$.it.length - 1]; _e.s && (_e.s.k[0] = j, _e.s.k[1] = j) } } return _ }, SVGTextLottieElement.prototype.buildNewText = function () { this.addDynamicProperty(this); var _, j, $ = this.textProperty.currentData; this.renderedLetters = createSizedArray($ ? $.l.length : 0), $.fc ? this.layerElement.setAttribute("fill", this.buildColor($.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), $.sc && (this.layerElement.setAttribute("stroke", this.buildColor($.sc)), this.layerElement.setAttribute("stroke-width", $.sw)), this.layerElement.setAttribute("font-size", $.finalSize); var _e = this.globalData.fontManager.getFontByName($.f); if (_e.fClass) this.layerElement.setAttribute("class", _e.fClass); else { this.layerElement.setAttribute("font-family", _e.fFamily); var et = $.fWeight, tt = $.fStyle; this.layerElement.setAttribute("font-style", tt), this.layerElement.setAttribute("font-weight", et) } this.layerElement.setAttribute("aria-label", $.t); var rt = $.l || [], nt = !!this.globalData.fontManager.chars; j = rt.length; var it, st = this.mHelper, ot = "", ft = this.data.singleShape, at = 0, dt = 0, pt = !0, ht = $.tr * .001 * $.finalSize; if (ft && !nt && !$.sz) { var xt = this.textContainer, ct = "start"; switch ($.j) { case 1: ct = "end"; break; case 2: ct = "middle"; break; default: ct = "start"; break }xt.setAttribute("text-anchor", ct), xt.setAttribute("letter-spacing", ht); var ut = this.buildTextContents($.finalText); for (j = ut.length, dt = $.ps ? $.ps[1] + $.ascent : 0, _ = 0; _ < j; _ += 1)it = this.textSpans[_].span || createNS("tspan"), it.textContent = ut[_], it.setAttribute("x", 0), it.setAttribute("y", dt), it.style.display = "inherit", xt.appendChild(it), this.textSpans[_] || (this.textSpans[_] = { span: null, glyph: null }), this.textSpans[_].span = it, dt += $.finalLineHeight; this.layerElement.appendChild(xt) } else { var lt = this.textSpans.length, mt; for (_ = 0; _ < j; _ += 1) { if (this.textSpans[_] || (this.textSpans[_] = { span: null, childSpan: null, glyph: null }), !nt || !ft || _ === 0) { if (it = lt > _ ? this.textSpans[_].span : createNS(nt ? "g" : "text"), lt <= _) { if (it.setAttribute("stroke-linecap", "butt"), it.setAttribute("stroke-linejoin", "round"), it.setAttribute("stroke-miterlimit", "4"), this.textSpans[_].span = it, nt) { var yt = createNS("g"); it.appendChild(yt), this.textSpans[_].childSpan = yt } this.textSpans[_].span = it, this.layerElement.appendChild(it) } it.style.display = "inherit" } if (st.reset(), ft && (rt[_].n && (at = -ht, dt += $.yOffset, dt += pt ? 1 : 0, pt = !1), this.applyTextPropertiesToMatrix($, st, rt[_].line, at, dt), at += rt[_].l || 0, at += ht), nt) { mt = this.globalData.fontManager.getCharData($.finalText[_], _e.fStyle, this.globalData.fontManager.getFontByName($.f).fFamily); var gt; if (mt.t === 1) gt = new SVGCompElement(mt.data, this.globalData, this); else { var St = emptyShapeData; mt.data && mt.data.shapes && (St = this.buildShapeData(mt.data, $.finalSize)), gt = new SVGShapeElement(St, this.globalData, this) } if (this.textSpans[_].glyph) { var bt = this.textSpans[_].glyph; this.textSpans[_].childSpan.removeChild(bt.layerElement), bt.destroy() } this.textSpans[_].glyph = gt, gt._debug = !0, gt.prepareFrame(0), gt.renderFrame(), this.textSpans[_].childSpan.appendChild(gt.layerElement), mt.t === 1 && this.textSpans[_].childSpan.setAttribute("transform", "scale(" + $.finalSize / 100 + "," + $.finalSize / 100 + ")") } else ft && it.setAttribute("transform", "translate(" + st.props[12] + "," + st.props[13] + ")"), it.textContent = rt[_].val, it.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve") } ft && it && it.setAttribute("d", ot) } for (; _ < this.textSpans.length;)this.textSpans[_].span.style.display = "none", _ += 1; this._sizeChanged = !0 }, SVGTextLottieElement.prototype.sourceRectAtTime = function () { if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) { this._sizeChanged = !1; var _ = this.layerElement.getBBox(); this.bbox = { top: _.y, left: _.x, width: _.width, height: _.height } } return this.bbox }, SVGTextLottieElement.prototype.getValue = function () { var _, j = this.textSpans.length, $; for (this.renderedFrame = this.comp.renderedFrame, _ = 0; _ < j; _ += 1)$ = this.textSpans[_].glyph, $ && ($.prepareFrame(this.comp.renderedFrame - this.data.st), $._mdf && (this._mdf = !0)) }, SVGTextLottieElement.prototype.renderInnerContent = function () { if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) { this._sizeChanged = !0; var _, j, $ = this.textAnimator.renderedLetters, _e = this.textProperty.currentData.l; j = _e.length; var et, tt, rt; for (_ = 0; _ < j; _ += 1)_e[_].n || (et = $[_], tt = this.textSpans[_].span, rt = this.textSpans[_].glyph, rt && rt.renderFrame(), et._mdf.m && tt.setAttribute("transform", et.m), et._mdf.o && tt.setAttribute("opacity", et.o), et._mdf.sw && tt.setAttribute("stroke-width", et.sw), et._mdf.sc && tt.setAttribute("stroke", et.sc), et._mdf.fc && tt.setAttribute("fill", et.fc)) } }; function ISolidElement(_, j, $) { this.initElement(_, j, $) } extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () { var _ = createNS("rect"); _.setAttribute("width", this.data.sw), _.setAttribute("height", this.data.sh), _.setAttribute("fill", this.data.sc), this.layerElement.appendChild(_) }; function NullElement(_, j, $) { this.initFrame(), this.initBaseData(_, j, $), this.initFrame(), this.initTransform(_, j, $), this.initHierarchy() } NullElement.prototype.prepareFrame = function (_) { this.prepareProperties(_, !0) }, NullElement.prototype.renderFrame = function () { }, NullElement.prototype.getBaseElement = function () { return null }, NullElement.prototype.destroy = function () { }, NullElement.prototype.sourceRectAtTime = function () { }, NullElement.prototype.hide = function () { }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement); function SVGRendererBase() { } extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function (_) { return new NullElement(_, this.globalData, this) }, SVGRendererBase.prototype.createShape = function (_) { return new SVGShapeElement(_, this.globalData, this) }, SVGRendererBase.prototype.createText = function (_) { return new SVGTextLottieElement(_, this.globalData, this) }, SVGRendererBase.prototype.createImage = function (_) { return new IImageElement(_, this.globalData, this) }, SVGRendererBase.prototype.createSolid = function (_) { return new ISolidElement(_, this.globalData, this) }, SVGRendererBase.prototype.configAnimation = function (_) { this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + _.w + " " + _.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", _.w), this.svgElement.setAttribute("height", _.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement); var j = this.globalData.defs; this.setupGlobalData(_, j), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = _; var $ = createNS("clipPath"), _e = createNS("rect"); _e.setAttribute("width", _.w), _e.setAttribute("height", _.h), _e.setAttribute("x", 0), _e.setAttribute("y", 0); var et = createElementID(); $.setAttribute("id", et), $.appendChild(_e), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + et + ")"), j.appendChild($), this.layers = _.layers, this.elements = createSizedArray(_.layers.length) }, SVGRendererBase.prototype.destroy = function () { this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null; var _, j = this.layers ? this.layers.length : 0; for (_ = 0; _ < j; _ += 1)this.elements[_] && this.elements[_].destroy && this.elements[_].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, SVGRendererBase.prototype.updateContainerSize = function () { }, SVGRendererBase.prototype.findIndexByInd = function (_) { var j = 0, $ = this.layers.length; for (j = 0; j < $; j += 1)if (this.layers[j].ind === _) return j; return -1 }, SVGRendererBase.prototype.buildItem = function (_) { var j = this.elements; if (!(j[_] || this.layers[_].ty === 99)) { j[_] = !0; var $ = this.createItem(this.layers[_]); if (j[_] = $, getExpressionsPlugin() && (this.layers[_].ty === 0 && this.globalData.projectInterface.registerComposition($), $.initExpressions()), this.appendElementInPos($, _), this.layers[_].tt) { var _e = "tp" in this.layers[_] ? this.findIndexByInd(this.layers[_].tp) : _ - 1; if (_e === -1) return; if (!this.elements[_e] || this.elements[_e] === !0) this.buildItem(_e), this.addPendingElement($); else { var et = j[_e], tt = et.getMatte(this.layers[_].tt); $.setMatte(tt) } } } }, SVGRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var _ = this.pendingElements.pop(); if (_.checkParenting(), _.data.tt) for (var j = 0, $ = this.elements.length; j < $;) { if (this.elements[j] === _) { var _e = "tp" in _.data ? this.findIndexByInd(_.data.tp) : j - 1, et = this.elements[_e], tt = et.getMatte(this.layers[j].tt); _.setMatte(tt); break } j += 1 } } }, SVGRendererBase.prototype.renderFrame = function (_) { if (!(this.renderedFrame === _ || this.destroyed)) { _ === null ? _ = this.renderedFrame : this.renderedFrame = _, this.globalData.frameNum = _, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = _, this.globalData._mdf = !1; var j, $ = this.layers.length; for (this.completeLayers || this.checkLayers(_), j = $ - 1; j >= 0; j -= 1)(this.completeLayers || this.elements[j]) && this.elements[j].prepareFrame(_ - this.layers[j].st); if (this.globalData._mdf) for (j = 0; j < $; j += 1)(this.completeLayers || this.elements[j]) && this.elements[j].renderFrame() } }, SVGRendererBase.prototype.appendElementInPos = function (_, j) { var $ = _.getBaseElement(); if ($) { for (var _e = 0, et; _e < j;)this.elements[_e] && this.elements[_e] !== !0 && this.elements[_e].getBaseElement() && (et = this.elements[_e].getBaseElement()), _e += 1; et ? this.layerElement.insertBefore($, et) : this.layerElement.appendChild($) } }, SVGRendererBase.prototype.hide = function () { this.layerElement.style.display = "none" }, SVGRendererBase.prototype.show = function () { this.layerElement.style.display = "block" }; function ICompElement() { } extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (_, j, $) { this.initFrame(), this.initBaseData(_, j, $), this.initTransform(_, j, $), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !j.progressiveLoad) && this.buildAllItems(), this.hide() }, ICompElement.prototype.prepareFrame = function (_) { if (this._mdf = !1, this.prepareRenderableFrame(_), this.prepareProperties(_, this.isInRange), !(!this.isInRange && !this.data.xt)) { if (this.tm._placeholder) this.renderedFrame = _ / this.data.sr; else { var j = this.tm.v; j === this.data.op && (j = this.data.op - 1), this.renderedFrame = j } var $, _e = this.elements.length; for (this.completeLayers || this.checkLayers(this.renderedFrame), $ = _e - 1; $ >= 0; $ -= 1)(this.completeLayers || this.elements[$]) && (this.elements[$].prepareFrame(this.renderedFrame - this.layers[$].st), this.elements[$]._mdf && (this._mdf = !0)) } }, ICompElement.prototype.renderInnerContent = function () { var _, j = this.layers.length; for (_ = 0; _ < j; _ += 1)(this.completeLayers || this.elements[_]) && this.elements[_].renderFrame() }, ICompElement.prototype.setElements = function (_) { this.elements = _ }, ICompElement.prototype.getElements = function () { return this.elements }, ICompElement.prototype.destroyElements = function () { var _, j = this.layers.length; for (_ = 0; _ < j; _ += 1)this.elements[_] && this.elements[_].destroy() }, ICompElement.prototype.destroy = function () { this.destroyElements(), this.destroyBaseElement() }; function SVGCompElement(_, j, $) { this.layers = _.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(_, j, $), this.tm = _.tm ? PropertyFactory.getProp(this, _.tm, 0, j.frameRate, this) : { _placeholder: !0 } } extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function (_) { return new SVGCompElement(_, this.globalData, this) }; function SVGRenderer(_, j) { this.animationItem = _, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg"); var $ = ""; if (j && j.title) { var _e = createNS("title"), et = createElementID(); _e.setAttribute("id", et), _e.textContent = j.title, this.svgElement.appendChild(_e), $ += et } if (j && j.description) { var tt = createNS("desc"), rt = createElementID(); tt.setAttribute("id", rt), tt.textContent = j.description, this.svgElement.appendChild(tt), $ += " " + rt } $ && this.svgElement.setAttribute("aria-labelledby", $); var nt = createNS("defs"); this.svgElement.appendChild(nt); var it = createNS("g"); this.svgElement.appendChild(it), this.layerElement = it, this.renderConfig = { preserveAspectRatio: j && j.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: j && j.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: j && j.contentVisibility || "visible", progressiveLoad: j && j.progressiveLoad || !1, hideOnTransparent: !(j && j.hideOnTransparent === !1), viewBoxOnly: j && j.viewBoxOnly || !1, viewBoxSize: j && j.viewBoxSize || !1, className: j && j.className || "", id: j && j.id || "", focusable: j && j.focusable, filterSize: { width: j && j.filterSize && j.filterSize.width || "100%", height: j && j.filterSize && j.filterSize.height || "100%", x: j && j.filterSize && j.filterSize.x || "0%", y: j && j.filterSize && j.filterSize.y || "0%" }, width: j && j.width, height: j && j.height, runExpressions: !j || j.runExpressions === void 0 || j.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, defs: nt, renderConfig: this.renderConfig }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg" } extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function (_) { return new SVGCompElement(_, this.globalData, this) }; function ShapeTransformManager() { this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0 } ShapeTransformManager.prototype = { addTransformSequence: function (j) { var $, _e = j.length, et = "_"; for ($ = 0; $ < _e; $ += 1)et += j[$].transform.key + "_"; var tt = this.sequences[et]; return tt || (tt = { transforms: [].concat(j), finalTransform: new Matrix, _mdf: !1 }, this.sequences[et] = tt, this.sequenceList.push(tt)), tt }, processSequence: function (j, $) { for (var _e = 0, et = j.transforms.length, tt = $; _e < et && !$;) { if (j.transforms[_e].transform.mProps._mdf) { tt = !0; break } _e += 1 } if (tt) for (j.finalTransform.reset(), _e = et - 1; _e >= 0; _e -= 1)j.finalTransform.multiply(j.transforms[_e].transform.mProps.v); j._mdf = tt }, processSequences: function (j) { var $, _e = this.sequenceList.length; for ($ = 0; $ < _e; $ += 1)this.processSequence(this.sequenceList[$], j) }, getNewKey: function () { return this.transform_key_count += 1, "_" + this.transform_key_count } }; var lumaLoader = function () { var j = "__lottie_element_luma_buffer", $ = null, _e = null, et = null; function tt() { var it = createNS("svg"), st = createNS("filter"), ot = createNS("feColorMatrix"); return st.setAttribute("id", j), ot.setAttribute("type", "matrix"), ot.setAttribute("color-interpolation-filters", "sRGB"), ot.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), st.appendChild(ot), it.appendChild(st), it.setAttribute("id", j + "_svg"), featureSupport.svgLumaHidden && (it.style.display = "none"), it } function rt() { $ || (et = tt(), document.body.appendChild(et), $ = createTag("canvas"), _e = $.getContext("2d"), _e.filter = "url(#" + j + ")", _e.fillStyle = "rgba(0,0,0,0)", _e.fillRect(0, 0, 1, 1)) } function nt(it) { return $ || rt(), $.width = it.width, $.height = it.height, _e.filter = "url(#" + j + ")", $ } return { load: rt, get: nt } }; function createCanvas(_, j) { if (featureSupport.offscreenCanvas) return new OffscreenCanvas(_, j); var $ = createTag("canvas"); return $.width = _, $.height = j, $ } var assetLoader = function () { return { loadLumaCanvas: lumaLoader.load, getLumaCanvas: lumaLoader.get, createCanvas } }(), registeredEffects = {}; function CVEffects(_) { var j, $ = _.data.ef ? _.data.ef.length : 0; this.filters = []; var _e; for (j = 0; j < $; j += 1) { _e = null; var et = _.data.ef[j].ty; if (registeredEffects[et]) { var tt = registeredEffects[et].effect; _e = new tt(_.effectsManager.effectElements[j], _) } _e && this.filters.push(_e) } this.filters.length && _.addRenderableComponent(this) } CVEffects.prototype.renderFrame = function (_) { var j, $ = this.filters.length; for (j = 0; j < $; j += 1)this.filters[j].renderFrame(_) }, CVEffects.prototype.getEffects = function (_) { var j, $ = this.filters.length, _e = []; for (j = 0; j < $; j += 1)this.filters[j].type === _ && _e.push(this.filters[j]); return _e }; function registerEffect(_, j) { registeredEffects[_] = { effect: j } } function CVMaskElement(_, j) { this.data = _, this.element = j, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length); var $, _e = this.masksProperties.length, et = !1; for ($ = 0; $ < _e; $ += 1)this.masksProperties[$].mode !== "n" && (et = !0), this.viewData[$] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[$], 3); this.hasMasks = et, et && this.element.addRenderableComponent(this) } CVMaskElement.prototype.renderFrame = function () { if (this.hasMasks) { var _ = this.element.finalTransform.mat, j = this.element.canvasContext, $, _e = this.masksProperties.length, et, tt, rt; for (j.beginPath(), $ = 0; $ < _e; $ += 1)if (this.masksProperties[$].mode !== "n") { this.masksProperties[$].inv && (j.moveTo(0, 0), j.lineTo(this.element.globalData.compSize.w, 0), j.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), j.lineTo(0, this.element.globalData.compSize.h), j.lineTo(0, 0)), rt = this.viewData[$].v, et = _.applyToPointArray(rt.v[0][0], rt.v[0][1], 0), j.moveTo(et[0], et[1]); var nt, it = rt._length; for (nt = 1; nt < it; nt += 1)tt = _.applyToTriplePoints(rt.o[nt - 1], rt.i[nt], rt.v[nt]), j.bezierCurveTo(tt[0], tt[1], tt[2], tt[3], tt[4], tt[5]); tt = _.applyToTriplePoints(rt.o[nt - 1], rt.i[0], rt.v[0]), j.bezierCurveTo(tt[0], tt[1], tt[2], tt[3], tt[4], tt[5]) } this.element.globalData.renderer.save(!0), j.clip() } }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () { this.element = null }; function CVBaseElement() { } var operationsMap = { 1: "source-in", 2: "source-out", 3: "source-in", 4: "source-out" }; CVBaseElement.prototype = { createElements: function () { }, initRendererElement: function () { }, createContainerElements: function () { if (this.data.tt >= 1) { this.buffers = []; var j = this.globalData.canvasContext, $ = assetLoader.createCanvas(j.canvas.width, j.canvas.height); this.buffers.push($); var _e = assetLoader.createCanvas(j.canvas.width, j.canvas.height); this.buffers.push(_e), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas() } this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms() }, createContent: function () { }, setBlendMode: function () { var j = this.globalData; if (j.blendMode !== this.data.bm) { j.blendMode = this.data.bm; var $ = getBlendMode(this.data.bm); j.canvasContext.globalCompositeOperation = $ } }, createRenderableComponents: function () { this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT) }, hideElement: function () { !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0) }, showElement: function () { this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0) }, clearCanvas: function (j) { j.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy) }, prepareLayer: function () { if (this.data.tt >= 1) { var j = this.buffers[0], $ = j.getContext("2d"); this.clearCanvas($), $.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform) } }, exitLayer: function () { if (this.data.tt >= 1) { var j = this.buffers[1], $ = j.getContext("2d"); this.clearCanvas($), $.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform); var _e = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1); if (_e.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) { var et = assetLoader.getLumaCanvas(this.canvasContext.canvas), tt = et.getContext("2d"); tt.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(et, 0, 0) } this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(j, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over" } }, renderFrame: function (j) { if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !j)) { this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode(); var $ = this.data.ty === 0; this.prepareLayer(), this.globalData.renderer.save($), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore($), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1) } }, destroy: function () { this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy() }, mHelper: new Matrix }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement; function CVShapeData(_, j, $, _e) { this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0]; var et = 4; j.ty === "rc" ? et = 5 : j.ty === "el" ? et = 6 : j.ty === "sr" && (et = 7), this.sh = ShapePropertyFactory.getShapeProp(_, j, et, _); var tt, rt = $.length, nt; for (tt = 0; tt < rt; tt += 1)$[tt].closed || (nt = { transforms: _e.addTransformSequence($[tt].transforms), trNodes: [] }, this.styledShapes.push(nt), $[tt].elements.push(nt)) } CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated; function CVShapeElement(_, j, $) { this.shapes = [], this.shapesData = _.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []) }, CVShapeElement.prototype.createStyleElement = function (_, j) { var $ = { data: _, type: _.ty, preTransforms: this.transformsManager.addTransformSequence(j), transforms: [], elements: [], closed: _.hd === !0 }, _e = {}; if (_.ty === "fl" || _.ty === "st" ? (_e.c = PropertyFactory.getProp(this, _.c, 1, 255, this), _e.c.k || ($.co = "rgb(" + bmFloor(_e.c.v[0]) + "," + bmFloor(_e.c.v[1]) + "," + bmFloor(_e.c.v[2]) + ")")) : (_.ty === "gf" || _.ty === "gs") && (_e.s = PropertyFactory.getProp(this, _.s, 1, null, this), _e.e = PropertyFactory.getProp(this, _.e, 1, null, this), _e.h = PropertyFactory.getProp(this, _.h || { k: 0 }, 0, .01, this), _e.a = PropertyFactory.getProp(this, _.a || { k: 0 }, 0, degToRads, this), _e.g = new GradientProperty(this, _.g, this)), _e.o = PropertyFactory.getProp(this, _.o, 0, .01, this), _.ty === "st" || _.ty === "gs") { if ($.lc = lineCapEnum[_.lc || 2], $.lj = lineJoinEnum[_.lj || 2], _.lj == 1 && ($.ml = _.ml), _e.w = PropertyFactory.getProp(this, _.w, 0, null, this), _e.w.k || ($.wi = _e.w.v), _.d) { var et = new DashProperty(this, _.d, "canvas", this); _e.d = et, _e.d.k || ($.da = _e.d.dashArray, $.do = _e.d.dashoffset[0]) } } else $.r = _.r === 2 ? "evenodd" : "nonzero"; return this.stylesList.push($), _e.style = $, _e }, CVShapeElement.prototype.createGroupElement = function () { var _ = { it: [], prevViewData: [] }; return _ }, CVShapeElement.prototype.createTransformElement = function (_) { var j = { transform: { opacity: 1, _opMdf: !1, key: this.transformsManager.getNewKey(), op: PropertyFactory.getProp(this, _.o, 0, .01, this), mProps: TransformPropertyFactory.getTransformProperty(this, _, this) } }; return j }, CVShapeElement.prototype.createShapeElement = function (_) { var j = new CVShapeData(this, _, this.stylesList, this.transformsManager); return this.shapes.push(j), this.addShapeToModifiers(j), j }, CVShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; var _, j = this.itemsData.length; for (_ = 0; _ < j; _ += 1)this.prevViewData[_] = this.itemsData[_]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), j = this.dynamicProperties.length, _ = 0; _ < j; _ += 1)this.dynamicProperties[_].getValue(); this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame) }, CVShapeElement.prototype.addTransformToStyleList = function (_) { var j, $ = this.stylesList.length; for (j = 0; j < $; j += 1)this.stylesList[j].closed || this.stylesList[j].transforms.push(_) }, CVShapeElement.prototype.removeTransformFromStyleList = function () { var _, j = this.stylesList.length; for (_ = 0; _ < j; _ += 1)this.stylesList[_].closed || this.stylesList[_].transforms.pop() }, CVShapeElement.prototype.closeStyles = function (_) { var j, $ = _.length; for (j = 0; j < $; j += 1)_[j].closed = !0 }, CVShapeElement.prototype.searchShapes = function (_, j, $, _e, et) { var tt, rt = _.length - 1, nt, it, st = [], ot = [], ft, at, dt, pt = [].concat(et); for (tt = rt; tt >= 0; tt -= 1) { if (ft = this.searchProcessedElement(_[tt]), ft ? j[tt] = $[ft - 1] : _[tt]._shouldRender = _e, _[tt].ty === "fl" || _[tt].ty === "st" || _[tt].ty === "gf" || _[tt].ty === "gs") ft ? j[tt].style.closed = !1 : j[tt] = this.createStyleElement(_[tt], pt), st.push(j[tt].style); else if (_[tt].ty === "gr") { if (!ft) j[tt] = this.createGroupElement(_[tt]); else for (it = j[tt].it.length, nt = 0; nt < it; nt += 1)j[tt].prevViewData[nt] = j[tt].it[nt]; this.searchShapes(_[tt].it, j[tt].it, j[tt].prevViewData, _e, pt) } else _[tt].ty === "tr" ? (ft || (dt = this.createTransformElement(_[tt]), j[tt] = dt), pt.push(j[tt]), this.addTransformToStyleList(j[tt])) : _[tt].ty === "sh" || _[tt].ty === "rc" || _[tt].ty === "el" || _[tt].ty === "sr" ? ft || (j[tt] = this.createShapeElement(_[tt])) : _[tt].ty === "tm" || _[tt].ty === "rd" || _[tt].ty === "pb" || _[tt].ty === "zz" || _[tt].ty === "op" ? (ft ? (at = j[tt], at.closed = !1) : (at = ShapeModifiers.getModifier(_[tt].ty), at.init(this, _[tt]), j[tt] = at, this.shapeModifiers.push(at)), ot.push(at)) : _[tt].ty === "rp" && (ft ? (at = j[tt], at.closed = !0) : (at = ShapeModifiers.getModifier(_[tt].ty), j[tt] = at, at.init(this, _, tt, j), this.shapeModifiers.push(at), _e = !1), ot.push(at)); this.addProcessedElement(_[tt], tt + 1) } for (this.removeTransformFromStyleList(), this.closeStyles(st), rt = ot.length, tt = 0; tt < rt; tt += 1)ot[tt].closed = !0 }, CVShapeElement.prototype.renderInnerContent = function () { this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0) }, CVShapeElement.prototype.renderShapeTransform = function (_, j) { (_._opMdf || j.op._mdf || this._isFirstFrame) && (j.opacity = _.opacity, j.opacity *= j.op.v, j._opMdf = !0) }, CVShapeElement.prototype.drawLayer = function () { var _, j = this.stylesList.length, $, _e, et, tt, rt, nt, it = this.globalData.renderer, st = this.globalData.canvasContext, ot, ft; for (_ = 0; _ < j; _ += 1)if (ft = this.stylesList[_], ot = ft.type, !((ot === "st" || ot === "gs") && ft.wi === 0 || !ft.data._shouldRender || ft.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) { for (it.save(), rt = ft.elements, ot === "st" || ot === "gs" ? (it.ctxStrokeStyle(ot === "st" ? ft.co : ft.grd), it.ctxLineWidth(ft.wi), it.ctxLineCap(ft.lc), it.ctxLineJoin(ft.lj), it.ctxMiterLimit(ft.ml || 0)) : it.ctxFillStyle(ot === "fl" ? ft.co : ft.grd), it.ctxOpacity(ft.coOp), ot !== "st" && ot !== "gs" && st.beginPath(), it.ctxTransform(ft.preTransforms.finalTransform.props), _e = rt.length, $ = 0; $ < _e; $ += 1) { for ((ot === "st" || ot === "gs") && (st.beginPath(), ft.da && (st.setLineDash(ft.da), st.lineDashOffset = ft.do)), nt = rt[$].trNodes, tt = nt.length, et = 0; et < tt; et += 1)nt[et].t === "m" ? st.moveTo(nt[et].p[0], nt[et].p[1]) : nt[et].t === "c" ? st.bezierCurveTo(nt[et].pts[0], nt[et].pts[1], nt[et].pts[2], nt[et].pts[3], nt[et].pts[4], nt[et].pts[5]) : st.closePath(); (ot === "st" || ot === "gs") && (it.ctxStroke(), ft.da && st.setLineDash(this.dashResetter)) } ot !== "st" && ot !== "gs" && this.globalData.renderer.ctxFill(ft.r), it.restore() } }, CVShapeElement.prototype.renderShape = function (_, j, $, _e) { var et, tt = j.length - 1, rt; for (rt = _, et = tt; et >= 0; et -= 1)j[et].ty === "tr" ? (rt = $[et].transform, this.renderShapeTransform(_, rt)) : j[et].ty === "sh" || j[et].ty === "el" || j[et].ty === "rc" || j[et].ty === "sr" ? this.renderPath(j[et], $[et]) : j[et].ty === "fl" ? this.renderFill(j[et], $[et], rt) : j[et].ty === "st" ? this.renderStroke(j[et], $[et], rt) : j[et].ty === "gf" || j[et].ty === "gs" ? this.renderGradientFill(j[et], $[et], rt) : j[et].ty === "gr" ? this.renderShape(rt, j[et].it, $[et].it) : j[et].ty; _e && this.drawLayer() }, CVShapeElement.prototype.renderStyledShape = function (_, j) { if (this._isFirstFrame || j._mdf || _.transforms._mdf) { var $ = _.trNodes, _e = j.paths, et, tt, rt, nt = _e._length; $.length = 0; var it = _.transforms.finalTransform; for (rt = 0; rt < nt; rt += 1) { var st = _e.shapes[rt]; if (st && st.v) { for (tt = st._length, et = 1; et < tt; et += 1)et === 1 && $.push({ t: "m", p: it.applyToPointArray(st.v[0][0], st.v[0][1], 0) }), $.push({ t: "c", pts: it.applyToTriplePoints(st.o[et - 1], st.i[et], st.v[et]) }); tt === 1 && $.push({ t: "m", p: it.applyToPointArray(st.v[0][0], st.v[0][1], 0) }), st.c && tt && ($.push({ t: "c", pts: it.applyToTriplePoints(st.o[et - 1], st.i[0], st.v[0]) }), $.push({ t: "z" })) } } _.trNodes = $ } }, CVShapeElement.prototype.renderPath = function (_, j) { if (_.hd !== !0 && _._shouldRender) { var $, _e = j.styledShapes.length; for ($ = 0; $ < _e; $ += 1)this.renderStyledShape(j.styledShapes[$], j.sh) } }, CVShapeElement.prototype.renderFill = function (_, j, $) { var _e = j.style; (j.c._mdf || this._isFirstFrame) && (_e.co = "rgb(" + bmFloor(j.c.v[0]) + "," + bmFloor(j.c.v[1]) + "," + bmFloor(j.c.v[2]) + ")"), (j.o._mdf || $._opMdf || this._isFirstFrame) && (_e.coOp = j.o.v * $.opacity) }, CVShapeElement.prototype.renderGradientFill = function (_, j, $) { var _e = j.style, et; if (!_e.grd || j.g._mdf || j.s._mdf || j.e._mdf || _.t !== 1 && (j.h._mdf || j.a._mdf)) { var tt = this.globalData.canvasContext, rt = j.s.v, nt = j.e.v; if (_.t === 1) et = tt.createLinearGradient(rt[0], rt[1], nt[0], nt[1]); else { var it = Math.sqrt(Math.pow(rt[0] - nt[0], 2) + Math.pow(rt[1] - nt[1], 2)), st = Math.atan2(nt[1] - rt[1], nt[0] - rt[0]), ot = j.h.v; ot >= 1 ? ot = .99 : ot <= -1 && (ot = -.99); var ft = it * ot, at = Math.cos(st + j.a.v) * ft + rt[0], dt = Math.sin(st + j.a.v) * ft + rt[1]; et = tt.createRadialGradient(at, dt, 0, rt[0], rt[1], it) } var pt, ht = _.g.p, xt = j.g.c, ct = 1; for (pt = 0; pt < ht; pt += 1)j.g._hasOpacity && j.g._collapsable && (ct = j.g.o[pt * 2 + 1]), et.addColorStop(xt[pt * 4] / 100, "rgba(" + xt[pt * 4 + 1] + "," + xt[pt * 4 + 2] + "," + xt[pt * 4 + 3] + "," + ct + ")"); _e.grd = et } _e.coOp = j.o.v * $.opacity }, CVShapeElement.prototype.renderStroke = function (_, j, $) { var _e = j.style, et = j.d; et && (et._mdf || this._isFirstFrame) && (_e.da = et.dashArray, _e.do = et.dashoffset[0]), (j.c._mdf || this._isFirstFrame) && (_e.co = "rgb(" + bmFloor(j.c.v[0]) + "," + bmFloor(j.c.v[1]) + "," + bmFloor(j.c.v[2]) + ")"), (j.o._mdf || $._opMdf || this._isFirstFrame) && (_e.coOp = j.o.v * $.opacity), (j.w._mdf || this._isFirstFrame) && (_e.wi = j.w.v) }, CVShapeElement.prototype.destroy = function () { this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0 }; function CVTextElement(_, j, $) { this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = { fill: "rgba(0,0,0,0)", stroke: "rgba(0,0,0,0)", sWidth: 0, fValue: "" }, this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () { var _ = this.textProperty.currentData; this.renderedLetters = createSizedArray(_.l ? _.l.length : 0); var j = !1; _.fc ? (j = !0, this.values.fill = this.buildColor(_.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = j; var $ = !1; _.sc && ($ = !0, this.values.stroke = this.buildColor(_.sc), this.values.sWidth = _.sw); var _e = this.globalData.fontManager.getFontByName(_.f), et, tt, rt = _.l, nt = this.mHelper; this.stroke = $, this.values.fValue = _.finalSize + "px " + this.globalData.fontManager.getFontByName(_.f).fFamily, tt = _.finalText.length; var it, st, ot, ft, at, dt, pt, ht, xt, ct, ut = this.data.singleShape, lt = _.tr * .001 * _.finalSize, mt = 0, yt = 0, gt = !0, St = 0; for (et = 0; et < tt; et += 1) { it = this.globalData.fontManager.getCharData(_.finalText[et], _e.fStyle, this.globalData.fontManager.getFontByName(_.f).fFamily), st = it && it.data || {}, nt.reset(), ut && rt[et].n && (mt = -lt, yt += _.yOffset, yt += gt ? 1 : 0, gt = !1), at = st.shapes ? st.shapes[0].it : [], pt = at.length, nt.scale(_.finalSize / 100, _.finalSize / 100), ut && this.applyTextPropertiesToMatrix(_, nt, rt[et].line, mt, yt), xt = createSizedArray(pt - 1); var bt = 0; for (dt = 0; dt < pt; dt += 1)if (at[dt].ty === "sh") { for (ft = at[dt].ks.k.i.length, ht = at[dt].ks.k, ct = [], ot = 1; ot < ft; ot += 1)ot === 1 && ct.push(nt.applyToX(ht.v[0][0], ht.v[0][1], 0), nt.applyToY(ht.v[0][0], ht.v[0][1], 0)), ct.push(nt.applyToX(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), nt.applyToY(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), nt.applyToX(ht.i[ot][0], ht.i[ot][1], 0), nt.applyToY(ht.i[ot][0], ht.i[ot][1], 0), nt.applyToX(ht.v[ot][0], ht.v[ot][1], 0), nt.applyToY(ht.v[ot][0], ht.v[ot][1], 0)); ct.push(nt.applyToX(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), nt.applyToY(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), nt.applyToX(ht.i[0][0], ht.i[0][1], 0), nt.applyToY(ht.i[0][0], ht.i[0][1], 0), nt.applyToX(ht.v[0][0], ht.v[0][1], 0), nt.applyToY(ht.v[0][0], ht.v[0][1], 0)), xt[bt] = ct, bt += 1 } ut && (mt += rt[et].l, mt += lt), this.textSpans[St] ? this.textSpans[St].elem = xt : this.textSpans[St] = { elem: xt }, St += 1 } }, CVTextElement.prototype.renderInnerContent = function () { this.validateText(); var _ = this.canvasContext; _.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag); var j, $, _e, et, tt, rt, nt = this.textAnimator.renderedLetters, it = this.textProperty.currentData.l; $ = it.length; var st, ot = null, ft = null, at = null, dt, pt, ht = this.globalData.renderer; for (j = 0; j < $; j += 1)if (!it[j].n) { if (st = nt[j], st && (ht.save(), ht.ctxTransform(st.p), ht.ctxOpacity(st.o)), this.fill) { for (st && st.fc ? ot !== st.fc && (ht.ctxFillStyle(st.fc), ot = st.fc) : ot !== this.values.fill && (ot = this.values.fill, ht.ctxFillStyle(this.values.fill)), dt = this.textSpans[j].elem, et = dt.length, this.globalData.canvasContext.beginPath(), _e = 0; _e < et; _e += 1)for (pt = dt[_e], rt = pt.length, this.globalData.canvasContext.moveTo(pt[0], pt[1]), tt = 2; tt < rt; tt += 6)this.globalData.canvasContext.bezierCurveTo(pt[tt], pt[tt + 1], pt[tt + 2], pt[tt + 3], pt[tt + 4], pt[tt + 5]); this.globalData.canvasContext.closePath(), ht.ctxFill() } if (this.stroke) { for (st && st.sw ? at !== st.sw && (at = st.sw, ht.ctxLineWidth(st.sw)) : at !== this.values.sWidth && (at = this.values.sWidth, ht.ctxLineWidth(this.values.sWidth)), st && st.sc ? ft !== st.sc && (ft = st.sc, ht.ctxStrokeStyle(st.sc)) : ft !== this.values.stroke && (ft = this.values.stroke, ht.ctxStrokeStyle(this.values.stroke)), dt = this.textSpans[j].elem, et = dt.length, this.globalData.canvasContext.beginPath(), _e = 0; _e < et; _e += 1)for (pt = dt[_e], rt = pt.length, this.globalData.canvasContext.moveTo(pt[0], pt[1]), tt = 2; tt < rt; tt += 6)this.globalData.canvasContext.bezierCurveTo(pt[tt], pt[tt + 1], pt[tt + 2], pt[tt + 3], pt[tt + 4], pt[tt + 5]); this.globalData.canvasContext.closePath(), ht.ctxStroke() } st && this.globalData.renderer.restore() } }; function CVImageElement(_, j, $) { this.assetData = j.getAssetData(_.refId), this.img = j.imageLoader.getAsset(this.assetData), this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () { if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) { var _ = createTag("canvas"); _.width = this.assetData.w, _.height = this.assetData.h; var j = _.getContext("2d"), $ = this.img.width, _e = this.img.height, et = $ / _e, tt = this.assetData.w / this.assetData.h, rt, nt, it = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio; et > tt && it === "xMidYMid slice" || et < tt && it !== "xMidYMid slice" ? (nt = _e, rt = nt * tt) : (rt = $, nt = rt / tt), j.drawImage(this.img, ($ - rt) / 2, (_e - nt) / 2, rt, nt, 0, 0, this.assetData.w, this.assetData.h), this.img = _ } }, CVImageElement.prototype.renderInnerContent = function () { this.canvasContext.drawImage(this.img, 0, 0) }, CVImageElement.prototype.destroy = function () { this.img = null }; function CVSolidElement(_, j, $) { this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () { this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh) }; function CanvasRendererBase() { } extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function (_) { return new CVShapeElement(_, this.globalData, this) }, CanvasRendererBase.prototype.createText = function (_) { return new CVTextElement(_, this.globalData, this) }, CanvasRendererBase.prototype.createImage = function (_) { return new CVImageElement(_, this.globalData, this) }, CanvasRendererBase.prototype.createSolid = function (_) { return new CVSolidElement(_, this.globalData, this) }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function (_) { _[0] === 1 && _[1] === 0 && _[4] === 0 && _[5] === 1 && _[12] === 0 && _[13] === 0 || this.canvasContext.transform(_[0], _[1], _[4], _[5], _[12], _[13]) }, CanvasRendererBase.prototype.ctxOpacity = function (_) { this.canvasContext.globalAlpha *= _ < 0 ? 0 : _ }, CanvasRendererBase.prototype.ctxFillStyle = function (_) { this.canvasContext.fillStyle = _ }, CanvasRendererBase.prototype.ctxStrokeStyle = function (_) { this.canvasContext.strokeStyle = _ }, CanvasRendererBase.prototype.ctxLineWidth = function (_) { this.canvasContext.lineWidth = _ }, CanvasRendererBase.prototype.ctxLineCap = function (_) { this.canvasContext.lineCap = _ }, CanvasRendererBase.prototype.ctxLineJoin = function (_) { this.canvasContext.lineJoin = _ }, CanvasRendererBase.prototype.ctxMiterLimit = function (_) { this.canvasContext.miterLimit = _ }, CanvasRendererBase.prototype.ctxFill = function (_) { this.canvasContext.fill(_) }, CanvasRendererBase.prototype.ctxFillRect = function (_, j, $, _e) { this.canvasContext.fillRect(_, j, $, _e) }, CanvasRendererBase.prototype.ctxStroke = function () { this.canvasContext.stroke() }, CanvasRendererBase.prototype.reset = function () { if (!this.renderConfig.clearCanvas) { this.canvasContext.restore(); return } this.contextData.reset() }, CanvasRendererBase.prototype.save = function () { this.canvasContext.save() }, CanvasRendererBase.prototype.restore = function (_) { if (!this.renderConfig.clearCanvas) { this.canvasContext.restore(); return } _ && (this.globalData.blendMode = "source-over"), this.contextData.restore(_) }, CanvasRendererBase.prototype.configAnimation = function (_) { if (this.animationItem.wrapper) { this.animationItem.container = createTag("canvas"); var j = this.animationItem.container.style; j.width = "100%", j.height = "100%"; var $ = "0px 0px 0px"; j.transformOrigin = $, j.mozTransformOrigin = $, j.webkitTransformOrigin = $, j["-webkit-transform"] = $, j.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id) } else this.canvasContext = this.renderConfig.context; this.contextData.setContext(this.canvasContext), this.data = _, this.layers = _.layers, this.transformCanvas = { w: _.w, h: _.h, sx: 0, sy: 0, tx: 0, ty: 0 }, this.setupGlobalData(_, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(_.layers.length), this.updateContainerSize() }, CanvasRendererBase.prototype.updateContainerSize = function (_, j) { this.reset(); var $, _e; _ ? ($ = _, _e = j, this.canvasContext.canvas.width = $, this.canvasContext.canvas.height = _e) : (this.animationItem.wrapper && this.animationItem.container ? ($ = this.animationItem.wrapper.offsetWidth, _e = this.animationItem.wrapper.offsetHeight) : ($ = this.canvasContext.canvas.width, _e = this.canvasContext.canvas.height), this.canvasContext.canvas.width = $ * this.renderConfig.dpr, this.canvasContext.canvas.height = _e * this.renderConfig.dpr); var et, tt; if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) { var rt = this.renderConfig.preserveAspectRatio.split(" "), nt = rt[1] || "meet", it = rt[0] || "xMidYMid", st = it.substr(0, 4), ot = it.substr(4); et = $ / _e, tt = this.transformCanvas.w / this.transformCanvas.h, tt > et && nt === "meet" || tt < et && nt === "slice" ? (this.transformCanvas.sx = $ / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = $ / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = _e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = _e / (this.transformCanvas.h / this.renderConfig.dpr)), st === "xMid" && (tt < et && nt === "meet" || tt > et && nt === "slice") ? this.transformCanvas.tx = ($ - this.transformCanvas.w * (_e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : st === "xMax" && (tt < et && nt === "meet" || tt > et && nt === "slice") ? this.transformCanvas.tx = ($ - this.transformCanvas.w * (_e / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, ot === "YMid" && (tt > et && nt === "meet" || tt < et && nt === "slice") ? this.transformCanvas.ty = (_e - this.transformCanvas.h * ($ / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : ot === "YMax" && (tt > et && nt === "meet" || tt < et && nt === "slice") ? this.transformCanvas.ty = (_e - this.transformCanvas.h * ($ / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0 } else this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = $ / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = _e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0); this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0) }, CanvasRendererBase.prototype.destroy = function () { this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""); var _, j = this.layers ? this.layers.length : 0; for (_ = j - 1; _ >= 0; _ -= 1)this.elements[_] && this.elements[_].destroy && this.elements[_].destroy(); this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0 }, CanvasRendererBase.prototype.renderFrame = function (_, j) { if (!(this.renderedFrame === _ && this.renderConfig.clearCanvas === !0 && !j || this.destroyed || _ === -1)) { this.renderedFrame = _, this.globalData.frameNum = _ - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || j, this.globalData.projectInterface.currentFrame = _; var $, _e = this.layers.length; for (this.completeLayers || this.checkLayers(_), $ = _e - 1; $ >= 0; $ -= 1)(this.completeLayers || this.elements[$]) && this.elements[$].prepareFrame(_ - this.layers[$].st); if (this.globalData._mdf) { for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), $ = _e - 1; $ >= 0; $ -= 1)(this.completeLayers || this.elements[$]) && this.elements[$].renderFrame(); this.renderConfig.clearCanvas !== !0 && this.restore() } } }, CanvasRendererBase.prototype.buildItem = function (_) { var j = this.elements; if (!(j[_] || this.layers[_].ty === 99)) { var $ = this.createItem(this.layers[_], this, this.globalData); j[_] = $, $.initExpressions() } }, CanvasRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var _ = this.pendingElements.pop(); _.checkParenting() } }, CanvasRendererBase.prototype.hide = function () { this.animationItem.container.style.display = "none" }, CanvasRendererBase.prototype.show = function () { this.animationItem.container.style.display = "block" }; function CanvasContext() { this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random() } function CVContextData() { this.stack = [], this.cArrPos = 0, this.cTr = new Matrix; var _, j = 15; for (_ = 0; _ < j; _ += 1) { var $ = new CanvasContext; this.stack[_] = $ } this._length = j, this.nativeContext = null, this.transformMat = new Matrix, this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = "" } CVContextData.prototype.duplicate = function () { var _ = this._length * 2, j = 0; for (j = this._length; j < _; j += 1)this.stack[j] = new CanvasContext; this._length = _ }, CVContextData.prototype.reset = function () { this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1 }, CVContextData.prototype.restore = function (_) { this.cArrPos -= 1; var j = this.stack[this.cArrPos], $ = j.transform, _e, et = this.cTr.props; for (_e = 0; _e < 16; _e += 1)et[_e] = $[_e]; if (_) { this.nativeContext.restore(); var tt = this.stack[this.cArrPos + 1]; this.appliedFillStyle = tt.fillStyle, this.appliedStrokeStyle = tt.strokeStyle, this.appliedLineWidth = tt.lineWidth, this.appliedLineCap = tt.lineCap, this.appliedLineJoin = tt.lineJoin, this.appliedMiterLimit = tt.miterLimit } this.nativeContext.setTransform($[0], $[1], $[4], $[5], $[12], $[13]), (_ || j.opacity !== -1 && this.currentOpacity !== j.opacity) && (this.nativeContext.globalAlpha = j.opacity, this.currentOpacity = j.opacity), this.currentFillStyle = j.fillStyle, this.currentStrokeStyle = j.strokeStyle, this.currentLineWidth = j.lineWidth, this.currentLineCap = j.lineCap, this.currentLineJoin = j.lineJoin, this.currentMiterLimit = j.miterLimit }, CVContextData.prototype.save = function (_) { _ && this.nativeContext.save(); var j = this.cTr.props; this._length <= this.cArrPos && this.duplicate(); var $ = this.stack[this.cArrPos], _e; for (_e = 0; _e < 16; _e += 1)$.transform[_e] = j[_e]; this.cArrPos += 1; var et = this.stack[this.cArrPos]; et.opacity = $.opacity, et.fillStyle = $.fillStyle, et.strokeStyle = $.strokeStyle, et.lineWidth = $.lineWidth, et.lineCap = $.lineCap, et.lineJoin = $.lineJoin, et.miterLimit = $.miterLimit }, CVContextData.prototype.setOpacity = function (_) { this.stack[this.cArrPos].opacity = _ }, CVContextData.prototype.setContext = function (_) { this.nativeContext = _ }, CVContextData.prototype.fillStyle = function (_) { this.stack[this.cArrPos].fillStyle !== _ && (this.currentFillStyle = _, this.stack[this.cArrPos].fillStyle = _) }, CVContextData.prototype.strokeStyle = function (_) { this.stack[this.cArrPos].strokeStyle !== _ && (this.currentStrokeStyle = _, this.stack[this.cArrPos].strokeStyle = _) }, CVContextData.prototype.lineWidth = function (_) { this.stack[this.cArrPos].lineWidth !== _ && (this.currentLineWidth = _, this.stack[this.cArrPos].lineWidth = _) }, CVContextData.prototype.lineCap = function (_) { this.stack[this.cArrPos].lineCap !== _ && (this.currentLineCap = _, this.stack[this.cArrPos].lineCap = _) }, CVContextData.prototype.lineJoin = function (_) { this.stack[this.cArrPos].lineJoin !== _ && (this.currentLineJoin = _, this.stack[this.cArrPos].lineJoin = _) }, CVContextData.prototype.miterLimit = function (_) { this.stack[this.cArrPos].miterLimit !== _ && (this.currentMiterLimit = _, this.stack[this.cArrPos].miterLimit = _) }, CVContextData.prototype.transform = function (_) { this.transformMat.cloneFromProps(_); var j = this.cTr; this.transformMat.multiply(j), j.cloneFromProps(this.transformMat.props); var $ = j.props; this.nativeContext.setTransform($[0], $[1], $[4], $[5], $[12], $[13]) }, CVContextData.prototype.opacity = function (_) { var j = this.stack[this.cArrPos].opacity; j *= _ < 0 ? 0 : _, this.stack[this.cArrPos].opacity !== j && (this.currentOpacity !== _ && (this.nativeContext.globalAlpha = _, this.currentOpacity = _), this.stack[this.cArrPos].opacity = j) }, CVContextData.prototype.fill = function (_) { this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(_) }, CVContextData.prototype.fillRect = function (_, j, $, _e) { this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(_, j, $, _e) }, CVContextData.prototype.stroke = function () { this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke() }; function CVCompElement(_, j, $) { this.completeLayers = !1, this.layers = _.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(_, j, $), this.tm = _.tm ? PropertyFactory.getProp(this, _.tm, 0, j.frameRate, this) : { _placeholder: !0 } } extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () { var _ = this.canvasContext; _.beginPath(), _.moveTo(0, 0), _.lineTo(this.data.w, 0), _.lineTo(this.data.w, this.data.h), _.lineTo(0, this.data.h), _.lineTo(0, 0), _.clip(); var j, $ = this.layers.length; for (j = $ - 1; j >= 0; j -= 1)(this.completeLayers || this.elements[j]) && this.elements[j].renderFrame() }, CVCompElement.prototype.destroy = function () { var _, j = this.layers.length; for (_ = j - 1; _ >= 0; _ -= 1)this.elements[_] && this.elements[_].destroy(); this.layers = null, this.elements = null }, CVCompElement.prototype.createComp = function (_) { return new CVCompElement(_, this.globalData, this) }; function CanvasRenderer(_, j) { this.animationItem = _, this.renderConfig = { clearCanvas: j && j.clearCanvas !== void 0 ? j.clearCanvas : !0, context: j && j.context || null, progressiveLoad: j && j.progressiveLoad || !1, preserveAspectRatio: j && j.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: j && j.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: j && j.contentVisibility || "visible", className: j && j.className || "", id: j && j.id || "", runExpressions: !j || j.runExpressions === void 0 || j.runExpressions }, this.renderConfig.dpr = j && j.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = j && j.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = { frameNum: -1, _mdf: !1, renderConfig: this.renderConfig, currentGlobalAlpha: -1 }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData)) } extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function (_) { return new CVCompElement(_, this.globalData, this) }; function HBaseElement() { } HBaseElement.prototype = { checkBlendMode: function () { }, initRendererElement: function () { this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement) }, createContainerElements: function () { this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode() }, renderElement: function () { var j = this.transformedElement ? this.transformedElement.style : {}; if (this.finalTransform._matMdf) { var $ = this.finalTransform.mat.toCSS(); j.transform = $, j.webkitTransform = $ } this.finalTransform._opMdf && (j.opacity = this.finalTransform.mProp.o.v) }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, destroy: function () { this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null) }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData) }, addEffects: function () { }, setMatte: function () { } }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting; function HSolidElement(_, j, $) { this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () { var _; this.data.hasMask ? (_ = createNS("rect"), _.setAttribute("width", this.data.sw), _.setAttribute("height", this.data.sh), _.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (_ = createTag("div"), _.style.width = this.data.sw + "px", _.style.height = this.data.sh + "px", _.style.backgroundColor = this.data.sc), this.layerElement.appendChild(_) }; function HShapeElement(_, j, $) { this.shapes = [], this.shapesData = _.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(_, j, $), this.prevViewData = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 } } extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () { var _; if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), _ = this.svgElement; else { _ = createNS("svg"); var j = this.comp.data ? this.comp.data : this.globalData.compSize; _.setAttribute("width", j.w), _.setAttribute("height", j.h), _.appendChild(this.shapesContainer), this.layerElement.appendChild(_) } this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = _ }, HShapeElement.prototype.getTransformedPoint = function (_, j) { var $, _e = _.length; for ($ = 0; $ < _e; $ += 1)j = _[$].mProps.v.applyToPointArray(j[0], j[1], 0); return j }, HShapeElement.prototype.calculateShapeBoundingBox = function (_, j) { var $ = _.sh.v, _e = _.transformers, et, tt = $._length, rt, nt, it, st; if (!(tt <= 1)) { for (et = 0; et < tt - 1; et += 1)rt = this.getTransformedPoint(_e, $.v[et]), nt = this.getTransformedPoint(_e, $.o[et]), it = this.getTransformedPoint(_e, $.i[et + 1]), st = this.getTransformedPoint(_e, $.v[et + 1]), this.checkBounds(rt, nt, it, st, j); $.c && (rt = this.getTransformedPoint(_e, $.v[et]), nt = this.getTransformedPoint(_e, $.o[et]), it = this.getTransformedPoint(_e, $.i[0]), st = this.getTransformedPoint(_e, $.v[0]), this.checkBounds(rt, nt, it, st, j)) } }, HShapeElement.prototype.checkBounds = function (_, j, $, _e, et) { this.getBoundsOfCurve(_, j, $, _e); var tt = this.shapeBoundingBox; et.x = bmMin(tt.left, et.x), et.xMax = bmMax(tt.right, et.xMax), et.y = bmMin(tt.top, et.y), et.yMax = bmMax(tt.bottom, et.yMax) }, HShapeElement.prototype.shapeBoundingBox = { left: 0, right: 0, top: 0, bottom: 0 }, HShapeElement.prototype.tempBoundingBox = { x: 0, xMax: 0, y: 0, yMax: 0, width: 0, height: 0 }, HShapeElement.prototype.getBoundsOfCurve = function (_, j, $, _e) { for (var et = [[_[0], _e[0]], [_[1], _e[1]]], tt, rt, nt, it, st, ot, ft, at = 0; at < 2; ++at)rt = 6 * _[at] - 12 * j[at] + 6 * $[at], tt = -3 * _[at] + 9 * j[at] - 9 * $[at] + 3 * _e[at], nt = 3 * j[at] - 3 * _[at], rt |= 0, tt |= 0, nt |= 0, tt === 0 && rt === 0 || (tt === 0 ? (it = -nt / rt, it > 0 && it < 1 && et[at].push(this.calculateF(it, _, j, $, _e, at))) : (st = rt * rt - 4 * nt * tt, st >= 0 && (ot = (-rt + bmSqrt(st)) / (2 * tt), ot > 0 && ot < 1 && et[at].push(this.calculateF(ot, _, j, $, _e, at)), ft = (-rt - bmSqrt(st)) / (2 * tt), ft > 0 && ft < 1 && et[at].push(this.calculateF(ft, _, j, $, _e, at))))); this.shapeBoundingBox.left = bmMin.apply(null, et[0]), this.shapeBoundingBox.top = bmMin.apply(null, et[1]), this.shapeBoundingBox.right = bmMax.apply(null, et[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, et[1]) }, HShapeElement.prototype.calculateF = function (_, j, $, _e, et, tt) { return bmPow(1 - _, 3) * j[tt] + 3 * bmPow(1 - _, 2) * _ * $[tt] + 3 * (1 - _) * bmPow(_, 2) * _e[tt] + bmPow(_, 3) * et[tt] }, HShapeElement.prototype.calculateBoundingBox = function (_, j) { var $, _e = _.length; for ($ = 0; $ < _e; $ += 1)_[$] && _[$].sh ? this.calculateShapeBoundingBox(_[$], j) : _[$] && _[$].it ? this.calculateBoundingBox(_[$].it, j) : _[$] && _[$].style && _[$].w && this.expandStrokeBoundingBox(_[$].w, j) }, HShapeElement.prototype.expandStrokeBoundingBox = function (_, j) { var $ = 0; if (_.keyframes) { for (var _e = 0; _e < _.keyframes.length; _e += 1) { var et = _.keyframes[_e].s; et > $ && ($ = et) } $ *= _.mult } else $ = _.v * _.mult; j.x -= $, j.xMax += $, j.y -= $, j.yMax += $ }, HShapeElement.prototype.currentBoxContains = function (_) { return this.currentBBox.x <= _.x && this.currentBBox.y <= _.y && this.currentBBox.width + this.currentBBox.x >= _.x + _.width && this.currentBBox.height + this.currentBBox.y >= _.y + _.height }, HShapeElement.prototype.renderInnerContent = function () { if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) { var _ = this.tempBoundingBox, j = 999999; if (_.x = j, _.xMax = -j, _.y = j, _.yMax = -j, this.calculateBoundingBox(this.itemsData, _), _.width = _.xMax < _.x ? 0 : _.xMax - _.x, _.height = _.yMax < _.y ? 0 : _.yMax - _.y, this.currentBoxContains(_)) return; var $ = !1; if (this.currentBBox.w !== _.width && (this.currentBBox.w = _.width, this.shapeCont.setAttribute("width", _.width), $ = !0), this.currentBBox.h !== _.height && (this.currentBBox.h = _.height, this.shapeCont.setAttribute("height", _.height), $ = !0), $ || this.currentBBox.x !== _.x || this.currentBBox.y !== _.y) { this.currentBBox.w = _.width, this.currentBBox.h = _.height, this.currentBBox.x = _.x, this.currentBBox.y = _.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h); var _e = this.shapeCont.style, et = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; _e.transform = et, _e.webkitTransform = et } } }; function HTextElement(_, j, $) { this.textSpans = [], this.textPaths = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }, this.renderType = "svg", this.isMasked = !1, this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () { if (this.isMasked = this.checkMasks(), this.isMasked) { this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH); var _ = createNS("g"); this.maskedElement.appendChild(_), this.innerElem = _ } else this.renderType = "html", this.innerElem = this.layerElement; this.checkParenting() }, HTextElement.prototype.buildNewText = function () { var _ = this.textProperty.currentData; this.renderedLetters = createSizedArray(_.l ? _.l.length : 0); var j = this.innerElem.style, $ = _.fc ? this.buildColor(_.fc) : "rgba(0,0,0,0)"; j.fill = $, j.color = $, _.sc && (j.stroke = this.buildColor(_.sc), j.strokeWidth = _.sw + "px"); var _e = this.globalData.fontManager.getFontByName(_.f); if (!this.globalData.fontManager.chars) if (j.fontSize = _.finalSize + "px", j.lineHeight = _.finalSize + "px", _e.fClass) this.innerElem.className = _e.fClass; else { j.fontFamily = _e.fFamily; var et = _.fWeight, tt = _.fStyle; j.fontStyle = tt, j.fontWeight = et } var rt, nt, it = _.l; nt = it.length; var st, ot, ft, at = this.mHelper, dt, pt = "", ht = 0; for (rt = 0; rt < nt; rt += 1) { if (this.globalData.fontManager.chars ? (this.textPaths[ht] ? st = this.textPaths[ht] : (st = createNS("path"), st.setAttribute("stroke-linecap", lineCapEnum[1]), st.setAttribute("stroke-linejoin", lineJoinEnum[2]), st.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[ht] ? (ot = this.textSpans[ht], ft = ot.children[0]) : (ot = createTag("div"), ot.style.lineHeight = 0, ft = createNS("svg"), ft.appendChild(st), styleDiv(ot)))) : this.isMasked ? st = this.textPaths[ht] ? this.textPaths[ht] : createNS("text") : this.textSpans[ht] ? (ot = this.textSpans[ht], st = this.textPaths[ht]) : (ot = createTag("span"), styleDiv(ot), st = createTag("span"), styleDiv(st), ot.appendChild(st)), this.globalData.fontManager.chars) { var xt = this.globalData.fontManager.getCharData(_.finalText[rt], _e.fStyle, this.globalData.fontManager.getFontByName(_.f).fFamily), ct; if (xt ? ct = xt.data : ct = null, at.reset(), ct && ct.shapes && ct.shapes.length && (dt = ct.shapes[0].it, at.scale(_.finalSize / 100, _.finalSize / 100), pt = this.createPathShape(at, dt), st.setAttribute("d", pt)), this.isMasked) this.innerElem.appendChild(st); else { if (this.innerElem.appendChild(ot), ct && ct.shapes) { document.body.appendChild(ft); var ut = ft.getBBox(); ft.setAttribute("width", ut.width + 2), ft.setAttribute("height", ut.height + 2), ft.setAttribute("viewBox", ut.x - 1 + " " + (ut.y - 1) + " " + (ut.width + 2) + " " + (ut.height + 2)); var lt = ft.style, mt = "translate(" + (ut.x - 1) + "px," + (ut.y - 1) + "px)"; lt.transform = mt, lt.webkitTransform = mt, it[rt].yOffset = ut.y - 1 } else ft.setAttribute("width", 1), ft.setAttribute("height", 1); ot.appendChild(ft) } } else if (st.textContent = it[rt].val, st.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(st); else { this.innerElem.appendChild(ot); var yt = st.style, gt = "translate3d(0," + -_.finalSize / 1.2 + "px,0)"; yt.transform = gt, yt.webkitTransform = gt } this.isMasked ? this.textSpans[ht] = st : this.textSpans[ht] = ot, this.textSpans[ht].style.display = "block", this.textPaths[ht] = st, ht += 1 } for (; ht < this.textSpans.length;)this.textSpans[ht].style.display = "none", ht += 1 }, HTextElement.prototype.renderInnerContent = function () { this.validateText(); var _; if (this.data.singleShape) { if (!this._isFirstFrame && !this.lettersChangedFlag) return; if (this.isMasked && this.finalTransform._matMdf) { this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), _ = this.svgElement.style; var j = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)"; _.transform = j, _.webkitTransform = j } } if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) { var $, _e, et = 0, tt = this.textAnimator.renderedLetters, rt = this.textProperty.currentData.l; _e = rt.length; var nt, it, st; for ($ = 0; $ < _e; $ += 1)rt[$].n ? et += 1 : (it = this.textSpans[$], st = this.textPaths[$], nt = tt[et], et += 1, nt._mdf.m && (this.isMasked ? it.setAttribute("transform", nt.m) : (it.style.webkitTransform = nt.m, it.style.transform = nt.m)), it.style.opacity = nt.o, nt.sw && nt._mdf.sw && st.setAttribute("stroke-width", nt.sw), nt.sc && nt._mdf.sc && st.setAttribute("stroke", nt.sc), nt.fc && nt._mdf.fc && (st.setAttribute("fill", nt.fc), st.style.color = nt.fc)); if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) { var ot = this.innerElem.getBBox(); this.currentBBox.w !== ot.width && (this.currentBBox.w = ot.width, this.svgElement.setAttribute("width", ot.width)), this.currentBBox.h !== ot.height && (this.currentBBox.h = ot.height, this.svgElement.setAttribute("height", ot.height)); var ft = 1; if (this.currentBBox.w !== ot.width + ft * 2 || this.currentBBox.h !== ot.height + ft * 2 || this.currentBBox.x !== ot.x - ft || this.currentBBox.y !== ot.y - ft) { this.currentBBox.w = ot.width + ft * 2, this.currentBBox.h = ot.height + ft * 2, this.currentBBox.x = ot.x - ft, this.currentBBox.y = ot.y - ft, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), _ = this.svgElement.style; var at = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; _.transform = at, _.webkitTransform = at } } } }; function HCameraElement(_, j, $) { this.initFrame(), this.initBaseData(_, j, $), this.initHierarchy(); var _e = PropertyFactory.getProp; if (this.pe = _e(this, _.pe, 0, 0, this), _.ks.p.s ? (this.px = _e(this, _.ks.p.x, 1, 0, this), this.py = _e(this, _.ks.p.y, 1, 0, this), this.pz = _e(this, _.ks.p.z, 1, 0, this)) : this.p = _e(this, _.ks.p, 1, 0, this), _.ks.a && (this.a = _e(this, _.ks.a, 1, 0, this)), _.ks.or.k.length && _.ks.or.k[0].to) { var et, tt = _.ks.or.k.length; for (et = 0; et < tt; et += 1)_.ks.or.k[et].to = null, _.ks.or.k[et].ti = null } this.or = _e(this, _.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = _e(this, _.ks.rx, 0, degToRads, this), this.ry = _e(this, _.ks.ry, 0, degToRads, this), this.rz = _e(this, _.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = { mProp: this } } extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () { var _, j = this.comp.threeDElements.length, $, _e, et; for (_ = 0; _ < j; _ += 1)if ($ = this.comp.threeDElements[_], $.type === "3d") { _e = $.perspectiveElem.style, et = $.container.style; var tt = this.pe.v + "px", rt = "0px 0px 0px", nt = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; _e.perspective = tt, _e.webkitPerspective = tt, et.transformOrigin = rt, et.mozTransformOrigin = rt, et.webkitTransformOrigin = rt, _e.transform = nt, _e.webkitTransform = nt } }, HCameraElement.prototype.createElements = function () { }, HCameraElement.prototype.hide = function () { }, HCameraElement.prototype.renderFrame = function () { var _ = this._isFirstFrame, j, $; if (this.hierarchy) for ($ = this.hierarchy.length, j = 0; j < $; j += 1)_ = this.hierarchy[j].finalTransform.mProp._mdf || _; if (_ || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) { if (this.mat.reset(), this.hierarchy) for ($ = this.hierarchy.length - 1, j = $; j >= 0; j -= 1) { var _e = this.hierarchy[j].finalTransform.mProp; this.mat.translate(-_e.p.v[0], -_e.p.v[1], _e.p.v[2]), this.mat.rotateX(-_e.or.v[0]).rotateY(-_e.or.v[1]).rotateZ(_e.or.v[2]), this.mat.rotateX(-_e.rx.v).rotateY(-_e.ry.v).rotateZ(_e.rz.v), this.mat.scale(1 / _e.s.v[0], 1 / _e.s.v[1], 1 / _e.s.v[2]), this.mat.translate(_e.a.v[0], _e.a.v[1], _e.a.v[2]) } if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) { var et; this.p ? et = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : et = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]]; var tt = Math.sqrt(Math.pow(et[0], 2) + Math.pow(et[1], 2) + Math.pow(et[2], 2)), rt = [et[0] / tt, et[1] / tt, et[2] / tt], nt = Math.sqrt(rt[2] * rt[2] + rt[0] * rt[0]), it = Math.atan2(rt[1], nt), st = Math.atan2(rt[0], -rt[2]); this.mat.rotateY(st).rotateX(-it) } this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v); var ot = !this._prevMat.equals(this.mat); if ((ot || this.pe._mdf) && this.comp.threeDElements) { $ = this.comp.threeDElements.length; var ft, at, dt; for (j = 0; j < $; j += 1)if (ft = this.comp.threeDElements[j], ft.type === "3d") { if (ot) { var pt = this.mat.toCSS(); dt = ft.container.style, dt.transform = pt, dt.webkitTransform = pt } this.pe._mdf && (at = ft.perspectiveElem.style, at.perspective = this.pe.v + "px", at.webkitPerspective = this.pe.v + "px") } this.mat.clone(this._prevMat) } } this._isFirstFrame = !1 }, HCameraElement.prototype.prepareFrame = function (_) { this.prepareProperties(_, !0) }, HCameraElement.prototype.destroy = function () { }, HCameraElement.prototype.getBaseElement = function () { return null }; function HImageElement(_, j, $) { this.assetData = j.getAssetData(_.refId), this.initElement(_, j, $) } extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () { var _ = this.globalData.getAssetsPath(this.assetData), j = new Image; this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", _), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(j), j.crossOrigin = "anonymous", j.src = _, this.data.ln && this.baseElement.setAttribute("id", this.data.ln) }; function HybridRendererBase(_, j) { this.animationItem = _, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: j && j.className || "", imagePreserveAspectRatio: j && j.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(j && j.hideOnTransparent === !1), filterSize: { width: j && j.filterSize && j.filterSize.width || "400%", height: j && j.filterSize && j.filterSize.height || "400%", x: j && j.filterSize && j.filterSize.x || "-100%", y: j && j.filterSize && j.filterSize.y || "-100%" } }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var _ = this.pendingElements.pop(); _.checkParenting() } }, HybridRendererBase.prototype.appendElementInPos = function (_, j) { var $ = _.getBaseElement(); if ($) { var _e = this.layers[j]; if (!_e.ddd || !this.supports3d) if (this.threeDElements) this.addTo3dContainer($, j); else { for (var et = 0, tt, rt, nt; et < j;)this.elements[et] && this.elements[et] !== !0 && this.elements[et].getBaseElement && (rt = this.elements[et], nt = this.layers[et].ddd ? this.getThreeDContainerByPos(et) : rt.getBaseElement(), tt = nt || tt), et += 1; tt ? (!_e.ddd || !this.supports3d) && this.layerElement.insertBefore($, tt) : (!_e.ddd || !this.supports3d) && this.layerElement.appendChild($) } else this.addTo3dContainer($, j) } }, HybridRendererBase.prototype.createShape = function (_) { return this.supports3d ? new HShapeElement(_, this.globalData, this) : new SVGShapeElement(_, this.globalData, this) }, HybridRendererBase.prototype.createText = function (_) { return this.supports3d ? new HTextElement(_, this.globalData, this) : new SVGTextLottieElement(_, this.globalData, this) }, HybridRendererBase.prototype.createCamera = function (_) { return this.camera = new HCameraElement(_, this.globalData, this), this.camera }, HybridRendererBase.prototype.createImage = function (_) { return this.supports3d ? new HImageElement(_, this.globalData, this) : new IImageElement(_, this.globalData, this) }, HybridRendererBase.prototype.createSolid = function (_) { return this.supports3d ? new HSolidElement(_, this.globalData, this) : new ISolidElement(_, this.globalData, this) }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function (_) { for (var j = 0, $ = this.threeDElements.length; j < $;) { if (this.threeDElements[j].startPos <= _ && this.threeDElements[j].endPos >= _) return this.threeDElements[j].perspectiveElem; j += 1 } return null }, HybridRendererBase.prototype.createThreeDContainer = function (_, j) { var $ = createTag("div"), _e, et; styleDiv($); var tt = createTag("div"); if (styleDiv(tt), j === "3d") { _e = $.style, _e.width = this.globalData.compSize.w + "px", _e.height = this.globalData.compSize.h + "px"; var rt = "50% 50%"; _e.webkitTransformOrigin = rt, _e.mozTransformOrigin = rt, _e.transformOrigin = rt, et = tt.style; var nt = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; et.transform = nt, et.webkitTransform = nt } $.appendChild(tt); var it = { container: tt, perspectiveElem: $, startPos: _, endPos: _, type: j }; return this.threeDElements.push(it), it }, HybridRendererBase.prototype.build3dContainers = function () { var _, j = this.layers.length, $, _e = ""; for (_ = 0; _ < j; _ += 1)this.layers[_].ddd && this.layers[_].ty !== 3 ? (_e !== "3d" && (_e = "3d", $ = this.createThreeDContainer(_, "3d")), $.endPos = Math.max($.endPos, _)) : (_e !== "2d" && (_e = "2d", $ = this.createThreeDContainer(_, "2d")), $.endPos = Math.max($.endPos, _)); for (j = this.threeDElements.length, _ = j - 1; _ >= 0; _ -= 1)this.resizerElem.appendChild(this.threeDElements[_].perspectiveElem) }, HybridRendererBase.prototype.addTo3dContainer = function (_, j) { for (var $ = 0, _e = this.threeDElements.length; $ < _e;) { if (j <= this.threeDElements[$].endPos) { for (var et = this.threeDElements[$].startPos, tt; et < j;)this.elements[et] && this.elements[et].getBaseElement && (tt = this.elements[et].getBaseElement()), et += 1; tt ? this.threeDElements[$].container.insertBefore(_, tt) : this.threeDElements[$].container.appendChild(_); break } $ += 1 } }, HybridRendererBase.prototype.configAnimation = function (_) { var j = createTag("div"), $ = this.animationItem.wrapper, _e = j.style; _e.width = _.w + "px", _e.height = _.h + "px", this.resizerElem = j, styleDiv(j), _e.transformStyle = "flat", _e.mozTransformStyle = "flat", _e.webkitTransformStyle = "flat", this.renderConfig.className && j.setAttribute("class", this.renderConfig.className), $.appendChild(j), _e.overflow = "hidden"; var et = createNS("svg"); et.setAttribute("width", "1"), et.setAttribute("height", "1"), styleDiv(et), this.resizerElem.appendChild(et); var tt = createNS("defs"); et.appendChild(tt), this.data = _, this.setupGlobalData(_, et), this.globalData.defs = tt, this.layers = _.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize() }, HybridRendererBase.prototype.destroy = function () { this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null; var _, j = this.layers ? this.layers.length : 0; for (_ = 0; _ < j; _ += 1)this.elements[_] && this.elements[_].destroy && this.elements[_].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, HybridRendererBase.prototype.updateContainerSize = function () { var _ = this.animationItem.wrapper.offsetWidth, j = this.animationItem.wrapper.offsetHeight, $ = _ / j, _e = this.globalData.compSize.w / this.globalData.compSize.h, et, tt, rt, nt; _e > $ ? (et = _ / this.globalData.compSize.w, tt = _ / this.globalData.compSize.w, rt = 0, nt = (j - this.globalData.compSize.h * (_ / this.globalData.compSize.w)) / 2) : (et = j / this.globalData.compSize.h, tt = j / this.globalData.compSize.h, rt = (_ - this.globalData.compSize.w * (j / this.globalData.compSize.h)) / 2, nt = 0); var it = this.resizerElem.style; it.webkitTransform = "matrix3d(" + et + ",0,0,0,0," + tt + ",0,0,0,0,1,0," + rt + "," + nt + ",0,1)", it.transform = it.webkitTransform }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function () { this.resizerElem.style.display = "none" }, HybridRendererBase.prototype.show = function () { this.resizerElem.style.display = "block" }, HybridRendererBase.prototype.initItems = function () { if (this.buildAllItems(), this.camera) this.camera.setup(); else { var _ = this.globalData.compSize.w, j = this.globalData.compSize.h, $, _e = this.threeDElements.length; for ($ = 0; $ < _e; $ += 1) { var et = this.threeDElements[$].perspectiveElem.style; et.webkitPerspective = Math.sqrt(Math.pow(_, 2) + Math.pow(j, 2)) + "px", et.perspective = et.webkitPerspective } } }, HybridRendererBase.prototype.searchExtraCompositions = function (_) { var j, $ = _.length, _e = createTag("div"); for (j = 0; j < $; j += 1)if (_[j].xt) { var et = this.createComp(_[j], _e, this.globalData.comp, null); et.initExpressions(), this.globalData.projectInterface.registerComposition(et) } }; function HCompElement(_, j, $) { this.layers = _.layers, this.supports3d = !_.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(_, j, $), this.tm = _.tm ? PropertyFactory.getProp(this, _.tm, 0, j.frameRate, this) : { _placeholder: !0 } } extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () { this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement }, HCompElement.prototype.addTo3dContainer = function (_, j) { for (var $ = 0, _e; $ < j;)this.elements[$] && this.elements[$].getBaseElement && (_e = this.elements[$].getBaseElement()), $ += 1; _e ? this.layerElement.insertBefore(_, _e) : this.layerElement.appendChild(_) }, HCompElement.prototype.createComp = function (_) { return this.supports3d ? new HCompElement(_, this.globalData, this) : new SVGCompElement(_, this.globalData, this) }; function HybridRenderer(_, j) { this.animationItem = _, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: j && j.className || "", imagePreserveAspectRatio: j && j.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(j && j.hideOnTransparent === !1), filterSize: { width: j && j.filterSize && j.filterSize.width || "400%", height: j && j.filterSize && j.filterSize.height || "400%", x: j && j.filterSize && j.filterSize.x || "-100%", y: j && j.filterSize && j.filterSize.y || "-100%" }, runExpressions: !j || j.runExpressions === void 0 || j.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function (_) { return this.supports3d ? new HCompElement(_, this.globalData, this) : new SVGCompElement(_, this.globalData, this) }; var CompExpressionInterface = function () { return function (_) { function j($) { for (var _e = 0, et = _.layers.length; _e < et;) { if (_.layers[_e].nm === $ || _.layers[_e].ind === $) return _.elements[_e].layerInterface; _e += 1 } return null } return Object.defineProperty(j, "_name", { value: _.data.nm }), j.layer = j, j.pixelAspect = 1, j.height = _.data.h || _.globalData.compSize.h, j.width = _.data.w || _.globalData.compSize.w, j.pixelAspect = 1, j.frameDuration = 1 / _.globalData.frameRate, j.displayStartTime = 0, j.numLayers = _.layers.length, j } }(); function _typeof$2(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function ($) { return typeof $ } : _typeof$2 = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof$2(_) } function seedRandom(_, j) { var $ = this, _e = 256, et = 6, tt = 52, rt = "random", nt = j.pow(_e, et), it = j.pow(2, tt), st = it * 2, ot = _e - 1, ft; function at(lt, mt, yt) { var gt = []; mt = mt === !0 ? { entropy: !0 } : mt || {}; var St = xt(ht(mt.entropy ? [lt, ut(_)] : lt === null ? ct() : lt, 3), gt), bt = new dt(gt), _t = function () { for (var It = bt.g(et), Rt = nt, Lt = 0; It < it;)It = (It + Lt) * _e, Rt *= _e, Lt = bt.g(1); for (; It >= st;)It /= 2, Rt /= 2, Lt >>>= 1; return (It + Lt) / Rt }; return _t.int32 = function () { return bt.g(4) | 0 }, _t.quick = function () { return bt.g(4) / 4294967296 }, _t.double = _t, xt(ut(bt.S), _), (mt.pass || yt || function (Mt, It, Rt, Lt) { return Lt && (Lt.S && pt(Lt, bt), Mt.state = function () { return pt(bt, {}) }), Rt ? (j[rt] = Mt, It) : Mt })(_t, St, "global" in mt ? mt.global : this == j, mt.state) } j["seed" + rt] = at; function dt(lt) { var mt, yt = lt.length, gt = this, St = 0, bt = gt.i = gt.j = 0, _t = gt.S = []; for (yt || (lt = [yt++]); St < _e;)_t[St] = St++; for (St = 0; St < _e; St++)_t[St] = _t[bt = ot & bt + lt[St % yt] + (mt = _t[St])], _t[bt] = mt; gt.g = function (Mt) { for (var It, Rt = 0, Lt = gt.i, Vt = gt.j, At = gt.S; Mt--;)It = At[Lt = ot & Lt + 1], Rt = Rt * _e + At[ot & (At[Lt] = At[Vt = ot & Vt + It]) + (At[Vt] = It)]; return gt.i = Lt, gt.j = Vt, Rt } } function pt(lt, mt) { return mt.i = lt.i, mt.j = lt.j, mt.S = lt.S.slice(), mt } function ht(lt, mt) { var yt = [], gt = _typeof$2(lt), St; if (mt && gt == "object") for (St in lt) try { yt.push(ht(lt[St], mt - 1)) } catch { } return yt.length ? yt : gt == "string" ? lt : lt + "\0" } function xt(lt, mt) { for (var yt = lt + "", gt, St = 0; St < yt.length;)mt[ot & St] = ot & (gt ^= mt[ot & St] * 19) + yt.charCodeAt(St++); return ut(mt) } function ct() { try { var lt = new Uint8Array(_e); return ($.crypto || $.msCrypto).getRandomValues(lt), ut(lt) } catch { var mt = $.navigator, yt = mt && mt.plugins; return [+new Date, $, yt, $.screen, ut(_)] } } function ut(lt) { return String.fromCharCode.apply(0, lt) } xt(j.random(), _) } function initialize$2(_) { seedRandom([], _) } var propTypes = { SHAPE: "shape" }; function _typeof$1(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function ($) { return typeof $ } : _typeof$1 = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof$1(_) } var ExpressionManager = function () { var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null, _lottieGlobal = {}; initialize$2(BMMath); function resetFrame() { _lottieGlobal = {} } function $bm_isInstanceOfArray(_) { return _.constructor === Array || _.constructor === Float32Array } function isNumerable(_, j) { return _ === "number" || j instanceof Number || _ === "boolean" || _ === "string" } function $bm_neg(_) { var j = _typeof$1(_); if (j === "number" || _ instanceof Number || j === "boolean") return -_; if ($bm_isInstanceOfArray(_)) { var $, _e = _.length, et = []; for ($ = 0; $ < _e; $ += 1)et[$] = -_[$]; return et } return _.propType ? _.v : -_ } var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get; function sum(_, j) { var $ = _typeof$1(_), _e = _typeof$1(j); if (isNumerable($, _) && isNumerable(_e, j) || $ === "string" || _e === "string") return _ + j; if ($bm_isInstanceOfArray(_) && isNumerable(_e, j)) return _ = _.slice(0), _[0] += j, _; if (isNumerable($, _) && $bm_isInstanceOfArray(j)) return j = j.slice(0), j[0] = _ + j[0], j; if ($bm_isInstanceOfArray(_) && $bm_isInstanceOfArray(j)) { for (var et = 0, tt = _.length, rt = j.length, nt = []; et < tt || et < rt;)(typeof _[et] == "number" || _[et] instanceof Number) && (typeof j[et] == "number" || j[et] instanceof Number) ? nt[et] = _[et] + j[et] : nt[et] = j[et] === void 0 ? _[et] : _[et] || j[et], et += 1; return nt } return 0 } var add = sum; function sub(_, j) { var $ = _typeof$1(_), _e = _typeof$1(j); if (isNumerable($, _) && isNumerable(_e, j)) return $ === "string" && (_ = parseInt(_, 10)), _e === "string" && (j = parseInt(j, 10)), _ - j; if ($bm_isInstanceOfArray(_) && isNumerable(_e, j)) return _ = _.slice(0), _[0] -= j, _; if (isNumerable($, _) && $bm_isInstanceOfArray(j)) return j = j.slice(0), j[0] = _ - j[0], j; if ($bm_isInstanceOfArray(_) && $bm_isInstanceOfArray(j)) { for (var et = 0, tt = _.length, rt = j.length, nt = []; et < tt || et < rt;)(typeof _[et] == "number" || _[et] instanceof Number) && (typeof j[et] == "number" || j[et] instanceof Number) ? nt[et] = _[et] - j[et] : nt[et] = j[et] === void 0 ? _[et] : _[et] || j[et], et += 1; return nt } return 0 } function mul(_, j) { var $ = _typeof$1(_), _e = _typeof$1(j), et; if (isNumerable($, _) && isNumerable(_e, j)) return _ * j; var tt, rt; if ($bm_isInstanceOfArray(_) && isNumerable(_e, j)) { for (rt = _.length, et = createTypedArray("float32", rt), tt = 0; tt < rt; tt += 1)et[tt] = _[tt] * j; return et } if (isNumerable($, _) && $bm_isInstanceOfArray(j)) { for (rt = j.length, et = createTypedArray("float32", rt), tt = 0; tt < rt; tt += 1)et[tt] = _ * j[tt]; return et } return 0 } function div(_, j) { var $ = _typeof$1(_), _e = _typeof$1(j), et; if (isNumerable($, _) && isNumerable(_e, j)) return _ / j; var tt, rt; if ($bm_isInstanceOfArray(_) && isNumerable(_e, j)) { for (rt = _.length, et = createTypedArray("float32", rt), tt = 0; tt < rt; tt += 1)et[tt] = _[tt] / j; return et } if (isNumerable($, _) && $bm_isInstanceOfArray(j)) { for (rt = j.length, et = createTypedArray("float32", rt), tt = 0; tt < rt; tt += 1)et[tt] = _ / j[tt]; return et } return 0 } function mod(_, j) { return typeof _ == "string" && (_ = parseInt(_, 10)), typeof j == "string" && (j = parseInt(j, 10)), _ % j } var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod; function clamp(_, j, $) { if (j > $) { var _e = $; $ = j, j = _e } return Math.min(Math.max(_, j), $) } function radiansToDegrees(_) { return _ / degToRads } var radians_to_degrees = radiansToDegrees; function degreesToRadians(_) { return _ * degToRads } var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0]; function length(_, j) { if (typeof _ == "number" || _ instanceof Number) return j = j || 0, Math.abs(_ - j); j || (j = helperLengthArray); var $, _e = Math.min(_.length, j.length), et = 0; for ($ = 0; $ < _e; $ += 1)et += Math.pow(j[$] - _[$], 2); return Math.sqrt(et) } function normalize(_) { return div(_, length(_)) } function rgbToHsl(_) { var j = _[0], $ = _[1], _e = _[2], et = Math.max(j, $, _e), tt = Math.min(j, $, _e), rt, nt, it = (et + tt) / 2; if (et === tt) rt = 0, nt = 0; else { var st = et - tt; switch (nt = it > .5 ? st / (2 - et - tt) : st / (et + tt), et) { case j: rt = ($ - _e) / st + ($ < _e ? 6 : 0); break; case $: rt = (_e - j) / st + 2; break; case _e: rt = (j - $) / st + 4; break }rt /= 6 } return [rt, nt, it, _[3]] } function hue2rgb(_, j, $) { return $ < 0 && ($ += 1), $ > 1 && ($ -= 1), $ < 1 / 6 ? _ + (j - _) * 6 * $ : $ < 1 / 2 ? j : $ < 2 / 3 ? _ + (j - _) * (2 / 3 - $) * 6 : _ } function hslToRgb(_) { var j = _[0], $ = _[1], _e = _[2], et, tt, rt; if ($ === 0) et = _e, rt = _e, tt = _e; else { var nt = _e < .5 ? _e * (1 + $) : _e + $ - _e * $, it = 2 * _e - nt; et = hue2rgb(it, nt, j + 1 / 3), tt = hue2rgb(it, nt, j), rt = hue2rgb(it, nt, j - 1 / 3) } return [et, tt, rt, _[3]] } function linear(_, j, $, _e, et) { if ((_e === void 0 || et === void 0) && (_e = j, et = $, j = 0, $ = 1), $ < j) { var tt = $; $ = j, j = tt } if (_ <= j) return _e; if (_ >= $) return et; var rt = $ === j ? 0 : (_ - j) / ($ - j); if (!_e.length) return _e + (et - _e) * rt; var nt, it = _e.length, st = createTypedArray("float32", it); for (nt = 0; nt < it; nt += 1)st[nt] = _e[nt] + (et[nt] - _e[nt]) * rt; return st } function random(_, j) { if (j === void 0 && (_ === void 0 ? (_ = 0, j = 1) : (j = _, _ = void 0)), j.length) { var $, _e = j.length; _ || (_ = createTypedArray("float32", _e)); var et = createTypedArray("float32", _e), tt = BMMath.random(); for ($ = 0; $ < _e; $ += 1)et[$] = _[$] + tt * (j[$] - _[$]); return et } _ === void 0 && (_ = 0); var rt = BMMath.random(); return _ + rt * (j - _) } function createPath(_, j, $, _e) { var et, tt = _.length, rt = shapePool.newElement(); rt.setPathData(!!_e, tt); var nt = [0, 0], it, st; for (et = 0; et < tt; et += 1)it = j && j[et] ? j[et] : nt, st = $ && $[et] ? $[et] : nt, rt.setTripleAt(_[et][0], _[et][1], st[0] + _[et][0], st[1] + _[et][1], it[0] + _[et][0], it[1] + _[et][1], et, !0); return rt } function initiateExpression(elem, data, property) { function noOp(_) { return _ } if (!elem.globalData.renderConfig.runExpressions) return noOp; var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property; thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", { get: function () { return thisProperty.v } }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0; var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function _(j, $) { var _e, et, tt = this.pv.length ? this.pv.length : 1, rt = createTypedArray("float32", tt); j = 5; var nt = Math.floor(time * j); for (_e = 0, et = 0; _e < nt;) { for (et = 0; et < tt; et += 1)rt[et] += -$ + $ * 2 * BMMath.random(); _e += 1 } var it = time * j, st = it - Math.floor(it), ot = createTypedArray("float32", tt); if (tt > 1) { for (et = 0; et < tt; et += 1)ot[et] = this.pv[et] + rt[et] + (-$ + $ * 2 * BMMath.random()) * st; return ot } return this.pv + rt[0] + (-$ + $ * 2 * BMMath.random()) * st }).bind(this); thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)); function loopInDuration(_, j) { return loopIn(_, j, !0) } function loopOutDuration(_, j) { return loopOut(_, j, !0) } this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this)); var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface); function lookAt(_, j) { var $ = [j[0] - _[0], j[1] - _[1], j[2] - _[2]], _e = Math.atan2($[0], Math.sqrt($[1] * $[1] + $[2] * $[2])) / degToRads, et = -Math.atan2($[1], $[2]) / degToRads; return [et, _e, 0] } function easeOut(_, j, $, _e, et) { return applyEase(easeOutBez, _, j, $, _e, et) } function easeIn(_, j, $, _e, et) { return applyEase(easeInBez, _, j, $, _e, et) } function ease(_, j, $, _e, et) { return applyEase(easeInOutBez, _, j, $, _e, et) } function applyEase(_, j, $, _e, et, tt) { et === void 0 ? (et = $, tt = _e) : j = (j - $) / (_e - $), j > 1 ? j = 1 : j < 0 && (j = 0); var rt = _(j); if ($bm_isInstanceOfArray(et)) { var nt, it = et.length, st = createTypedArray("float32", it); for (nt = 0; nt < it; nt += 1)st[nt] = (tt[nt] - et[nt]) * rt + et[nt]; return st } return (tt - et) * rt + et } function nearestKey(_) { var j, $ = data.k.length, _e, et; if (!data.k.length || typeof data.k[0] == "number") _e = 0, et = 0; else if (_e = -1, _ *= elem.comp.globalData.frameRate, _ < data.k[0].t) _e = 1, et = data.k[0].t; else { for (j = 0; j < $ - 1; j += 1)if (_ === data.k[j].t) { _e = j + 1, et = data.k[j].t; break } else if (_ > data.k[j].t && _ < data.k[j + 1].t) { _ - data.k[j].t > data.k[j + 1].t - _ ? (_e = j + 2, et = data.k[j + 1].t) : (_e = j + 1, et = data.k[j].t); break } _e === -1 && (_e = j + 1, et = data.k[j].t) } var tt = {}; return tt.index = _e, tt.time = et / elem.comp.globalData.frameRate, tt } function key(_) { var j, $, _e; if (!data.k.length || typeof data.k[0] == "number") throw new Error("The property has no keyframe at index " + _); _ -= 1, j = { time: data.k[_].t / elem.comp.globalData.frameRate, value: [] }; var et = Object.prototype.hasOwnProperty.call(data.k[_], "s") ? data.k[_].s : data.k[_ - 1].e; for (_e = et.length, $ = 0; $ < _e; $ += 1)j[$] = et[$], j.value[$] = et[$]; return j } function framesToTime(_, j) { return j || (j = elem.comp.globalData.frameRate), _ / j } function timeToFrames(_, j) { return !_ && _ !== 0 && (_ = time), j || (j = elem.comp.globalData.frameRate), _ * j } function seedRandom(_) { BMMath.seedrandom(randSeed + _) } function sourceRectAtTime() { return elem.sourceRectAtTime() } function substring(_, j) { return typeof value == "string" ? j === void 0 ? value.substring(_) : value.substring(_, j) : "" } function substr(_, j) { return typeof value == "string" ? j === void 0 ? value.substr(_) : value.substr(_, j) : "" } function posterizeTime(_) { time = _ === 0 ? 0 : Math.floor(time * _) / _, value = valueAtTime(time) } var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData; function executeExpression(_) { return value = _, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt) } return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression } return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob }(), Expressions = function () { var _ = {}; _.initExpressions = j, _.resetFrame = ExpressionManager.resetFrame; function j($) { var _e = 0, et = []; function tt() { _e += 1 } function rt() { _e -= 1, _e === 0 && it() } function nt(st) { et.indexOf(st) === -1 && et.push(st) } function it() { var st, ot = et.length; for (st = 0; st < ot; st += 1)et[st].release(); et.length = 0 } $.renderer.compInterface = CompExpressionInterface($.renderer), $.renderer.globalData.projectInterface.registerComposition($.renderer), $.renderer.globalData.pushExpression = tt, $.renderer.globalData.popExpression = rt, $.renderer.globalData.registerExpressionProperty = nt } return _ }(), MaskManagerInterface = function () { function _($, _e) { this._mask = $, this._data = _e } Object.defineProperty(_.prototype, "maskPath", { get: function () { return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop } }), Object.defineProperty(_.prototype, "maskOpacity", { get: function () { return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100 } }); var j = function (_e) { var et = createSizedArray(_e.viewData.length), tt, rt = _e.viewData.length; for (tt = 0; tt < rt; tt += 1)et[tt] = new _(_e.viewData[tt], _e.masksProperties[tt]); var nt = function (st) { for (tt = 0; tt < rt;) { if (_e.masksProperties[tt].nm === st) return et[tt]; tt += 1 } return null }; return nt }; return j }(), ExpressionPropertyInterface = function () { var _ = { pv: 0, v: 0, mult: 1 }, j = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }; function $(rt, nt, it) { Object.defineProperty(rt, "velocity", { get: function () { return nt.getVelocityAtTime(nt.comp.currentFrame) } }), rt.numKeys = nt.keyframes ? nt.keyframes.length : 0, rt.key = function (st) { if (!rt.numKeys) return 0; var ot = ""; "s" in nt.keyframes[st - 1] ? ot = nt.keyframes[st - 1].s : "e" in nt.keyframes[st - 2] ? ot = nt.keyframes[st - 2].e : ot = nt.keyframes[st - 2].s; var ft = it === "unidimensional" ? new Number(ot) : Object.assign({}, ot); return ft.time = nt.keyframes[st - 1].t / nt.elem.comp.globalData.frameRate, ft.value = it === "unidimensional" ? ot[0] : ot, ft }, rt.valueAtTime = nt.getValueAtTime, rt.speedAtTime = nt.getSpeedAtTime, rt.velocityAtTime = nt.getVelocityAtTime, rt.propertyGroup = nt.propertyGroup } function _e(rt) { (!rt || !("pv" in rt)) && (rt = _); var nt = 1 / rt.mult, it = rt.pv * nt, st = new Number(it); return st.value = it, $(st, rt, "unidimensional"), function () { return rt.k && rt.getValue(), it = rt.v * nt, st.value !== it && (st = new Number(it), st.value = it, $(st, rt, "unidimensional")), st } } function et(rt) { (!rt || !("pv" in rt)) && (rt = j); var nt = 1 / rt.mult, it = rt.data && rt.data.l || rt.pv.length, st = createTypedArray("float32", it), ot = createTypedArray("float32", it); return st.value = ot, $(st, rt, "multidimensional"), function () { rt.k && rt.getValue(); for (var ft = 0; ft < it; ft += 1)ot[ft] = rt.v[ft] * nt, st[ft] = ot[ft]; return st } } function tt() { return _ } return function (rt) { return rt ? rt.propType === "unidimensional" ? _e(rt) : et(rt) : tt } }(), TransformExpressionInterface = function () { return function (_) { function j(rt) { switch (rt) { case "scale": case "Scale": case "ADBE Scale": case 6: return j.scale; case "rotation": case "Rotation": case "ADBE Rotation": case "ADBE Rotate Z": case 10: return j.rotation; case "ADBE Rotate X": return j.xRotation; case "ADBE Rotate Y": return j.yRotation; case "position": case "Position": case "ADBE Position": case 2: return j.position; case "ADBE Position_0": return j.xPosition; case "ADBE Position_1": return j.yPosition; case "ADBE Position_2": return j.zPosition; case "anchorPoint": case "AnchorPoint": case "Anchor Point": case "ADBE AnchorPoint": case 1: return j.anchorPoint; case "opacity": case "Opacity": case 11: return j.opacity; default: return null } } Object.defineProperty(j, "rotation", { get: ExpressionPropertyInterface(_.r || _.rz) }), Object.defineProperty(j, "zRotation", { get: ExpressionPropertyInterface(_.rz || _.r) }), Object.defineProperty(j, "xRotation", { get: ExpressionPropertyInterface(_.rx) }), Object.defineProperty(j, "yRotation", { get: ExpressionPropertyInterface(_.ry) }), Object.defineProperty(j, "scale", { get: ExpressionPropertyInterface(_.s) }); var $, _e, et, tt; return _.p ? tt = ExpressionPropertyInterface(_.p) : ($ = ExpressionPropertyInterface(_.px), _e = ExpressionPropertyInterface(_.py), _.pz && (et = ExpressionPropertyInterface(_.pz))), Object.defineProperty(j, "position", { get: function () { return _.p ? tt() : [$(), _e(), et ? et() : 0] } }), Object.defineProperty(j, "xPosition", { get: ExpressionPropertyInterface(_.px) }), Object.defineProperty(j, "yPosition", { get: ExpressionPropertyInterface(_.py) }), Object.defineProperty(j, "zPosition", { get: ExpressionPropertyInterface(_.pz) }), Object.defineProperty(j, "anchorPoint", { get: ExpressionPropertyInterface(_.a) }), Object.defineProperty(j, "opacity", { get: ExpressionPropertyInterface(_.o) }), Object.defineProperty(j, "skew", { get: ExpressionPropertyInterface(_.sk) }), Object.defineProperty(j, "skewAxis", { get: ExpressionPropertyInterface(_.sa) }), Object.defineProperty(j, "orientation", { get: ExpressionPropertyInterface(_.or) }), j } }(), LayerExpressionInterface = function () { function _(st) { var ot = new Matrix; if (st !== void 0) { var ft = this._elem.finalTransform.mProp.getValueAtTime(st); ft.clone(ot) } else { var at = this._elem.finalTransform.mProp; at.applyToMatrix(ot) } return ot } function j(st, ot) { var ft = this.getMatrix(ot); return ft.props[12] = 0, ft.props[13] = 0, ft.props[14] = 0, this.applyPoint(ft, st) } function $(st, ot) { var ft = this.getMatrix(ot); return this.applyPoint(ft, st) } function _e(st, ot) { var ft = this.getMatrix(ot); return ft.props[12] = 0, ft.props[13] = 0, ft.props[14] = 0, this.invertPoint(ft, st) } function et(st, ot) { var ft = this.getMatrix(ot); return this.invertPoint(ft, st) } function tt(st, ot) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var ft, at = this._elem.hierarchy.length; for (ft = 0; ft < at; ft += 1)this._elem.hierarchy[ft].finalTransform.mProp.applyToMatrix(st) } return st.applyToPointArray(ot[0], ot[1], ot[2] || 0) } function rt(st, ot) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var ft, at = this._elem.hierarchy.length; for (ft = 0; ft < at; ft += 1)this._elem.hierarchy[ft].finalTransform.mProp.applyToMatrix(st) } return st.inversePoint(ot) } function nt(st) { var ot = new Matrix; if (ot.reset(), this._elem.finalTransform.mProp.applyToMatrix(ot), this._elem.hierarchy && this._elem.hierarchy.length) { var ft, at = this._elem.hierarchy.length; for (ft = 0; ft < at; ft += 1)this._elem.hierarchy[ft].finalTransform.mProp.applyToMatrix(ot); return ot.inversePoint(st) } return ot.inversePoint(st) } function it() { return [1, 1, 1, 1] } return function (st) { var ot; function ft(ht) { dt.mask = new MaskManagerInterface(ht, st) } function at(ht) { dt.effect = ht } function dt(ht) { switch (ht) { case "ADBE Root Vectors Group": case "Contents": case 2: return dt.shapeInterface; case 1: case 6: case "Transform": case "transform": case "ADBE Transform Group": return ot; case 4: case "ADBE Effect Parade": case "effects": case "Effects": return dt.effect; case "ADBE Text Properties": return dt.textInterface; default: return null } } dt.getMatrix = _, dt.invertPoint = rt, dt.applyPoint = tt, dt.toWorld = $, dt.toWorldVec = j, dt.fromWorld = et, dt.fromWorldVec = _e, dt.toComp = $, dt.fromComp = nt, dt.sampleImage = it, dt.sourceRectAtTime = st.sourceRectAtTime.bind(st), dt._elem = st, ot = TransformExpressionInterface(st.finalTransform.mProp); var pt = getDescriptor(ot, "anchorPoint"); return Object.defineProperties(dt, { hasParent: { get: function () { return st.hierarchy.length } }, parent: { get: function () { return st.hierarchy[0].layerInterface } }, rotation: getDescriptor(ot, "rotation"), scale: getDescriptor(ot, "scale"), position: getDescriptor(ot, "position"), opacity: getDescriptor(ot, "opacity"), anchorPoint: pt, anchor_point: pt, transform: { get: function () { return ot } }, active: { get: function () { return st.isInRange } } }), dt.startTime = st.data.st, dt.index = st.data.ind, dt.source = st.data.refId, dt.height = st.data.ty === 0 ? st.data.h : 100, dt.width = st.data.ty === 0 ? st.data.w : 100, dt.inPoint = st.data.ip / st.comp.globalData.frameRate, dt.outPoint = st.data.op / st.comp.globalData.frameRate, dt._name = st.data.nm, dt.registerMaskInterface = ft, dt.registerEffectsInterface = at, dt } }(), propertyGroupFactory = function () { return function (_, j) { return function ($) { return $ = $ === void 0 ? 1 : $, $ <= 0 ? _ : j($ - 1) } } }(), PropertyInterface = function () { return function (_, j) { var $ = { _name: _ }; function _e(et) { return et = et === void 0 ? 1 : et, et <= 0 ? $ : j(et - 1) } return _e } }(), EffectsExpressionInterface = function () { var _ = { createEffectsInterface: j }; function j(et, tt) { if (et.effectsManager) { var rt = [], nt = et.data.ef, it, st = et.effectsManager.effectElements.length; for (it = 0; it < st; it += 1)rt.push($(nt[it], et.effectsManager.effectElements[it], tt, et)); var ot = et.data.ef || [], ft = function (dt) { for (it = 0, st = ot.length; it < st;) { if (dt === ot[it].nm || dt === ot[it].mn || dt === ot[it].ix) return rt[it]; it += 1 } return null }; return Object.defineProperty(ft, "numProperties", { get: function () { return ot.length } }), ft } return null } function $(et, tt, rt, nt) { function it(dt) { for (var pt = et.ef, ht = 0, xt = pt.length; ht < xt;) { if (dt === pt[ht].nm || dt === pt[ht].mn || dt === pt[ht].ix) return pt[ht].ty === 5 ? ot[ht] : ot[ht](); ht += 1 } throw new Error } var st = propertyGroupFactory(it, rt), ot = [], ft, at = et.ef.length; for (ft = 0; ft < at; ft += 1)et.ef[ft].ty === 5 ? ot.push($(et.ef[ft], tt.effectElements[ft], tt.effectElements[ft].propertyGroup, nt)) : ot.push(_e(tt.effectElements[ft], et.ef[ft].ty, nt, st)); return et.mn === "ADBE Color Control" && Object.defineProperty(it, "color", { get: function () { return ot[0]() } }), Object.defineProperties(it, { numProperties: { get: function () { return et.np } }, _name: { value: et.nm }, propertyGroup: { value: st } }), it.enabled = et.en !== 0, it.active = it.enabled, it } function _e(et, tt, rt, nt) { var it = ExpressionPropertyInterface(et.p); function st() { return tt === 10 ? rt.comp.compInterface(et.p.v) : it() } return et.p.setGroupProperty && et.p.setGroupProperty(PropertyInterface("", nt)), st } return _ }(), ShapePathInterface = function () { return function (j, $, _e) { var et = $.sh; function tt(nt) { return nt === "Shape" || nt === "shape" || nt === "Path" || nt === "path" || nt === "ADBE Vector Shape" || nt === 2 ? tt.path : null } var rt = propertyGroupFactory(tt, _e); return et.setGroupProperty(PropertyInterface("Path", rt)), Object.defineProperties(tt, { path: { get: function () { return et.k && et.getValue(), et } }, shape: { get: function () { return et.k && et.getValue(), et } }, _name: { value: j.nm }, ix: { value: j.ix }, propertyIndex: { value: j.ix }, mn: { value: j.mn }, propertyGroup: { value: _e } }), tt } }(), ShapeExpressionInterface = function () { function _(pt, ht, xt) { var ct = [], ut, lt = pt ? pt.length : 0; for (ut = 0; ut < lt; ut += 1)pt[ut].ty === "gr" ? ct.push($(pt[ut], ht[ut], xt)) : pt[ut].ty === "fl" ? ct.push(_e(pt[ut], ht[ut], xt)) : pt[ut].ty === "st" ? ct.push(rt(pt[ut], ht[ut], xt)) : pt[ut].ty === "tm" ? ct.push(nt(pt[ut], ht[ut], xt)) : pt[ut].ty === "tr" || (pt[ut].ty === "el" ? ct.push(st(pt[ut], ht[ut], xt)) : pt[ut].ty === "sr" ? ct.push(ot(pt[ut], ht[ut], xt)) : pt[ut].ty === "sh" ? ct.push(ShapePathInterface(pt[ut], ht[ut], xt)) : pt[ut].ty === "rc" ? ct.push(ft(pt[ut], ht[ut], xt)) : pt[ut].ty === "rd" ? ct.push(at(pt[ut], ht[ut], xt)) : pt[ut].ty === "rp" ? ct.push(dt(pt[ut], ht[ut], xt)) : pt[ut].ty === "gf" ? ct.push(et(pt[ut], ht[ut], xt)) : ct.push(tt(pt[ut], ht[ut]))); return ct } function j(pt, ht, xt) { var ct, ut = function (yt) { for (var gt = 0, St = ct.length; gt < St;) { if (ct[gt]._name === yt || ct[gt].mn === yt || ct[gt].propertyIndex === yt || ct[gt].ix === yt || ct[gt].ind === yt) return ct[gt]; gt += 1 } return typeof yt == "number" ? ct[yt - 1] : null }; ut.propertyGroup = propertyGroupFactory(ut, xt), ct = _(pt.it, ht.it, ut.propertyGroup), ut.numProperties = ct.length; var lt = it(pt.it[pt.it.length - 1], ht.it[ht.it.length - 1], ut.propertyGroup); return ut.transform = lt, ut.propertyIndex = pt.cix, ut._name = pt.nm, ut } function $(pt, ht, xt) { var ct = function (yt) { switch (yt) { case "ADBE Vectors Group": case "Contents": case 2: return ct.content; default: return ct.transform } }; ct.propertyGroup = propertyGroupFactory(ct, xt); var ut = j(pt, ht, ct.propertyGroup), lt = it(pt.it[pt.it.length - 1], ht.it[ht.it.length - 1], ct.propertyGroup); return ct.content = ut, ct.transform = lt, Object.defineProperty(ct, "_name", { get: function () { return pt.nm } }), ct.numProperties = pt.np, ct.propertyIndex = pt.ix, ct.nm = pt.nm, ct.mn = pt.mn, ct } function _e(pt, ht, xt) { function ct(ut) { return ut === "Color" || ut === "color" ? ct.color : ut === "Opacity" || ut === "opacity" ? ct.opacity : null } return Object.defineProperties(ct, { color: { get: ExpressionPropertyInterface(ht.c) }, opacity: { get: ExpressionPropertyInterface(ht.o) }, _name: { value: pt.nm }, mn: { value: pt.mn } }), ht.c.setGroupProperty(PropertyInterface("Color", xt)), ht.o.setGroupProperty(PropertyInterface("Opacity", xt)), ct } function et(pt, ht, xt) { function ct(ut) { return ut === "Start Point" || ut === "start point" ? ct.startPoint : ut === "End Point" || ut === "end point" ? ct.endPoint : ut === "Opacity" || ut === "opacity" ? ct.opacity : null } return Object.defineProperties(ct, { startPoint: { get: ExpressionPropertyInterface(ht.s) }, endPoint: { get: ExpressionPropertyInterface(ht.e) }, opacity: { get: ExpressionPropertyInterface(ht.o) }, type: { get: function () { return "a" } }, _name: { value: pt.nm }, mn: { value: pt.mn } }), ht.s.setGroupProperty(PropertyInterface("Start Point", xt)), ht.e.setGroupProperty(PropertyInterface("End Point", xt)), ht.o.setGroupProperty(PropertyInterface("Opacity", xt)), ct } function tt() { function pt() { return null } return pt } function rt(pt, ht, xt) { var ct = propertyGroupFactory(St, xt), ut = propertyGroupFactory(gt, ct); function lt(bt) { Object.defineProperty(gt, pt.d[bt].nm, { get: ExpressionPropertyInterface(ht.d.dataProps[bt].p) }) } var mt, yt = pt.d ? pt.d.length : 0, gt = {}; for (mt = 0; mt < yt; mt += 1)lt(mt), ht.d.dataProps[mt].p.setGroupProperty(ut); function St(bt) { return bt === "Color" || bt === "color" ? St.color : bt === "Opacity" || bt === "opacity" ? St.opacity : bt === "Stroke Width" || bt === "stroke width" ? St.strokeWidth : null } return Object.defineProperties(St, { color: { get: ExpressionPropertyInterface(ht.c) }, opacity: { get: ExpressionPropertyInterface(ht.o) }, strokeWidth: { get: ExpressionPropertyInterface(ht.w) }, dash: { get: function () { return gt } }, _name: { value: pt.nm }, mn: { value: pt.mn } }), ht.c.setGroupProperty(PropertyInterface("Color", ct)), ht.o.setGroupProperty(PropertyInterface("Opacity", ct)), ht.w.setGroupProperty(PropertyInterface("Stroke Width", ct)), St } function nt(pt, ht, xt) { function ct(lt) { return lt === pt.e.ix || lt === "End" || lt === "end" ? ct.end : lt === pt.s.ix ? ct.start : lt === pt.o.ix ? ct.offset : null } var ut = propertyGroupFactory(ct, xt); return ct.propertyIndex = pt.ix, ht.s.setGroupProperty(PropertyInterface("Start", ut)), ht.e.setGroupProperty(PropertyInterface("End", ut)), ht.o.setGroupProperty(PropertyInterface("Offset", ut)), ct.propertyIndex = pt.ix, ct.propertyGroup = xt, Object.defineProperties(ct, { start: { get: ExpressionPropertyInterface(ht.s) }, end: { get: ExpressionPropertyInterface(ht.e) }, offset: { get: ExpressionPropertyInterface(ht.o) }, _name: { value: pt.nm } }), ct.mn = pt.mn, ct } function it(pt, ht, xt) { function ct(lt) { return pt.a.ix === lt || lt === "Anchor Point" ? ct.anchorPoint : pt.o.ix === lt || lt === "Opacity" ? ct.opacity : pt.p.ix === lt || lt === "Position" ? ct.position : pt.r.ix === lt || lt === "Rotation" || lt === "ADBE Vector Rotation" ? ct.rotation : pt.s.ix === lt || lt === "Scale" ? ct.scale : pt.sk && pt.sk.ix === lt || lt === "Skew" ? ct.skew : pt.sa && pt.sa.ix === lt || lt === "Skew Axis" ? ct.skewAxis : null } var ut = propertyGroupFactory(ct, xt); return ht.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", ut)), ht.transform.mProps.p.setGroupProperty(PropertyInterface("Position", ut)), ht.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", ut)), ht.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", ut)), ht.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", ut)), ht.transform.mProps.sk && (ht.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", ut)), ht.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", ut))), ht.transform.op.setGroupProperty(PropertyInterface("Opacity", ut)), Object.defineProperties(ct, { opacity: { get: ExpressionPropertyInterface(ht.transform.mProps.o) }, position: { get: ExpressionPropertyInterface(ht.transform.mProps.p) }, anchorPoint: { get: ExpressionPropertyInterface(ht.transform.mProps.a) }, scale: { get: ExpressionPropertyInterface(ht.transform.mProps.s) }, rotation: { get: ExpressionPropertyInterface(ht.transform.mProps.r) }, skew: { get: ExpressionPropertyInterface(ht.transform.mProps.sk) }, skewAxis: { get: ExpressionPropertyInterface(ht.transform.mProps.sa) }, _name: { value: pt.nm } }), ct.ty = "tr", ct.mn = pt.mn, ct.propertyGroup = xt, ct } function st(pt, ht, xt) { function ct(mt) { return pt.p.ix === mt ? ct.position : pt.s.ix === mt ? ct.size : null } var ut = propertyGroupFactory(ct, xt); ct.propertyIndex = pt.ix; var lt = ht.sh.ty === "tm" ? ht.sh.prop : ht.sh; return lt.s.setGroupProperty(PropertyInterface("Size", ut)), lt.p.setGroupProperty(PropertyInterface("Position", ut)), Object.defineProperties(ct, { size: { get: ExpressionPropertyInterface(lt.s) }, position: { get: ExpressionPropertyInterface(lt.p) }, _name: { value: pt.nm } }), ct.mn = pt.mn, ct } function ot(pt, ht, xt) { function ct(mt) { return pt.p.ix === mt ? ct.position : pt.r.ix === mt ? ct.rotation : pt.pt.ix === mt ? ct.points : pt.or.ix === mt || mt === "ADBE Vector Star Outer Radius" ? ct.outerRadius : pt.os.ix === mt ? ct.outerRoundness : pt.ir && (pt.ir.ix === mt || mt === "ADBE Vector Star Inner Radius") ? ct.innerRadius : pt.is && pt.is.ix === mt ? ct.innerRoundness : null } var ut = propertyGroupFactory(ct, xt), lt = ht.sh.ty === "tm" ? ht.sh.prop : ht.sh; return ct.propertyIndex = pt.ix, lt.or.setGroupProperty(PropertyInterface("Outer Radius", ut)), lt.os.setGroupProperty(PropertyInterface("Outer Roundness", ut)), lt.pt.setGroupProperty(PropertyInterface("Points", ut)), lt.p.setGroupProperty(PropertyInterface("Position", ut)), lt.r.setGroupProperty(PropertyInterface("Rotation", ut)), pt.ir && (lt.ir.setGroupProperty(PropertyInterface("Inner Radius", ut)), lt.is.setGroupProperty(PropertyInterface("Inner Roundness", ut))), Object.defineProperties(ct, { position: { get: ExpressionPropertyInterface(lt.p) }, rotation: { get: ExpressionPropertyInterface(lt.r) }, points: { get: ExpressionPropertyInterface(lt.pt) }, outerRadius: { get: ExpressionPropertyInterface(lt.or) }, outerRoundness: { get: ExpressionPropertyInterface(lt.os) }, innerRadius: { get: ExpressionPropertyInterface(lt.ir) }, innerRoundness: { get: ExpressionPropertyInterface(lt.is) }, _name: { value: pt.nm } }), ct.mn = pt.mn, ct } function ft(pt, ht, xt) { function ct(mt) { return pt.p.ix === mt ? ct.position : pt.r.ix === mt ? ct.roundness : pt.s.ix === mt || mt === "Size" || mt === "ADBE Vector Rect Size" ? ct.size : null } var ut = propertyGroupFactory(ct, xt), lt = ht.sh.ty === "tm" ? ht.sh.prop : ht.sh; return ct.propertyIndex = pt.ix, lt.p.setGroupProperty(PropertyInterface("Position", ut)), lt.s.setGroupProperty(PropertyInterface("Size", ut)), lt.r.setGroupProperty(PropertyInterface("Rotation", ut)), Object.defineProperties(ct, { position: { get: ExpressionPropertyInterface(lt.p) }, roundness: { get: ExpressionPropertyInterface(lt.r) }, size: { get: ExpressionPropertyInterface(lt.s) }, _name: { value: pt.nm } }), ct.mn = pt.mn, ct } function at(pt, ht, xt) { function ct(mt) { return pt.r.ix === mt || mt === "Round Corners 1" ? ct.radius : null } var ut = propertyGroupFactory(ct, xt), lt = ht; return ct.propertyIndex = pt.ix, lt.rd.setGroupProperty(PropertyInterface("Radius", ut)), Object.defineProperties(ct, { radius: { get: ExpressionPropertyInterface(lt.rd) }, _name: { value: pt.nm } }), ct.mn = pt.mn, ct } function dt(pt, ht, xt) { function ct(mt) { return pt.c.ix === mt || mt === "Copies" ? ct.copies : pt.o.ix === mt || mt === "Offset" ? ct.offset : null } var ut = propertyGroupFactory(ct, xt), lt = ht; return ct.propertyIndex = pt.ix, lt.c.setGroupProperty(PropertyInterface("Copies", ut)), lt.o.setGroupProperty(PropertyInterface("Offset", ut)), Object.defineProperties(ct, { copies: { get: ExpressionPropertyInterface(lt.c) }, offset: { get: ExpressionPropertyInterface(lt.o) }, _name: { value: pt.nm } }), ct.mn = pt.mn, ct } return function (pt, ht, xt) { var ct; function ut(mt) { if (typeof mt == "number") return mt = mt === void 0 ? 1 : mt, mt === 0 ? xt : ct[mt - 1]; for (var yt = 0, gt = ct.length; yt < gt;) { if (ct[yt]._name === mt) return ct[yt]; yt += 1 } return null } function lt() { return xt } return ut.propertyGroup = propertyGroupFactory(ut, lt), ct = _(pt, ht, ut.propertyGroup), ut.numProperties = ct.length, ut._name = "Contents", ut } }(), TextExpressionInterface = function () { return function (_) { var j; function $(_e) { switch (_e) { case "ADBE Text Document": return $.sourceText; default: return null } } return Object.defineProperty($, "sourceText", { get: function () { _.textProperty.getValue(); var et = _.textProperty.currentData.t; return (!j || et !== j.value) && (j = new String(et), j.value = et || new String(et), Object.defineProperty(j, "style", { get: function () { return { fillColor: _.textProperty.currentData.fc } } })), j } }), $ } }(); function _typeof(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function ($) { return typeof $ } : _typeof = function ($) { return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $ }, _typeof(_) } var FootageInterface = function () { var _ = function (_e) { var et = "", tt = _e.getFootageData(); function rt() { return et = "", tt = _e.getFootageData(), nt } function nt(it) { if (tt[it]) return et = it, tt = tt[it], _typeof(tt) === "object" ? nt : tt; var st = it.indexOf(et); if (st !== -1) { var ot = parseInt(it.substr(st + et.length), 10); return tt = tt[ot], _typeof(tt) === "object" ? nt : tt } return "" } return rt }, j = function (_e) { function et(tt) { return tt === "Outline" ? et.outlineInterface() : null } return et._name = "Outline", et.outlineInterface = _(_e), et }; return function ($) { function _e(et) { return et === "Data" ? _e.dataInterface : null } return _e._name = "Data", _e.dataInterface = j($), _e } }(), interfaces = { layer: LayerExpressionInterface, effects: EffectsExpressionInterface, comp: CompExpressionInterface, shape: ShapeExpressionInterface, text: TextExpressionInterface, footage: FootageInterface }; function getInterface(_) { return interfaces[_] || null } var expressionHelpers = function () { function _(rt, nt, it) { nt.x && (it.k = !0, it.x = !0, it.initiateExpression = ExpressionManager.initiateExpression, it.effectsSequence.push(it.initiateExpression(rt, nt, it).bind(it))) } function j(rt) { return rt *= this.elem.globalData.frameRate, rt -= this.offsetTime, rt !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < rt ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(rt, this._cachingAtTime), this._cachingAtTime.lastFrame = rt), this._cachingAtTime.value } function $(rt) { var nt = -.01, it = this.getValueAtTime(rt), st = this.getValueAtTime(rt + nt), ot = 0; if (it.length) { var ft; for (ft = 0; ft < it.length; ft += 1)ot += Math.pow(st[ft] - it[ft], 2); ot = Math.sqrt(ot) * 100 } else ot = 0; return ot } function _e(rt) { if (this.vel !== void 0) return this.vel; var nt = -.001, it = this.getValueAtTime(rt), st = this.getValueAtTime(rt + nt), ot; if (it.length) { ot = createTypedArray("float32", it.length); var ft; for (ft = 0; ft < it.length; ft += 1)ot[ft] = (st[ft] - it[ft]) / nt } else ot = (st - it) / nt; return ot } function et() { return this.pv } function tt(rt) { this.propertyGroup = rt } return { searchExpressions: _, getSpeedAtTime: $, getVelocityAtTime: _e, getValueAtTime: j, getStaticValueAtTime: et, setGroupProperty: tt } }(); function addPropertyDecorator() { function _(at, dt, pt) { if (!this.k || !this.keyframes) return this.pv; at = at ? at.toLowerCase() : ""; var ht = this.comp.renderedFrame, xt = this.keyframes, ct = xt[xt.length - 1].t; if (ht <= ct) return this.pv; var ut, lt; pt ? (dt ? ut = Math.abs(ct - this.elem.comp.globalData.frameRate * dt) : ut = Math.max(0, ct - this.elem.data.ip), lt = ct - ut) : ((!dt || dt > xt.length - 1) && (dt = xt.length - 1), lt = xt[xt.length - 1 - dt].t, ut = ct - lt); var mt, yt, gt; if (at === "pingpong") { var St = Math.floor((ht - lt) / ut); if (St % 2 !== 0) return this.getValueAtTime((ut - (ht - lt) % ut + lt) / this.comp.globalData.frameRate, 0) } else if (at === "offset") { var bt = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0), _t = this.getValueAtTime(ct / this.comp.globalData.frameRate, 0), Mt = this.getValueAtTime(((ht - lt) % ut + lt) / this.comp.globalData.frameRate, 0), It = Math.floor((ht - lt) / ut); if (this.pv.length) { for (gt = new Array(bt.length), yt = gt.length, mt = 0; mt < yt; mt += 1)gt[mt] = (_t[mt] - bt[mt]) * It + Mt[mt]; return gt } return (_t - bt) * It + Mt } else if (at === "continue") { var Rt = this.getValueAtTime(ct / this.comp.globalData.frameRate, 0), Lt = this.getValueAtTime((ct - .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (gt = new Array(Rt.length), yt = gt.length, mt = 0; mt < yt; mt += 1)gt[mt] = Rt[mt] + (Rt[mt] - Lt[mt]) * ((ht - ct) / this.comp.globalData.frameRate) / 5e-4; return gt } return Rt + (Rt - Lt) * ((ht - ct) / .001) } return this.getValueAtTime(((ht - lt) % ut + lt) / this.comp.globalData.frameRate, 0) } function j(at, dt, pt) { if (!this.k) return this.pv; at = at ? at.toLowerCase() : ""; var ht = this.comp.renderedFrame, xt = this.keyframes, ct = xt[0].t; if (ht >= ct) return this.pv; var ut, lt; pt ? (dt ? ut = Math.abs(this.elem.comp.globalData.frameRate * dt) : ut = Math.max(0, this.elem.data.op - ct), lt = ct + ut) : ((!dt || dt > xt.length - 1) && (dt = xt.length - 1), lt = xt[dt].t, ut = lt - ct); var mt, yt, gt; if (at === "pingpong") { var St = Math.floor((ct - ht) / ut); if (St % 2 === 0) return this.getValueAtTime(((ct - ht) % ut + ct) / this.comp.globalData.frameRate, 0) } else if (at === "offset") { var bt = this.getValueAtTime(ct / this.comp.globalData.frameRate, 0), _t = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0), Mt = this.getValueAtTime((ut - (ct - ht) % ut + ct) / this.comp.globalData.frameRate, 0), It = Math.floor((ct - ht) / ut) + 1; if (this.pv.length) { for (gt = new Array(bt.length), yt = gt.length, mt = 0; mt < yt; mt += 1)gt[mt] = Mt[mt] - (_t[mt] - bt[mt]) * It; return gt } return Mt - (_t - bt) * It } else if (at === "continue") { var Rt = this.getValueAtTime(ct / this.comp.globalData.frameRate, 0), Lt = this.getValueAtTime((ct + .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (gt = new Array(Rt.length), yt = gt.length, mt = 0; mt < yt; mt += 1)gt[mt] = Rt[mt] + (Rt[mt] - Lt[mt]) * (ct - ht) / .001; return gt } return Rt + (Rt - Lt) * (ct - ht) / .001 } return this.getValueAtTime((ut - ((ct - ht) % ut + ct)) / this.comp.globalData.frameRate, 0) } function $(at, dt) { if (!this.k) return this.pv; if (at = (at || .4) * .5, dt = Math.floor(dt || 5), dt <= 1) return this.pv; var pt = this.comp.renderedFrame / this.comp.globalData.frameRate, ht = pt - at, xt = pt + at, ct = dt > 1 ? (xt - ht) / (dt - 1) : 1, ut = 0, lt = 0, mt; this.pv.length ? mt = createTypedArray("float32", this.pv.length) : mt = 0; for (var yt; ut < dt;) { if (yt = this.getValueAtTime(ht + ut * ct), this.pv.length) for (lt = 0; lt < this.pv.length; lt += 1)mt[lt] += yt[lt]; else mt += yt; ut += 1 } if (this.pv.length) for (lt = 0; lt < this.pv.length; lt += 1)mt[lt] /= dt; else mt /= dt; return mt } function _e(at) { this._transformCachingAtTime || (this._transformCachingAtTime = { v: new Matrix }); var dt = this._transformCachingAtTime.v; if (dt.cloneFromProps(this.pre.props), this.appliedTransformations < 1) { var pt = this.a.getValueAtTime(at); dt.translate(-pt[0] * this.a.mult, -pt[1] * this.a.mult, pt[2] * this.a.mult) } if (this.appliedTransformations < 2) { var ht = this.s.getValueAtTime(at); dt.scale(ht[0] * this.s.mult, ht[1] * this.s.mult, ht[2] * this.s.mult) } if (this.sk && this.appliedTransformations < 3) { var xt = this.sk.getValueAtTime(at), ct = this.sa.getValueAtTime(at); dt.skewFromAxis(-xt * this.sk.mult, ct * this.sa.mult) } if (this.r && this.appliedTransformations < 4) { var ut = this.r.getValueAtTime(at); dt.rotate(-ut * this.r.mult) } else if (!this.r && this.appliedTransformations < 4) { var lt = this.rz.getValueAtTime(at), mt = this.ry.getValueAtTime(at), yt = this.rx.getValueAtTime(at), gt = this.or.getValueAtTime(at); dt.rotateZ(-lt * this.rz.mult).rotateY(mt * this.ry.mult).rotateX(yt * this.rx.mult).rotateZ(-gt[2] * this.or.mult).rotateY(gt[1] * this.or.mult).rotateX(gt[0] * this.or.mult) } if (this.data.p && this.data.p.s) { var St = this.px.getValueAtTime(at), bt = this.py.getValueAtTime(at); if (this.data.p.z) { var _t = this.pz.getValueAtTime(at); dt.translate(St * this.px.mult, bt * this.py.mult, -_t * this.pz.mult) } else dt.translate(St * this.px.mult, bt * this.py.mult, 0) } else { var Mt = this.p.getValueAtTime(at); dt.translate(Mt[0] * this.p.mult, Mt[1] * this.p.mult, -Mt[2] * this.p.mult) } return dt } function et() { return this.v.clone(new Matrix) } var tt = TransformPropertyFactory.getTransformProperty; TransformPropertyFactory.getTransformProperty = function (at, dt, pt) { var ht = tt(at, dt, pt); return ht.dynamicProperties.length ? ht.getValueAtTime = _e.bind(ht) : ht.getValueAtTime = et.bind(ht), ht.setGroupProperty = expressionHelpers.setGroupProperty, ht }; var rt = PropertyFactory.getProp; PropertyFactory.getProp = function (at, dt, pt, ht, xt) { var ct = rt(at, dt, pt, ht, xt); ct.kf ? ct.getValueAtTime = expressionHelpers.getValueAtTime.bind(ct) : ct.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(ct), ct.setGroupProperty = expressionHelpers.setGroupProperty, ct.loopOut = _, ct.loopIn = j, ct.smooth = $, ct.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(ct), ct.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(ct), ct.numKeys = dt.a === 1 ? dt.k.length : 0, ct.propertyIndex = dt.ix; var ut = 0; return pt !== 0 && (ut = createTypedArray("float32", dt.a === 1 ? dt.k[0].s.length : dt.k.length)), ct._cachingAtTime = { lastFrame: initialDefaultFrame, lastIndex: 0, value: ut }, expressionHelpers.searchExpressions(at, dt, ct), ct.k && xt.addDynamicProperty(ct), ct }; function nt(at) { return this._cachingAtTime || (this._cachingAtTime = { shapeValue: shapePool.clone(this.pv), lastIndex: 0, lastTime: initialDefaultFrame }), at *= this.elem.globalData.frameRate, at -= this.offsetTime, at !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < at ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = at, this.interpolateShape(at, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue } var it = ShapePropertyFactory.getConstructorFunction(), st = ShapePropertyFactory.getKeyframedConstructorFunction(); function ot() { } ot.prototype = { vertices: function (dt, pt) { this.k && this.getValue(); var ht = this.v; pt !== void 0 && (ht = this.getValueAtTime(pt, 0)); var xt, ct = ht._length, ut = ht[dt], lt = ht.v, mt = createSizedArray(ct); for (xt = 0; xt < ct; xt += 1)dt === "i" || dt === "o" ? mt[xt] = [ut[xt][0] - lt[xt][0], ut[xt][1] - lt[xt][1]] : mt[xt] = [ut[xt][0], ut[xt][1]]; return mt }, points: function (dt) { return this.vertices("v", dt) }, inTangents: function (dt) { return this.vertices("i", dt) }, outTangents: function (dt) { return this.vertices("o", dt) }, isClosed: function () { return this.v.c }, pointOnPath: function (dt, pt) { var ht = this.v; pt !== void 0 && (ht = this.getValueAtTime(pt, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(ht)); for (var xt = this._segmentsLength, ct = xt.lengths, ut = xt.totalLength * dt, lt = 0, mt = ct.length, yt = 0, gt; lt < mt;) { if (yt + ct[lt].addedLength > ut) { var St = lt, bt = ht.c && lt === mt - 1 ? 0 : lt + 1, _t = (ut - yt) / ct[lt].addedLength; gt = bez.getPointInSegment(ht.v[St], ht.v[bt], ht.o[St], ht.i[bt], _t, ct[lt]); break } else yt += ct[lt].addedLength; lt += 1 } return gt || (gt = ht.c ? [ht.v[0][0], ht.v[0][1]] : [ht.v[ht._length - 1][0], ht.v[ht._length - 1][1]]), gt }, vectorOnPath: function (dt, pt, ht) { dt == 1 ? dt = this.v.c : dt == 0 && (dt = .999); var xt = this.pointOnPath(dt, pt), ct = this.pointOnPath(dt + .001, pt), ut = ct[0] - xt[0], lt = ct[1] - xt[1], mt = Math.sqrt(Math.pow(ut, 2) + Math.pow(lt, 2)); if (mt === 0) return [0, 0]; var yt = ht === "tangent" ? [ut / mt, lt / mt] : [-lt / mt, ut / mt]; return yt }, tangentOnPath: function (dt, pt) { return this.vectorOnPath(dt, pt, "tangent") }, normalOnPath: function (dt, pt) { return this.vectorOnPath(dt, pt, "normal") }, setGroupProperty: expressionHelpers.setGroupProperty, getValueAtTime: expressionHelpers.getStaticValueAtTime }, extendPrototype([ot], it), extendPrototype([ot], st), st.prototype.getValueAtTime = nt, st.prototype.initiateExpression = ExpressionManager.initiateExpression; var ft = ShapePropertyFactory.getShapeProp; ShapePropertyFactory.getShapeProp = function (at, dt, pt, ht, xt) { var ct = ft(at, dt, pt, ht, xt); return ct.propertyIndex = dt.ix, ct.lock = !1, pt === 3 ? expressionHelpers.searchExpressions(at, dt.pt, ct) : pt === 4 && expressionHelpers.searchExpressions(at, dt.ks, ct), ct.k && at.addDynamicProperty(ct), ct } } function initialize$1() { addPropertyDecorator() } function addDecorator() { function _() { return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null } TextProperty.prototype.getExpressionValue = function (j, $) { var _e = this.calculateExpression($); if (j.t !== _e) { var et = {}; return this.copyData(et, j), et.t = _e.toString(), et.__complete = !1, et } return j }, TextProperty.prototype.searchProperty = function () { var j = this.searchKeyframes(), $ = this.searchExpressions(); return this.kf = j || $, this.kf }, TextProperty.prototype.searchExpressions = _ } function initialize() { addDecorator() } function SVGComposableEffect() { } SVGComposableEffect.prototype = { createMergeNode: function _(j, $) { var _e = createNS("feMerge"); _e.setAttribute("result", j); var et, tt; for (tt = 0; tt < $.length; tt += 1)et = createNS("feMergeNode"), et.setAttribute("in", $[tt]), _e.appendChild(et), _e.appendChild(et); return _e } }; var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0"; function SVGTintFilter(_, j, $, _e, et) { this.filterManager = j; var tt = createNS("feColorMatrix"); tt.setAttribute("type", "matrix"), tt.setAttribute("color-interpolation-filters", "linearRGB"), tt.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = tt, tt.setAttribute("result", _e + "_tint_1"), _.appendChild(tt), tt = createNS("feColorMatrix"), tt.setAttribute("type", "matrix"), tt.setAttribute("color-interpolation-filters", "sRGB"), tt.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), tt.setAttribute("result", _e + "_tint_2"), _.appendChild(tt), this.matrixFilter = tt; var rt = this.createMergeNode(_e, [et, _e + "_tint_1", _e + "_tint_2"]); _.appendChild(rt) } extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function (_) { if (_ || this.filterManager._mdf) { var j = this.filterManager.effectElements[0].p.v, $ = this.filterManager.effectElements[1].p.v, _e = this.filterManager.effectElements[2].p.v / 100; this.linearFilter.setAttribute("values", linearFilterValue + " " + _e + " 0"), this.matrixFilter.setAttribute("values", $[0] - j[0] + " 0 0 0 " + j[0] + " " + ($[1] - j[1]) + " 0 0 0 " + j[1] + " " + ($[2] - j[2]) + " 0 0 0 " + j[2] + " 0 0 0 1 0") } }; function SVGFillFilter(_, j, $, _e) { this.filterManager = j; var et = createNS("feColorMatrix"); et.setAttribute("type", "matrix"), et.setAttribute("color-interpolation-filters", "sRGB"), et.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), et.setAttribute("result", _e), _.appendChild(et), this.matrixFilter = et } SVGFillFilter.prototype.renderFrame = function (_) { if (_ || this.filterManager._mdf) { var j = this.filterManager.effectElements[2].p.v, $ = this.filterManager.effectElements[6].p.v; this.matrixFilter.setAttribute("values", "0 0 0 0 " + j[0] + " 0 0 0 0 " + j[1] + " 0 0 0 0 " + j[2] + " 0 0 0 " + $ + " 0") } }; function SVGStrokeEffect(_, j, $) { this.initialized = !1, this.filterManager = j, this.elem = $, this.paths = [] } SVGStrokeEffect.prototype.initialize = function () { var _ = this.elem.layerElement.children || this.elem.layerElement.childNodes, j, $, _e, et; for (this.filterManager.effectElements[1].p.v === 1 ? (et = this.elem.maskManager.masksProperties.length, _e = 0) : (_e = this.filterManager.effectElements[0].p.v - 1, et = _e + 1), $ = createNS("g"), $.setAttribute("fill", "none"), $.setAttribute("stroke-linecap", "round"), $.setAttribute("stroke-dashoffset", 1), _e; _e < et; _e += 1)j = createNS("path"), $.appendChild(j), this.paths.push({ p: j, m: _e }); if (this.filterManager.effectElements[10].p.v === 3) { var tt = createNS("mask"), rt = createElementID(); tt.setAttribute("id", rt), tt.setAttribute("mask-type", "alpha"), tt.appendChild($), this.elem.globalData.defs.appendChild(tt); var nt = createNS("g"); for (nt.setAttribute("mask", "url(" + getLocationHref() + "#" + rt + ")"); _[0];)nt.appendChild(_[0]); this.elem.layerElement.appendChild(nt), this.masker = tt, $.setAttribute("stroke", "#fff") } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) { if (this.filterManager.effectElements[10].p.v === 2) for (_ = this.elem.layerElement.children || this.elem.layerElement.childNodes; _.length;)this.elem.layerElement.removeChild(_[0]); this.elem.layerElement.appendChild($), this.elem.layerElement.removeAttribute("mask"), $.setAttribute("stroke", "#fff") } this.initialized = !0, this.pathMasker = $ }, SVGStrokeEffect.prototype.renderFrame = function (_) { this.initialized || this.initialize(); var j, $ = this.paths.length, _e, et; for (j = 0; j < $; j += 1)if (this.paths[j].m !== -1 && (_e = this.elem.maskManager.viewData[this.paths[j].m], et = this.paths[j].p, (_ || this.filterManager._mdf || _e.prop._mdf) && et.setAttribute("d", _e.lastPath), _ || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || _e.prop._mdf)) { var tt; if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) { var rt = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01, nt = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01, it = et.getTotalLength(); tt = "0 0 0 " + it * rt + " "; var st = it * (nt - rt), ot = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, ft = Math.floor(st / ot), at; for (at = 0; at < ft; at += 1)tt += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " "; tt += "0 " + it * 10 + " 0 0" } else tt = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01; et.setAttribute("stroke-dasharray", tt) } if ((_ || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (_ || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (_ || this.filterManager.effectElements[3].p._mdf)) { var dt = this.filterManager.effectElements[3].p.v; this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(dt[0] * 255) + "," + bmFloor(dt[1] * 255) + "," + bmFloor(dt[2] * 255) + ")") } }; function SVGTritoneFilter(_, j, $, _e) { this.filterManager = j; var et = createNS("feColorMatrix"); et.setAttribute("type", "matrix"), et.setAttribute("color-interpolation-filters", "linearRGB"), et.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), _.appendChild(et); var tt = createNS("feComponentTransfer"); tt.setAttribute("color-interpolation-filters", "sRGB"), tt.setAttribute("result", _e), this.matrixFilter = tt; var rt = createNS("feFuncR"); rt.setAttribute("type", "table"), tt.appendChild(rt), this.feFuncR = rt; var nt = createNS("feFuncG"); nt.setAttribute("type", "table"), tt.appendChild(nt), this.feFuncG = nt; var it = createNS("feFuncB"); it.setAttribute("type", "table"), tt.appendChild(it), this.feFuncB = it, _.appendChild(tt) } SVGTritoneFilter.prototype.renderFrame = function (_) { if (_ || this.filterManager._mdf) { var j = this.filterManager.effectElements[0].p.v, $ = this.filterManager.effectElements[1].p.v, _e = this.filterManager.effectElements[2].p.v, et = _e[0] + " " + $[0] + " " + j[0], tt = _e[1] + " " + $[1] + " " + j[1], rt = _e[2] + " " + $[2] + " " + j[2]; this.feFuncR.setAttribute("tableValues", et), this.feFuncG.setAttribute("tableValues", tt), this.feFuncB.setAttribute("tableValues", rt) } }; function SVGProLevelsFilter(_, j, $, _e) { this.filterManager = j; var et = this.filterManager.effectElements, tt = createNS("feComponentTransfer"); (et[10].p.k || et[10].p.v !== 0 || et[11].p.k || et[11].p.v !== 1 || et[12].p.k || et[12].p.v !== 1 || et[13].p.k || et[13].p.v !== 0 || et[14].p.k || et[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", tt)), (et[17].p.k || et[17].p.v !== 0 || et[18].p.k || et[18].p.v !== 1 || et[19].p.k || et[19].p.v !== 1 || et[20].p.k || et[20].p.v !== 0 || et[21].p.k || et[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", tt)), (et[24].p.k || et[24].p.v !== 0 || et[25].p.k || et[25].p.v !== 1 || et[26].p.k || et[26].p.v !== 1 || et[27].p.k || et[27].p.v !== 0 || et[28].p.k || et[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", tt)), (et[31].p.k || et[31].p.v !== 0 || et[32].p.k || et[32].p.v !== 1 || et[33].p.k || et[33].p.v !== 1 || et[34].p.k || et[34].p.v !== 0 || et[35].p.k || et[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", tt)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (tt.setAttribute("color-interpolation-filters", "sRGB"), _.appendChild(tt)), (et[3].p.k || et[3].p.v !== 0 || et[4].p.k || et[4].p.v !== 1 || et[5].p.k || et[5].p.v !== 1 || et[6].p.k || et[6].p.v !== 0 || et[7].p.k || et[7].p.v !== 1) && (tt = createNS("feComponentTransfer"), tt.setAttribute("color-interpolation-filters", "sRGB"), tt.setAttribute("result", _e), _.appendChild(tt), this.feFuncRComposed = this.createFeFunc("feFuncR", tt), this.feFuncGComposed = this.createFeFunc("feFuncG", tt), this.feFuncBComposed = this.createFeFunc("feFuncB", tt)) } SVGProLevelsFilter.prototype.createFeFunc = function (_, j) { var $ = createNS(_); return $.setAttribute("type", "table"), j.appendChild($), $ }, SVGProLevelsFilter.prototype.getTableValue = function (_, j, $, _e, et) { for (var tt = 0, rt = 256, nt, it = Math.min(_, j), st = Math.max(_, j), ot = Array.call(null, { length: rt }), ft, at = 0, dt = et - _e, pt = j - _; tt <= 256;)nt = tt / 256, nt <= it ? ft = pt < 0 ? et : _e : nt >= st ? ft = pt < 0 ? _e : et : ft = _e + dt * Math.pow((nt - _) / pt, 1 / $), ot[at] = ft, at += 1, tt += 256 / (rt - 1); return ot.join(" ") }, SVGProLevelsFilter.prototype.renderFrame = function (_) { if (_ || this.filterManager._mdf) { var j, $ = this.filterManager.effectElements; this.feFuncRComposed && (_ || $[3].p._mdf || $[4].p._mdf || $[5].p._mdf || $[6].p._mdf || $[7].p._mdf) && (j = this.getTableValue($[3].p.v, $[4].p.v, $[5].p.v, $[6].p.v, $[7].p.v), this.feFuncRComposed.setAttribute("tableValues", j), this.feFuncGComposed.setAttribute("tableValues", j), this.feFuncBComposed.setAttribute("tableValues", j)), this.feFuncR && (_ || $[10].p._mdf || $[11].p._mdf || $[12].p._mdf || $[13].p._mdf || $[14].p._mdf) && (j = this.getTableValue($[10].p.v, $[11].p.v, $[12].p.v, $[13].p.v, $[14].p.v), this.feFuncR.setAttribute("tableValues", j)), this.feFuncG && (_ || $[17].p._mdf || $[18].p._mdf || $[19].p._mdf || $[20].p._mdf || $[21].p._mdf) && (j = this.getTableValue($[17].p.v, $[18].p.v, $[19].p.v, $[20].p.v, $[21].p.v), this.feFuncG.setAttribute("tableValues", j)), this.feFuncB && (_ || $[24].p._mdf || $[25].p._mdf || $[26].p._mdf || $[27].p._mdf || $[28].p._mdf) && (j = this.getTableValue($[24].p.v, $[25].p.v, $[26].p.v, $[27].p.v, $[28].p.v), this.feFuncB.setAttribute("tableValues", j)), this.feFuncA && (_ || $[31].p._mdf || $[32].p._mdf || $[33].p._mdf || $[34].p._mdf || $[35].p._mdf) && (j = this.getTableValue($[31].p.v, $[32].p.v, $[33].p.v, $[34].p.v, $[35].p.v), this.feFuncA.setAttribute("tableValues", j)) } }; function SVGDropShadowEffect(_, j, $, _e, et) { var tt = j.container.globalData.renderConfig.filterSize, rt = j.data.fs || tt; _.setAttribute("x", rt.x || tt.x), _.setAttribute("y", rt.y || tt.y), _.setAttribute("width", rt.width || tt.width), _.setAttribute("height", rt.height || tt.height), this.filterManager = j; var nt = createNS("feGaussianBlur"); nt.setAttribute("in", "SourceAlpha"), nt.setAttribute("result", _e + "_drop_shadow_1"), nt.setAttribute("stdDeviation", "0"), this.feGaussianBlur = nt, _.appendChild(nt); var it = createNS("feOffset"); it.setAttribute("dx", "25"), it.setAttribute("dy", "0"), it.setAttribute("in", _e + "_drop_shadow_1"), it.setAttribute("result", _e + "_drop_shadow_2"), this.feOffset = it, _.appendChild(it); var st = createNS("feFlood"); st.setAttribute("flood-color", "#00ff00"), st.setAttribute("flood-opacity", "1"), st.setAttribute("result", _e + "_drop_shadow_3"), this.feFlood = st, _.appendChild(st); var ot = createNS("feComposite"); ot.setAttribute("in", _e + "_drop_shadow_3"), ot.setAttribute("in2", _e + "_drop_shadow_2"), ot.setAttribute("operator", "in"), ot.setAttribute("result", _e + "_drop_shadow_4"), _.appendChild(ot); var ft = this.createMergeNode(_e, [_e + "_drop_shadow_4", et]); _.appendChild(ft) } extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function (_) { if (_ || this.filterManager._mdf) { if ((_ || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), _ || this.filterManager.effectElements[0].p._mdf) { var j = this.filterManager.effectElements[0].p.v; this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(j[0] * 255), Math.round(j[1] * 255), Math.round(j[2] * 255))) } if ((_ || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), _ || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) { var $ = this.filterManager.effectElements[3].p.v, _e = (this.filterManager.effectElements[2].p.v - 90) * degToRads, et = $ * Math.cos(_e), tt = $ * Math.sin(_e); this.feOffset.setAttribute("dx", et), this.feOffset.setAttribute("dy", tt) } } }; var _svgMatteSymbols = []; function SVGMatte3Effect(_, j, $) { this.initialized = !1, this.filterManager = j, this.filterElem = _, this.elem = $, $.matteElement = createNS("g"), $.matteElement.appendChild($.layerElement), $.matteElement.appendChild($.transformedElement), $.baseElement = $.matteElement } SVGMatte3Effect.prototype.findSymbol = function (_) { for (var j = 0, $ = _svgMatteSymbols.length; j < $;) { if (_svgMatteSymbols[j] === _) return _svgMatteSymbols[j]; j += 1 } return null }, SVGMatte3Effect.prototype.replaceInParent = function (_, j) { var $ = _.layerElement.parentNode; if ($) { for (var _e = $.children, et = 0, tt = _e.length; et < tt && _e[et] !== _.layerElement;)et += 1; var rt; et <= tt - 2 && (rt = _e[et + 1]); var nt = createNS("use"); nt.setAttribute("href", "#" + j), rt ? $.insertBefore(nt, rt) : $.appendChild(nt) } }, SVGMatte3Effect.prototype.setElementAsMask = function (_, j) { if (!this.findSymbol(j)) { var $ = createElementID(), _e = createNS("mask"); _e.setAttribute("id", j.layerId), _e.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(j); var et = _.globalData.defs; et.appendChild(_e); var tt = createNS("symbol"); tt.setAttribute("id", $), this.replaceInParent(j, $), tt.appendChild(j.layerElement), et.appendChild(tt); var rt = createNS("use"); rt.setAttribute("href", "#" + $), _e.appendChild(rt), j.data.hd = !1, j.show() } _.setMatte(j.layerId) }, SVGMatte3Effect.prototype.initialize = function () { for (var _ = this.filterManager.effectElements[0].p.v, j = this.elem.comp.elements, $ = 0, _e = j.length; $ < _e;)j[$] && j[$].data.ind === _ && this.setElementAsMask(this.elem, j[$]), $ += 1; this.initialized = !0 }, SVGMatte3Effect.prototype.renderFrame = function () { this.initialized || this.initialize() }; function SVGGaussianBlurEffect(_, j, $, _e) { _.setAttribute("x", "-100%"), _.setAttribute("y", "-100%"), _.setAttribute("width", "300%"), _.setAttribute("height", "300%"), this.filterManager = j; var et = createNS("feGaussianBlur"); et.setAttribute("result", _e), _.appendChild(et), this.feGaussianBlur = et } SVGGaussianBlurEffect.prototype.renderFrame = function (_) { if (_ || this.filterManager._mdf) { var j = .3, $ = this.filterManager.effectElements[0].p.v * j, _e = this.filterManager.effectElements[1].p.v, et = _e == 3 ? 0 : $, tt = _e == 2 ? 0 : $; this.feGaussianBlur.setAttribute("stdDeviation", et + " " + tt); var rt = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate"; this.feGaussianBlur.setAttribute("edgeMode", rt) } }; function TransformEffect() { } TransformEffect.prototype.init = function (_) { this.effectsManager = _, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix, this.opacity = -1, this._mdf = !1, this._opMdf = !1 }, TransformEffect.prototype.renderFrame = function (_) { if (this._opMdf = !1, this._mdf = !1, _ || this.effectsManager._mdf) { var j = this.effectsManager.effectElements, $ = j[0].p.v, _e = j[1].p.v, et = j[2].p.v === 1, tt = j[3].p.v, rt = et ? tt : j[4].p.v, nt = j[5].p.v, it = j[6].p.v, st = j[7].p.v; this.matrix.reset(), this.matrix.translate(-$[0], -$[1], $[2]), this.matrix.scale(rt * .01, tt * .01, 1), this.matrix.rotate(-st * degToRads), this.matrix.skewFromAxis(-nt * degToRads, (it + 90) * degToRads), this.matrix.translate(_e[0], _e[1], 0), this._mdf = !0, this.opacity !== j[8].p.v && (this.opacity = j[8].p.v, this._opMdf = !0) } }; function SVGTransformEffect(_, j) { this.init(j) } extendPrototype([TransformEffect], SVGTransformEffect); function CVTransformEffect(_) { this.init(_) } return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie
  })
})(lottie$1, lottie$1.exports); var lottieExports = lottie$1.exports; const lottie = getDefaultExportFromCjs(lottieExports); function _iterableToArrayLimit(_, j) { var $ = _ == null ? null : typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"]; if ($ != null) { var _e, et, tt, rt, nt = [], it = !0, st = !1; try { if (tt = ($ = $.call(_)).next, j === 0) { if (Object($) !== $) return; it = !1 } else for (; !(it = (_e = tt.call($)).done) && (nt.push(_e.value), nt.length !== j); it = !0); } catch (ot) { st = !0, et = ot } finally { try { if (!it && $.return != null && (rt = $.return(), Object(rt) !== rt)) return } finally { if (st) throw et } } return nt } } function ownKeys$1(_, j) { var $ = Object.keys(_); if (Object.getOwnPropertySymbols) { var _e = Object.getOwnPropertySymbols(_); j && (_e = _e.filter(function (et) { return Object.getOwnPropertyDescriptor(_, et).enumerable })), $.push.apply($, _e) } return $ } function _objectSpread2(_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j] != null ? arguments[j] : {}; j % 2 ? ownKeys$1(Object($), !0).forEach(function (_e) { _defineProperty$1(_, _e, $[_e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors($)) : ownKeys$1(Object($)).forEach(function (_e) { Object.defineProperty(_, _e, Object.getOwnPropertyDescriptor($, _e)) }) } return _ } function _defineProperty$1(_, j, $) { return j = _toPropertyKey$1(j), j in _ ? Object.defineProperty(_, j, { value: $, enumerable: !0, configurable: !0, writable: !0 }) : _[j] = $, _ } function _objectWithoutPropertiesLoose$2(_, j) { if (_ == null) return {}; var $ = {}, _e = Object.keys(_), et, tt; for (tt = 0; tt < _e.length; tt++)et = _e[tt], !(j.indexOf(et) >= 0) && ($[et] = _[et]); return $ } function _objectWithoutProperties$1(_, j) { if (_ == null) return {}; var $ = _objectWithoutPropertiesLoose$2(_, j), _e, et; if (Object.getOwnPropertySymbols) { var tt = Object.getOwnPropertySymbols(_); for (et = 0; et < tt.length; et++)_e = tt[et], !(j.indexOf(_e) >= 0) && Object.prototype.propertyIsEnumerable.call(_, _e) && ($[_e] = _[_e]) } return $ } function _slicedToArray(_, j) { return _arrayWithHoles(_) || _iterableToArrayLimit(_, j) || _unsupportedIterableToArray(_, j) || _nonIterableRest() } function _arrayWithHoles(_) { if (Array.isArray(_)) return _ } function _unsupportedIterableToArray(_, j) { if (_) { if (typeof _ == "string") return _arrayLikeToArray(_, j); var $ = Object.prototype.toString.call(_).slice(8, -1); if ($ === "Object" && _.constructor && ($ = _.constructor.name), $ === "Map" || $ === "Set") return Array.from(_); if ($ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test($)) return _arrayLikeToArray(_, j) } } function _arrayLikeToArray(_, j) { (j == null || j > _.length) && (j = _.length); for (var $ = 0, _e = new Array(j); $ < j; $++)_e[$] = _[$]; return _e } function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function _toPrimitive$1(_, j) { if (typeof _ != "object" || _ === null) return _; var $ = _[Symbol.toPrimitive]; if ($ !== void 0) { var _e = $.call(_, j || "default"); if (typeof _e != "object") return _e; throw new TypeError("@@toPrimitive must return a primitive value.") } return (j === "string" ? String : Number)(_) } function _toPropertyKey$1(_) { var j = _toPrimitive$1(_, "string"); return typeof j == "symbol" ? j : String(j) } var _excluded$1$1 = ["animationData", "loop", "autoplay", "initialSegment", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart", "onConfigReady", "onDataReady", "onDataFailed", "onLoadedImages", "onDOMLoaded", "onDestroy", "lottieRef", "renderer", "name", "assetsPath", "rendererSettings"], useLottie = function _(j, $) { var _e = j.animationData, et = j.loop, tt = j.autoplay, rt = j.initialSegment, nt = j.onComplete, it = j.onLoopComplete, st = j.onEnterFrame, ot = j.onSegmentStart, ft = j.onConfigReady, at = j.onDataReady, dt = j.onDataFailed, pt = j.onLoadedImages, ht = j.onDOMLoaded, xt = j.onDestroy; j.lottieRef, j.renderer, j.name, j.assetsPath, j.rendererSettings; var ct = _objectWithoutProperties$1(j, _excluded$1$1), ut = reactExports.useState(!1), lt = _slicedToArray(ut, 2), mt = lt[0], yt = lt[1], gt = reactExports.useRef(), St = reactExports.useRef(null), bt = function () { var Tt; (Tt = gt.current) === null || Tt === void 0 || Tt.play() }, _t = function () { var Tt; (Tt = gt.current) === null || Tt === void 0 || Tt.stop() }, Mt = function () { var Tt; (Tt = gt.current) === null || Tt === void 0 || Tt.pause() }, It = function (Tt) { var jt; (jt = gt.current) === null || jt === void 0 || jt.setSpeed(Tt) }, Rt = function (Tt, jt) { var Ft; (Ft = gt.current) === null || Ft === void 0 || Ft.goToAndPlay(Tt, jt) }, Lt = function (Tt, jt) { var Ft; (Ft = gt.current) === null || Ft === void 0 || Ft.goToAndStop(Tt, jt) }, Vt = function (Tt) { var jt; (jt = gt.current) === null || jt === void 0 || jt.setDirection(Tt) }, At = function (Tt, jt) { var Ft; (Ft = gt.current) === null || Ft === void 0 || Ft.playSegments(Tt, jt) }, Pt = function (Tt) { var jt; (jt = gt.current) === null || jt === void 0 || jt.setSubframe(Tt) }, kt = function (Tt) { var jt; return (jt = gt.current) === null || jt === void 0 ? void 0 : jt.getDuration(Tt) }, vt = function () { var Tt; (Tt = gt.current) === null || Tt === void 0 || Tt.destroy(), gt.current = void 0 }, Et = function () { var Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, jt; if (St.current) { (jt = gt.current) === null || jt === void 0 || jt.destroy(); var Ft = _objectSpread2(_objectSpread2(_objectSpread2({}, j), Tt), {}, { container: St.current }); return gt.current = lottie.loadAnimation(Ft), yt(!!gt.current), function () { var Dt; (Dt = gt.current) === null || Dt === void 0 || Dt.destroy(), gt.current = void 0 } } }; reactExports.useEffect(function () { var wt = Et(); return function () { return wt == null ? void 0 : wt() } }, [_e, et]), reactExports.useEffect(function () { gt.current && (gt.current.autoplay = !!tt) }, [tt]), reactExports.useEffect(function () { if (gt.current) { if (!rt) { gt.current.resetSegments(!0); return } !Array.isArray(rt) || !rt.length || ((gt.current.currentRawFrame < rt[0] || gt.current.currentRawFrame > rt[1]) && (gt.current.currentRawFrame = rt[0]), gt.current.setSegment(rt[0], rt[1])) } }, [rt]), reactExports.useEffect(function () { var wt = [{ name: "complete", handler: nt }, { name: "loopComplete", handler: it }, { name: "enterFrame", handler: st }, { name: "segmentStart", handler: ot }, { name: "config_ready", handler: ft }, { name: "data_ready", handler: at }, { name: "data_failed", handler: dt }, { name: "loaded_images", handler: pt }, { name: "DOMLoaded", handler: ht }, { name: "destroy", handler: xt }], Tt = wt.filter(function (Ft) { return Ft.handler != null }); if (Tt.length) { var jt = Tt.map(function (Ft) { var Dt; return (Dt = gt.current) === null || Dt === void 0 || Dt.addEventListener(Ft.name, Ft.handler), function () { var Ot; (Ot = gt.current) === null || Ot === void 0 || Ot.removeEventListener(Ft.name, Ft.handler) } }); return function () { jt.forEach(function (Ft) { return Ft() }) } } }, [nt, it, st, ot, ft, at, dt, pt, ht, xt]); var Ct = React$1.createElement("div", _objectSpread2({ style: $, ref: St }, ct)); return { View: Ct, play: bt, stop: _t, pause: Mt, setSpeed: It, goToAndStop: Lt, goToAndPlay: Rt, setDirection: Vt, playSegments: At, setSubframe: Pt, getDuration: kt, destroy: vt, animationContainerRef: St, animationLoaded: mt, animationItem: gt.current } }; function getContainerVisibility(_) { var j = _.getBoundingClientRect(), $ = j.top, _e = j.height, et = window.innerHeight - $, tt = window.innerHeight + _e; return et / tt } function getContainerCursorPosition(_, j, $) { var _e = _.getBoundingClientRect(), et = _e.top, tt = _e.left, rt = _e.width, nt = _e.height, it = (j - tt) / rt, st = ($ - et) / nt; return { x: it, y: st } } var useInitInteractivity = function _(j) {
  var $ = j.wrapperRef, _e = j.animationItem, et = j.mode, tt = j.actions; reactExports.useEffect(function () {
    var rt = $.current; if (!(!rt || !_e || !tt.length)) {
      _e.stop(); var nt = function () {
        var ot = null, ft = function () {
          var dt = getContainerVisibility(rt), pt = tt.find(function (xt) { var ct = xt.visibility; return ct && dt >= ct[0] && dt <= ct[1] }); if (pt) {
            if (pt.type === "seek" && pt.visibility && pt.frames.length === 2) {
              var ht = pt.frames[0] + Math.ceil((dt - pt.visibility[0]) / (pt.visibility[1] - pt.visibility[0]) * pt.frames[1]);//! goToAndStop must be relative to the start of the current segment
              _e.goToAndStop(ht - _e.firstFrame - 1, !0)
            } pt.type === "loop" && (ot === null || ot !== pt.frames || _e.isPaused) && (_e.playSegments(pt.frames, !0), ot = pt.frames), pt.type === "play" && _e.isPaused && (_e.resetSegments(!0), _e.play()), pt.type === "stop" && _e.goToAndStop(pt.frames[0] - _e.firstFrame - 1, !0)
          }
        }; return document.addEventListener("scroll", ft), function () { document.removeEventListener("scroll", ft) }
      }, it = function () { var ot = function (pt, ht) { var xt = pt, ct = ht; if (xt !== -1 && ct !== -1) { var ut = getContainerCursorPosition(rt, xt, ct); xt = ut.x, ct = ut.y } var lt = tt.find(function (gt) { var St = gt.position; return St && Array.isArray(St.x) && Array.isArray(St.y) ? xt >= St.x[0] && xt <= St.x[1] && ct >= St.y[0] && ct <= St.y[1] : St && !Number.isNaN(St.x) && !Number.isNaN(St.y) ? xt === St.x && ct === St.y : !1 }); if (lt) { if (lt.type === "seek" && lt.position && Array.isArray(lt.position.x) && Array.isArray(lt.position.y) && lt.frames.length === 2) { var mt = (xt - lt.position.x[0]) / (lt.position.x[1] - lt.position.x[0]), yt = (ct - lt.position.y[0]) / (lt.position.y[1] - lt.position.y[0]); _e.playSegments(lt.frames, !0), _e.goToAndStop(Math.ceil((mt + yt) / 2 * (lt.frames[1] - lt.frames[0])), !0) } lt.type === "loop" && _e.playSegments(lt.frames, !0), lt.type === "play" && (_e.isPaused && _e.resetSegments(!1), _e.playSegments(lt.frames)), lt.type === "stop" && _e.goToAndStop(lt.frames[0], !0) } }, ft = function (pt) { ot(pt.clientX, pt.clientY) }, at = function () { ot(-1, -1) }; return rt.addEventListener("mousemove", ft), rt.addEventListener("mouseout", at), function () { rt.removeEventListener("mousemove", ft), rt.removeEventListener("mouseout", at) } }; switch (et) { case "scroll": return nt(); case "cursor": return it() }
    }
  }, [et, _e])
}, useLottieInteractivity = function _(j) { var $ = j.actions, _e = j.mode, et = j.lottieObj, tt = et.animationItem, rt = et.View, nt = et.animationContainerRef; return useInitInteractivity({ actions: $, animationItem: tt, mode: _e, wrapperRef: nt }), rt }, _excluded$2 = ["style", "interactivity"], Lottie = function _(j) { var $, _e, et, tt = j.style, rt = j.interactivity, nt = _objectWithoutProperties$1(j, _excluded$2), it = useLottie(nt, tt), st = it.View, ot = it.play, ft = it.stop, at = it.pause, dt = it.setSpeed, pt = it.goToAndStop, ht = it.goToAndPlay, xt = it.setDirection, ct = it.playSegments, ut = it.setSubframe, lt = it.getDuration, mt = it.destroy, yt = it.animationContainerRef, gt = it.animationLoaded, St = it.animationItem; return reactExports.useEffect(function () { j.lottieRef && (j.lottieRef.current = { play: ot, stop: ft, pause: at, setSpeed: dt, goToAndPlay: ht, goToAndStop: pt, setDirection: xt, playSegments: ct, setSubframe: ut, getDuration: lt, destroy: mt, animationContainerRef: yt, animationLoaded: gt, animationItem: St }) }, [($ = j.lottieRef) === null || $ === void 0 ? void 0 : $.current]), useLottieInteractivity({ lottieObj: { View: st, play: ot, stop: ft, pause: at, setSpeed: dt, goToAndStop: pt, goToAndPlay: ht, setDirection: xt, playSegments: ct, setSubframe: ut, getDuration: lt, destroy: mt, animationContainerRef: yt, animationLoaded: gt, animationItem: St }, actions: (_e = rt == null ? void 0 : rt.actions) !== null && _e !== void 0 ? _e : [], mode: (et = rt == null ? void 0 : rt.mode) !== null && et !== void 0 ? et : "scroll" }) }; const v$4 = "5.5.0", fr$1 = 60, ip$1 = 0, op$1 = 90, w$2 = 50, h$4 = 80, nm$1 = "ScrollAnimation", ddd$1 = 0, assets$1 = [], layers$1 = [{ ddd: 0, ind: 1, ty: 4, nm: "Dot", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 1, k: [{ i: { x: .505, y: 1 }, o: { x: .655, y: 0 }, t: 0, s: [25, 22, 0], to: [0, 5.958, 0], ti: [0, -5.958, 0] }, { t: 89, s: [25, 57.75, 0] }], ix: 2 }, a: { a: 0, k: [25, 22, 0], ix: 1 }, s: { a: 1, k: [{ i: { x: [0, 0, .833], y: [1, 1, 1] }, o: { x: [.167, .167, .167], y: [0, 0, 0] }, t: 6, s: [0, 0, 100] }, { i: { x: [.833, .833, .833], y: [1, 1, 1] }, o: { x: [.167, .167, .167], y: [0, 0, 0] }, t: 26, s: [100, 100, 100] }, { i: { x: [.667, .667, .667], y: [1, 1, 1] }, o: { x: [1, 1, .333], y: [0, 0, 0] }, t: 55, s: [100, 100, 100] }, { t: 79, s: [0, 0, 100] }], ix: 6 } }, ao: 0, shapes: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, -2.761], [2.762, 0], [0, 2.761], [-2.761, 0]], o: [[0, 2.761], [-2.761, 0], [0, -2.761], [2.762, 0]], v: [[30, 22], [25, 27], [20, 22], [25, 17]], c: !0 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }], ip: 0, op: 90, st: 0, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "Outline", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [25, 40, 0], ix: 2 }, a: { a: 0, k: [25, 40, 0], ix: 1 }, s: { a: 0, k: [100, 100, 100], ix: 6 } }, ao: 0, shapes: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[13.807, 0], [0, 0], [0, -13.807], [0, 0], [-13.807, 0], [0, 13.807], [0, 0]], o: [[0, 0], [-13.807, 0], [0, 0], [0, 13.807], [13.807, 0], [0, 0], [0, -13.807]], v: [[25, 0], [25, 0], [0, 25], [0, 55], [25, 80], [50, 55], [50, 25]], c: !0 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ind: 1, ty: "sh", ix: 2, ks: { a: 0, k: { i: [[-11.028, 0], [0, -11.028], [0, 0], [11.028, 0], [0, 11.028], [0, 0]], o: [[11.028, 0], [0, 0], [0, 11.028], [-11.028, 0], [0, 0], [0, -11.028]], v: [[25, 5], [45, 25], [45, 55], [25, 75], [5, 55], [5, 25]], c: !0 }, ix: 2 }, nm: "Path 2", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "mm", mm: 1, nm: "Merge Paths 1", mn: "ADBE Vector Filter - Merge", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }], ip: 0, op: 90, st: 0, bm: 0 }], markers$1 = [], scroll2 = { v: v$4, fr: fr$1, ip: ip$1, op: op$1, w: w$2, h: h$4, nm: nm$1, ddd: ddd$1, assets: assets$1, layers: layers$1, markers: markers$1 }; var classnames$1 = { exports: {} };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function (_) { (function () { var j = {}.hasOwnProperty; function $() { for (var tt = "", rt = 0; rt < arguments.length; rt++) { var nt = arguments[rt]; nt && (tt = et(tt, _e(nt))) } return tt } function _e(tt) { if (typeof tt == "string" || typeof tt == "number") return tt; if (typeof tt != "object") return ""; if (Array.isArray(tt)) return $.apply(null, tt); if (tt.toString !== Object.prototype.toString && !tt.toString.toString().includes("[native code]")) return tt.toString(); var rt = ""; for (var nt in tt) j.call(tt, nt) && tt[nt] && (rt = et(rt, nt)); return rt } function et(tt, rt) { return rt ? tt ? tt + " " + rt : tt + rt : tt } _.exports ? ($.default = $, _.exports = $) : window.classNames = $ })() })(classnames$1); var classnamesExports = classnames$1.exports; const classNames = getDefaultExportFromCjs(classnamesExports), DEFAULT_BREAKPOINTS = ["xxl", "xl", "lg", "md", "sm", "xs"], DEFAULT_MIN_BREAKPOINT = "xs", ThemeContext$1 = reactExports.createContext({ prefixes: {}, breakpoints: DEFAULT_BREAKPOINTS, minBreakpoint: DEFAULT_MIN_BREAKPOINT }); function useBootstrapPrefix(_, j) { const { prefixes: $ } = reactExports.useContext(ThemeContext$1); return _ || $[j] || j } function useBootstrapBreakpoints() { const { breakpoints: _ } = reactExports.useContext(ThemeContext$1); return _ } function useBootstrapMinBreakpoint() { const { minBreakpoint: _ } = reactExports.useContext(ThemeContext$1); return _ } var propTypes = { exports: {} }, ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", ReactPropTypesSecret_1 = ReactPropTypesSecret$1, ReactPropTypesSecret = ReactPropTypesSecret_1; function emptyFunction() { } function emptyFunctionWithReset() { } emptyFunctionWithReset.resetWarningCache = emptyFunction; var factoryWithThrowingShims = function () { function _(_e, et, tt, rt, nt, it) { if (it !== ReactPropTypesSecret) { var st = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw st.name = "Invariant Violation", st } } _.isRequired = _; function j() { return _ } var $ = { array: _, bigint: _, bool: _, func: _, number: _, object: _, string: _, symbol: _, any: _, arrayOf: j, element: _, elementType: _, instanceOf: j, node: _, objectOf: j, oneOf: j, oneOfType: j, shape: j, exact: j, checkPropTypes: emptyFunctionWithReset, resetWarningCache: emptyFunction }; return $.PropTypes = $, $ }; propTypes.exports = factoryWithThrowingShims(); var propTypesExports = propTypes.exports; const PropTypes$1 = getDefaultExportFromCjs(propTypesExports), _excluded$1 = ["as", "disabled"]; function _objectWithoutPropertiesLoose$1(_, j) { if (_ == null) return {}; var $ = {}, _e = Object.keys(_), et, tt; for (tt = 0; tt < _e.length; tt++)et = _e[tt], !(j.indexOf(et) >= 0) && ($[et] = _[et]); return $ } function isTrivialHref(_) { return !_ || _.trim() === "#" } function useButtonProps({ tagName: _, disabled: j, href: $, target: _e, rel: et, role: tt, onClick: rt, tabIndex: nt = 0, type: it }) { _ || ($ != null || _e != null || et != null ? _ = "a" : _ = "button"); const st = { tagName: _ }; if (_ === "button") return [{ type: it || "button", disabled: j }, st]; const ot = at => { if ((j || _ === "a" && isTrivialHref($)) && at.preventDefault(), j) { at.stopPropagation(); return } rt == null || rt(at) }, ft = at => { at.key === " " && (at.preventDefault(), ot(at)) }; return _ === "a" && ($ || ($ = "#"), j && ($ = void 0)), [{ role: tt ?? "button", disabled: void 0, tabIndex: j ? void 0 : nt, href: $, target: _ === "a" ? _e : void 0, "aria-disabled": j || void 0, rel: _ === "a" ? et : void 0, onClick: ot, onKeyDown: ft }, st] } const Button$3 = reactExports.forwardRef((_, j) => { let { as: $, disabled: _e } = _, et = _objectWithoutPropertiesLoose$1(_, _excluded$1); const [tt, { tagName: rt }] = useButtonProps(Object.assign({ tagName: $, disabled: _e }, et)); return jsxRuntimeExports.jsx(rt, Object.assign({}, et, tt, { ref: j })) }); Button$3.displayName = "Button"; const Button$1 = reactExports.forwardRef(({ as: _, bsPrefix: j, variant: $ = "primary", size: _e, active: et = !1, disabled: tt = !1, className: rt, ...nt }, it) => { const st = useBootstrapPrefix(j, "btn"), [ot, { tagName: ft }] = useButtonProps({ tagName: _, disabled: tt, ...nt }), at = ft; return jsxRuntimeExports.jsx(at, { ...ot, ...nt, ref: it, disabled: tt, className: classNames(rt, st, et && "active", $ && `${st}-${$}`, _e && `${st}-${_e}`, nt.href && tt && "disabled") }) }); Button$1.displayName = "Button"; const Button$2 = Button$1; function useCol({ as: _, bsPrefix: j, className: $, ..._e }) { j = useBootstrapPrefix(j, "col"); const et = useBootstrapBreakpoints(), tt = useBootstrapMinBreakpoint(), rt = [], nt = []; return et.forEach(it => { const st = _e[it]; delete _e[it]; let ot, ft, at; typeof st == "object" && st != null ? { span: ot, offset: ft, order: at } = st : ot = st; const dt = it !== tt ? `-${it}` : ""; ot && rt.push(ot === !0 ? `${j}${dt}` : `${j}${dt}-${ot}`), at != null && nt.push(`order${dt}-${at}`), ft != null && nt.push(`offset${dt}-${ft}`) }), [{ ..._e, className: classNames($, ...rt, ...nt) }, { as: _, bsPrefix: j, spans: rt }] } const Col = reactExports.forwardRef((_, j) => { const [{ className: $, ..._e }, { as: et = "div", bsPrefix: tt, spans: rt }] = useCol(_); return jsxRuntimeExports.jsx(et, { ..._e, ref: j, className: classNames($, !rt.length && tt) }) }); Col.displayName = "Col"; const Col$1 = Col, Container = reactExports.forwardRef(({ bsPrefix: _, fluid: j = !1, as: $ = "div", className: _e, ...et }, tt) => { const rt = useBootstrapPrefix(_, "container"), nt = typeof j == "string" ? `-${j}` : "-fluid"; return jsxRuntimeExports.jsx($, { ref: tt, ...et, className: classNames(_e, j ? `${rt}${nt}` : rt) }) }); Container.displayName = "Container"; const Container$1 = Container; PropTypes$1.string, PropTypes$1.bool, PropTypes$1.bool, PropTypes$1.bool, PropTypes$1.bool; const Image$1 = reactExports.forwardRef(({ bsPrefix: _, className: j, fluid: $ = !1, rounded: _e = !1, roundedCircle: et = !1, thumbnail: tt = !1, ...rt }, nt) => (_ = useBootstrapPrefix(_, "img"), jsxRuntimeExports.jsx("img", { ref: nt, ...rt, className: classNames(j, $ && `${_}-fluid`, _e && "rounded", et && "rounded-circle", tt && `${_}-thumbnail`) }))); Image$1.displayName = "Image"; const Image$2 = Image$1, Row = reactExports.forwardRef(({ bsPrefix: _, className: j, as: $ = "div", ..._e }, et) => { const tt = useBootstrapPrefix(_, "row"), rt = useBootstrapBreakpoints(), nt = useBootstrapMinBreakpoint(), it = `${tt}-cols`, st = []; return rt.forEach(ot => { const ft = _e[ot]; delete _e[ot]; let at; ft != null && typeof ft == "object" ? { cols: at } = ft : at = ft; const dt = ot !== nt ? `-${ot}` : ""; at != null && st.push(`${it}${dt}-${at}`) }), jsxRuntimeExports.jsx($, { ref: et, ..._e, className: classNames(j, tt, ...st) }) }); Row.displayName = "Row"; const Row$1 = Row, profile = "./assets/Me-DOqH4t4-.jpeg"; function i$1(_, j, $, _e) { return new ($ || ($ = Promise))(function (et, tt) { function rt(st) { try { it(_e.next(st)) } catch (ot) { tt(ot) } } function nt(st) { try { it(_e.throw(st)) } catch (ot) { tt(ot) } } function it(st) { var ot; st.done ? et(st.value) : (ot = st.value, ot instanceof $ ? ot : new $(function (ft) { ft(ot) })).then(rt, nt) } it((_e = _e.apply(_, j || [])).next()) }) } const n$2 = (_, j, $, _e) => { _.style.transition = `${j} ${$}ms ${_e}` }, s$1 = (_, j, $) => Math.min(Math.max(_, j), $); let r$1 = class { constructor(j, $) { this.glareAngle = 0, this.glareOpacity = 0, this.calculateGlareSize = rt => { const { width: nt, height: it } = rt, st = Math.sqrt(Math.pow(nt, 2) + Math.pow(it, 2)); return { width: st, height: st } }, this.setSize = rt => { const nt = this.calculateGlareSize(rt); this.glareEl.style.width = `${nt.width}px`, this.glareEl.style.height = `${nt.height}px` }, this.update = (rt, nt, it, st) => { this.updateAngle(rt, nt.glareReverse), this.updateOpacity(rt, nt, it, st) }, this.updateAngle = (rt, nt) => { const { xPercentage: it, yPercentage: st } = rt, ot = 180 / Math.PI, ft = it ? Math.atan2(st, -it) * ot : 0; this.glareAngle = ft - (nt ? 180 : 0) }, this.updateOpacity = (rt, nt, it, st) => { const { xPercentage: ot, yPercentage: ft } = rt, { glarePosition: at, glareReverse: dt, glareMaxOpacity: pt } = nt, ht = it ? -1 : 1, xt = st ? -1 : 1, ct = dt ? -1 : 1; let ut = 0; switch (at) { case "top": ut = -ot * ht * ct; break; case "right": ut = ft * xt * ct; break; case "bottom": case void 0: ut = ot * ht * ct; break; case "left": ut = -ft * xt * ct; break; case "all": ut = Math.hypot(ot, ft) }const lt = s$1(ut, 0, 100); this.glareOpacity = lt * pt / 100 }, this.render = rt => { const { glareColor: nt } = rt; this.glareEl.style.transform = `rotate(${this.glareAngle}deg) translate(-50%, -50%)`, this.glareEl.style.opacity = this.glareOpacity.toString(), this.glareEl.style.background = `linear-gradient(0deg, rgba(255,255,255,0) 0%, ${nt} 100%)` }, this.glareWrapperEl = document.createElement("div"), this.glareEl = document.createElement("div"), this.glareWrapperEl.appendChild(this.glareEl), this.glareWrapperEl.className = "glare-wrapper", this.glareEl.className = "glare"; const _e = { position: "absolute", top: "0", left: "0", width: "100%", height: "100%", overflow: "hidden", borderRadius: $, WebkitMaskImage: "-webkit-radial-gradient(white, black)", pointerEvents: "none" }, et = this.calculateGlareSize(j), tt = { position: "absolute", top: "50%", left: "50%", transformOrigin: "0% 0%", pointerEvents: "none", width: `${et.width}px`, height: `${et.height}px` }; Object.assign(this.glareWrapperEl.style, _e), Object.assign(this.glareEl.style, tt) } }, l$3 = class { constructor() { this.glareAngle = 0, this.glareOpacity = 0, this.tiltAngleX = 0, this.tiltAngleY = 0, this.tiltAngleXPercentage = 0, this.tiltAngleYPercentage = 0, this.update = (j, $) => { this.updateTilt(j, $), this.updateTiltManualInput(j, $), this.updateTiltReverse($), this.updateTiltLimits($) }, this.updateTilt = (j, $) => { const { xPercentage: _e, yPercentage: et } = j, { tiltMaxAngleX: tt, tiltMaxAngleY: rt } = $; this.tiltAngleX = _e * tt / 100, this.tiltAngleY = et * rt / 100 * -1 }, this.updateTiltManualInput = (j, $) => { const { tiltAngleXManual: _e, tiltAngleYManual: et, tiltMaxAngleX: tt, tiltMaxAngleY: rt } = $; (_e !== null || et !== null) && (this.tiltAngleX = _e !== null ? _e : 0, this.tiltAngleY = et !== null ? et : 0, j.xPercentage = 100 * this.tiltAngleX / tt, j.yPercentage = 100 * this.tiltAngleY / rt) }, this.updateTiltReverse = j => { const $ = j.tiltReverse ? -1 : 1; this.tiltAngleX = $ * this.tiltAngleX, this.tiltAngleY = $ * this.tiltAngleY }, this.updateTiltLimits = j => { const { tiltAxis: $ } = j; this.tiltAngleX = s$1(this.tiltAngleX, -90, 90), this.tiltAngleY = s$1(this.tiltAngleY, -90, 90), $ && (this.tiltAngleX = $ === "x" ? this.tiltAngleX : 0, this.tiltAngleY = $ === "y" ? this.tiltAngleY : 0) }, this.updateTiltAnglesPercentage = j => { const { tiltMaxAngleX: $, tiltMaxAngleY: _e } = j; this.tiltAngleXPercentage = this.tiltAngleX / $ * 100, this.tiltAngleYPercentage = this.tiltAngleY / _e * 100 }, this.render = j => { j.style.transform += `rotateX(${this.tiltAngleX}deg) rotateY(${this.tiltAngleY}deg) ` } } }; const a = Object.assign(Object.assign({ scale: 1, perspective: 1e3, flipVertically: !1, flipHorizontally: !1, reset: !0, transitionEasing: "cubic-bezier(.03,.98,.52,.99)", transitionSpeed: 400, trackOnWindow: !1, gyroscope: !1 }, { tiltEnable: !0, tiltReverse: !1, tiltAngleXInitial: 0, tiltAngleYInitial: 0, tiltMaxAngleX: 20, tiltMaxAngleY: 20, tiltAxis: void 0, tiltAngleXManual: null, tiltAngleYManual: null }), { glareEnable: !1, glareMaxOpacity: .7, glareColor: "#ffffff", glarePosition: "bottom", glareReverse: !1, glareBorderRadius: "0" }); class o extends reactExports.PureComponent { constructor() { super(...arguments), this.wrapperEl = { node: null, size: { width: 0, height: 0, left: 0, top: 0 }, clientPosition: { x: null, y: null, xPercentage: 0, yPercentage: 0 }, updateAnimationId: null, scale: 1 }, this.tilt = null, this.glare = null, this.addDeviceOrientationEventListener = () => i$1(this, void 0, void 0, function* () { if (!window.DeviceOrientationEvent) return; const j = DeviceOrientationEvent.requestPermission; typeof j == "function" ? (yield j()) === "granted" && window.addEventListener("deviceorientation", this.onMove) : window.addEventListener("deviceorientation", this.onMove) }), this.setSize = () => { this.setWrapperElSize(), this.glare && this.glare.setSize(this.wrapperEl.size) }, this.mainLoop = j => { this.wrapperEl.updateAnimationId !== null && cancelAnimationFrame(this.wrapperEl.updateAnimationId), this.processInput(j), this.update(j.type), this.wrapperEl.updateAnimationId = requestAnimationFrame(this.renderFrame) }, this.onEnter = j => { const { onEnter: $ } = this.props; this.setSize(), this.wrapperEl.node.style.willChange = "transform", this.setTransitions(), $ && $(j.type) }, this.onMove = j => { this.mainLoop(j), this.emitOnMove(j) }, this.onLeave = j => { const { onLeave: $ } = this.props; if (this.setTransitions(), $ && $(j.type), this.props.reset) { const _e = new CustomEvent("autoreset"); this.onMove(_e) } }, this.processInput = j => { const { scale: $ } = this.props; switch (j.type) { case "mousemove": this.wrapperEl.clientPosition.x = j.pageX, this.wrapperEl.clientPosition.y = j.pageY, this.wrapperEl.scale = $; break; case "touchmove": this.wrapperEl.clientPosition.x = j.touches[0].pageX, this.wrapperEl.clientPosition.y = j.touches[0].pageY, this.wrapperEl.scale = $; break; case "deviceorientation": this.processInputDeviceOrientation(j), this.wrapperEl.scale = $; break; case "autoreset": const { tiltAngleXInitial: _e, tiltAngleYInitial: et, tiltMaxAngleX: tt, tiltMaxAngleY: rt } = this.props, nt = et / rt * 100; this.wrapperEl.clientPosition.xPercentage = s$1(_e / tt * 100, -100, 100), this.wrapperEl.clientPosition.yPercentage = s$1(nt, -100, 100), this.wrapperEl.scale = 1 } }, this.processInputDeviceOrientation = j => { if (!j.gamma || !j.beta || !this.props.gyroscope) return; const { tiltMaxAngleX: $, tiltMaxAngleY: _e } = this.props, et = j.gamma; this.wrapperEl.clientPosition.xPercentage = j.beta / $ * 100, this.wrapperEl.clientPosition.yPercentage = et / _e * 100, this.wrapperEl.clientPosition.xPercentage = s$1(this.wrapperEl.clientPosition.xPercentage, -100, 100), this.wrapperEl.clientPosition.yPercentage = s$1(this.wrapperEl.clientPosition.yPercentage, -100, 100) }, this.update = j => { const { tiltEnable: $, flipVertically: _e, flipHorizontally: et } = this.props; j !== "autoreset" && j !== "deviceorientation" && j !== "propChange" && this.updateClientInput(), $ && this.tilt.update(this.wrapperEl.clientPosition, this.props), this.updateFlip(), this.tilt.updateTiltAnglesPercentage(this.props), this.glare && this.glare.update(this.wrapperEl.clientPosition, this.props, _e, et) }, this.updateClientInput = () => { const { trackOnWindow: j } = this.props; let $, _e; if (j) { const { x: et, y: tt } = this.wrapperEl.clientPosition; $ = tt / window.innerHeight * 200 - 100, _e = et / window.innerWidth * 200 - 100 } else { const { size: { width: et, height: tt, left: rt, top: nt }, clientPosition: { x: it, y: st } } = this.wrapperEl; $ = (st - nt) / tt * 200 - 100, _e = (it - rt) / et * 200 - 100 } this.wrapperEl.clientPosition.xPercentage = s$1($, -100, 100), this.wrapperEl.clientPosition.yPercentage = s$1(_e, -100, 100) }, this.updateFlip = () => { const { flipVertically: j, flipHorizontally: $ } = this.props; j && (this.tilt.tiltAngleX += 180, this.tilt.tiltAngleY *= -1), $ && (this.tilt.tiltAngleY += 180) }, this.renderFrame = () => { this.resetWrapperElTransform(), this.renderPerspective(), this.tilt.render(this.wrapperEl.node), this.renderScale(), this.glare && this.glare.render(this.props) } } componentDidMount() { if (this.tilt = new l$3, this.initGlare(), this.addEventListeners(), typeof CustomEvent > "u") return; const j = new CustomEvent("autoreset"); this.mainLoop(j); const $ = new CustomEvent("initial"); this.emitOnMove($) } componentWillUnmount() { this.wrapperEl.updateAnimationId !== null && cancelAnimationFrame(this.wrapperEl.updateAnimationId), this.removeEventListeners() } componentDidUpdate() { const j = new CustomEvent("propChange"); this.mainLoop(j), this.emitOnMove(j) } addEventListeners() { const { trackOnWindow: j, gyroscope: $ } = this.props; window.addEventListener("resize", this.setSize), j && (window.addEventListener("mouseenter", this.onEnter), window.addEventListener("mousemove", this.onMove), window.addEventListener("mouseout", this.onLeave), window.addEventListener("touchstart", this.onEnter), window.addEventListener("touchmove", this.onMove), window.addEventListener("touchend", this.onLeave)), $ && this.addDeviceOrientationEventListener() } removeEventListeners() { const { trackOnWindow: j, gyroscope: $ } = this.props; window.removeEventListener("resize", this.setSize), j && (window.removeEventListener("mouseenter", this.onEnter), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseout", this.onLeave), window.removeEventListener("touchstart", this.onEnter), window.removeEventListener("touchmove", this.onMove), window.removeEventListener("touchend", this.onLeave)), $ && window.DeviceOrientationEvent && window.removeEventListener("deviceorientation", this.onMove) } setWrapperElSize() { const j = this.wrapperEl.node.getBoundingClientRect(); this.wrapperEl.size.width = this.wrapperEl.node.offsetWidth, this.wrapperEl.size.height = this.wrapperEl.node.offsetHeight, this.wrapperEl.size.left = j.left + window.scrollX, this.wrapperEl.size.top = j.top + window.scrollY } initGlare() { const { glareEnable: j, glareBorderRadius: $ } = this.props; j && (this.glare = new r$1(this.wrapperEl.size, $), this.wrapperEl.node.appendChild(this.glare.glareWrapperEl)) } emitOnMove(j) { const { onMove: $ } = this.props; if (!$) return; let _e = 0, et = 0; this.glare && (_e = this.glare.glareAngle, et = this.glare.glareOpacity), $({ tiltAngleX: this.tilt.tiltAngleX, tiltAngleY: this.tilt.tiltAngleY, tiltAngleXPercentage: this.tilt.tiltAngleXPercentage, tiltAngleYPercentage: this.tilt.tiltAngleYPercentage, glareAngle: _e, glareOpacity: et, eventType: j.type }) } resetWrapperElTransform() { this.wrapperEl.node.style.transform = "" } renderPerspective() { const { perspective: j } = this.props; this.wrapperEl.node.style.transform += `perspective(${j}px) ` } renderScale() { const { scale: j } = this.wrapperEl; this.wrapperEl.node.style.transform += `scale3d(${j},${j},${j})` } setTransitions() { const { transitionSpeed: j, transitionEasing: $ } = this.props; n$2(this.wrapperEl.node, "all", j, $), this.glare && n$2(this.glare.glareEl, "opacity", j, $) } render() { const { children: j, className: $, style: _e } = this.props; return React$1.createElement("div", { ref: et => this.wrapperEl.node = et, onMouseEnter: this.onEnter, onMouseMove: this.onMove, onMouseLeave: this.onLeave, onTouchStart: this.onEnter, onTouchMove: this.onMove, onTouchEnd: this.onLeave, className: $, style: _e }, j) } } o.defaultProps = a; function sheetForTag(_) { if (_.sheet) return _.sheet; for (var j = 0; j < document.styleSheets.length; j++)if (document.styleSheets[j].ownerNode === _) return document.styleSheets[j] } function createStyleElement(_) { var j = document.createElement("style"); return j.setAttribute("data-emotion", _.key), _.nonce !== void 0 && j.setAttribute("nonce", _.nonce), j.appendChild(document.createTextNode("")), j.setAttribute("data-s", ""), j } var StyleSheet = function () { function _($) { var _e = this; this._insertTag = function (et) { var tt; _e.tags.length === 0 ? _e.insertionPoint ? tt = _e.insertionPoint.nextSibling : _e.prepend ? tt = _e.container.firstChild : tt = _e.before : tt = _e.tags[_e.tags.length - 1].nextSibling, _e.container.insertBefore(et, tt), _e.tags.push(et) }, this.isSpeedy = $.speedy === void 0 ? !0 : $.speedy, this.tags = [], this.ctr = 0, this.nonce = $.nonce, this.key = $.key, this.container = $.container, this.prepend = $.prepend, this.insertionPoint = $.insertionPoint, this.before = null } var j = _.prototype; return j.hydrate = function (_e) { _e.forEach(this._insertTag) }, j.insert = function (_e) { this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this)); var et = this.tags[this.tags.length - 1]; if (this.isSpeedy) { var tt = sheetForTag(et); try { tt.insertRule(_e, tt.cssRules.length) } catch { } } else et.appendChild(document.createTextNode(_e)); this.ctr++ }, j.flush = function () { this.tags.forEach(function (_e) { return _e.parentNode && _e.parentNode.removeChild(_e) }), this.tags = [], this.ctr = 0 }, _ }(), MS = "-ms-", MOZ = "-moz-", WEBKIT = "-webkit-", COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from = String.fromCharCode, assign = Object.assign; function hash(_, j) { return charat(_, 0) ^ 45 ? (((j << 2 ^ charat(_, 0)) << 2 ^ charat(_, 1)) << 2 ^ charat(_, 2)) << 2 ^ charat(_, 3) : 0 } function trim(_) { return _.trim() } function match(_, j) { return (_ = j.exec(_)) ? _[0] : _ } function replace(_, j, $) { return _.replace(j, $) } function indexof(_, j) { return _.indexOf(j) } function charat(_, j) { return _.charCodeAt(j) | 0 } function substr(_, j, $) { return _.slice(j, $) } function strlen(_) { return _.length } function sizeof(_) { return _.length } function append(_, j) { return j.push(_), _ } function combine(_, j) { return _.map(j).join("") } var line = 1, column = 1, length = 0, position = 0, character = 0, characters = ""; function node(_, j, $, _e, et, tt, rt) { return { value: _, root: j, parent: $, type: _e, props: et, children: tt, line, column, length: rt, return: "" } } function copy(_, j) { return assign(node("", null, null, "", null, null, 0), _, { length: -_.length }, j) } function char() { return character } function prev() { return character = position > 0 ? charat(characters, --position) : 0, column--, character === 10 && (column = 1, line--), character } function next() { return character = position < length ? charat(characters, position++) : 0, column++, character === 10 && (column = 1, line++), character } function peek() { return charat(characters, position) } function caret() { return position } function slice(_, j) { return substr(characters, _, j) } function token(_) { switch (_) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1 }return 0 } function alloc(_) { return line = column = 1, length = strlen(characters = _), position = 0, [] } function dealloc(_) { return characters = "", _ } function delimit(_) { return trim(slice(position - 1, delimiter(_ === 91 ? _ + 2 : _ === 40 ? _ + 1 : _))) } function whitespace(_) { for (; (character = peek()) && character < 33;)next(); return token(_) > 2 || token(character) > 3 ? "" : " " } function escaping(_, j) { for (; --j && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97);); return slice(_, caret() + (j < 6 && peek() == 32 && next() == 32)) } function delimiter(_) { for (; next();)switch (character) { case _: return position; case 34: case 39: _ !== 34 && _ !== 39 && delimiter(character); break; case 40: _ === 41 && delimiter(_); break; case 92: next(); break }return position } function commenter(_, j) { for (; next() && _ + character !== 57;)if (_ + character === 84 && peek() === 47) break; return "/*" + slice(j, position - 1) + "*" + from(_ === 47 ? _ : next()) } function identifier(_) { for (; !token(peek());)next(); return slice(_, position) } function compile(_) { return dealloc(parse("", null, null, null, [""], _ = alloc(_), 0, [0], _)) } function parse(_, j, $, _e, et, tt, rt, nt, it) { for (var st = 0, ot = 0, ft = rt, at = 0, dt = 0, pt = 0, ht = 1, xt = 1, ct = 1, ut = 0, lt = "", mt = et, yt = tt, gt = _e, St = lt; xt;)switch (pt = ut, ut = next()) { case 40: if (pt != 108 && charat(St, ft - 1) == 58) { indexof(St += replace(delimit(ut), "&", "&\f"), "&\f") != -1 && (ct = -1); break } case 34: case 39: case 91: St += delimit(ut); break; case 9: case 10: case 13: case 32: St += whitespace(pt); break; case 92: St += escaping(caret() - 1, 7); continue; case 47: switch (peek()) { case 42: case 47: append(comment(commenter(next(), caret()), j, $), it); break; default: St += "/" }break; case 123 * ht: nt[st++] = strlen(St) * ct; case 125 * ht: case 59: case 0: switch (ut) { case 0: case 125: xt = 0; case 59 + ot: ct == -1 && (St = replace(St, /\f/g, "")), dt > 0 && strlen(St) - ft && append(dt > 32 ? declaration(St + ";", _e, $, ft - 1) : declaration(replace(St, " ", "") + ";", _e, $, ft - 2), it); break; case 59: St += ";"; default: if (append(gt = ruleset(St, j, $, st, ot, et, nt, lt, mt = [], yt = [], ft), tt), ut === 123) if (ot === 0) parse(St, j, gt, gt, mt, tt, ft, nt, yt); else switch (at === 99 && charat(St, 3) === 110 ? 100 : at) { case 100: case 108: case 109: case 115: parse(_, gt, gt, _e && append(ruleset(_, gt, gt, 0, 0, et, nt, lt, et, mt = [], ft), yt), et, yt, ft, nt, _e ? mt : yt); break; default: parse(St, gt, gt, gt, [""], yt, 0, nt, yt) } }st = ot = dt = 0, ht = ct = 1, lt = St = "", ft = rt; break; case 58: ft = 1 + strlen(St), dt = pt; default: if (ht < 1) { if (ut == 123) --ht; else if (ut == 125 && ht++ == 0 && prev() == 125) continue } switch (St += from(ut), ut * ht) { case 38: ct = ot > 0 ? 1 : (St += "\f", -1); break; case 44: nt[st++] = (strlen(St) - 1) * ct, ct = 1; break; case 64: peek() === 45 && (St += delimit(next())), at = peek(), ot = ft = strlen(lt = St += identifier(caret())), ut++; break; case 45: pt === 45 && strlen(St) == 2 && (ht = 0) } }return tt } function ruleset(_, j, $, _e, et, tt, rt, nt, it, st, ot) { for (var ft = et - 1, at = et === 0 ? tt : [""], dt = sizeof(at), pt = 0, ht = 0, xt = 0; pt < _e; ++pt)for (var ct = 0, ut = substr(_, ft + 1, ft = abs(ht = rt[pt])), lt = _; ct < dt; ++ct)(lt = trim(ht > 0 ? at[ct] + " " + ut : replace(ut, /&\f/g, at[ct]))) && (it[xt++] = lt); return node(_, j, $, et === 0 ? RULESET : nt, it, st, ot) } function comment(_, j, $) { return node(_, j, $, COMMENT, from(char()), substr(_, 2, -2), 0) } function declaration(_, j, $, _e) { return node(_, j, $, DECLARATION, substr(_, 0, _e), substr(_, _e + 1, -1), _e) } function serialize(_, j) { for (var $ = "", _e = sizeof(_), et = 0; et < _e; et++)$ += j(_[et], et, _, j) || ""; return $ } function stringify(_, j, $, _e) { switch (_.type) { case LAYER: if (_.children.length) break; case IMPORT: case DECLARATION: return _.return = _.return || _.value; case COMMENT: return ""; case KEYFRAMES: return _.return = _.value + "{" + serialize(_.children, _e) + "}"; case RULESET: _.value = _.props.join(",") }return strlen($ = serialize(_.children, _e)) ? _.return = _.value + "{" + $ + "}" : "" } function middleware(_) { var j = sizeof(_); return function ($, _e, et, tt) { for (var rt = "", nt = 0; nt < j; nt++)rt += _[nt]($, _e, et, tt) || ""; return rt } } function rulesheet(_) { return function (j) { j.root || (j = j.return) && _(j) } } function memoize(_) { var j = Object.create(null); return function ($) { return j[$] === void 0 && (j[$] = _($)), j[$] } } var identifierWithPointTracking = function _(j, $, _e) { for (var et = 0, tt = 0; et = tt, tt = peek(), et === 38 && tt === 12 && ($[_e] = 1), !token(tt);)next(); return slice(j, position) }, toRules = function _(j, $) { var _e = -1, et = 44; do switch (token(et)) { case 0: et === 38 && peek() === 12 && ($[_e] = 1), j[_e] += identifierWithPointTracking(position - 1, $, _e); break; case 2: j[_e] += delimit(et); break; case 4: if (et === 44) { j[++_e] = peek() === 58 ? "&\f" : "", $[_e] = j[_e].length; break } default: j[_e] += from(et) } while (et = next()); return j }, getRules = function _(j, $) { return dealloc(toRules(alloc(j), $)) }, fixedElements = new WeakMap, compat = function _(j) { if (!(j.type !== "rule" || !j.parent || j.length < 1)) { for (var $ = j.value, _e = j.parent, et = j.column === _e.column && j.line === _e.line; _e.type !== "rule";)if (_e = _e.parent, !_e) return; if (!(j.props.length === 1 && $.charCodeAt(0) !== 58 && !fixedElements.get(_e)) && !et) { fixedElements.set(j, !0); for (var tt = [], rt = getRules($, tt), nt = _e.props, it = 0, st = 0; it < rt.length; it++)for (var ot = 0; ot < nt.length; ot++, st++)j.props[st] = tt[it] ? rt[it].replace(/&\f/g, nt[ot]) : nt[ot] + " " + rt[it] } } }, removeLabel = function _(j) { if (j.type === "decl") { var $ = j.value; $.charCodeAt(0) === 108 && $.charCodeAt(2) === 98 && (j.return = "", j.value = "") } }; function prefix(_, j) { switch (hash(_, j)) { case 5103: return WEBKIT + "print-" + _ + _; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return WEBKIT + _ + _; case 5349: case 4246: case 4810: case 6968: case 2756: return WEBKIT + _ + MOZ + _ + MS + _ + _; case 6828: case 4268: return WEBKIT + _ + MS + _ + _; case 6165: return WEBKIT + _ + MS + "flex-" + _ + _; case 5187: return WEBKIT + _ + replace(_, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + _; case 5443: return WEBKIT + _ + MS + "flex-item-" + replace(_, /flex-|-self/, "") + _; case 4675: return WEBKIT + _ + MS + "flex-line-pack" + replace(_, /align-content|flex-|-self/, "") + _; case 5548: return WEBKIT + _ + MS + replace(_, "shrink", "negative") + _; case 5292: return WEBKIT + _ + MS + replace(_, "basis", "preferred-size") + _; case 6060: return WEBKIT + "box-" + replace(_, "-grow", "") + WEBKIT + _ + MS + replace(_, "grow", "positive") + _; case 4554: return WEBKIT + replace(_, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + _; case 6187: return replace(replace(replace(_, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), _, "") + _; case 5495: case 3959: return replace(_, /(image-set\([^]*)/, WEBKIT + "$1$`$1"); case 4968: return replace(replace(_, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + _ + _; case 4095: case 3583: case 4068: case 2532: return replace(_, /(.+)-inline(.+)/, WEBKIT + "$1$2") + _; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (strlen(_) - 1 - j > 6) switch (charat(_, j + 1)) { case 109: if (charat(_, j + 4) !== 45) break; case 102: return replace(_, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(_, j + 3) == 108 ? "$3" : "$2-$3")) + _; case 115: return ~indexof(_, "stretch") ? prefix(replace(_, "stretch", "fill-available"), j) + _ : _ }break; case 4949: if (charat(_, j + 1) !== 115) break; case 6444: switch (charat(_, strlen(_) - 3 - (~indexof(_, "!important") && 10))) { case 107: return replace(_, ":", ":" + WEBKIT) + _; case 101: return replace(_, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(_, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + _ }break; case 5936: switch (charat(_, j + 11)) { case 114: return WEBKIT + _ + MS + replace(_, /[svh]\w+-[tblr]{2}/, "tb") + _; case 108: return WEBKIT + _ + MS + replace(_, /[svh]\w+-[tblr]{2}/, "tb-rl") + _; case 45: return WEBKIT + _ + MS + replace(_, /[svh]\w+-[tblr]{2}/, "lr") + _ }return WEBKIT + _ + MS + _ + _ }return _ } var prefixer = function _(j, $, _e, et) { if (j.length > -1 && !j.return) switch (j.type) { case DECLARATION: j.return = prefix(j.value, j.length); break; case KEYFRAMES: return serialize([copy(j, { value: replace(j.value, "@", "@" + WEBKIT) })], et); case RULESET: if (j.length) return combine(j.props, function (tt) { switch (match(tt, /(::plac\w+|:read-\w+)/)) { case ":read-only": case ":read-write": return serialize([copy(j, { props: [replace(tt, /:(read-\w+)/, ":" + MOZ + "$1")] })], et); case "::placeholder": return serialize([copy(j, { props: [replace(tt, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }), copy(j, { props: [replace(tt, /:(plac\w+)/, ":" + MOZ + "$1")] }), copy(j, { props: [replace(tt, /:(plac\w+)/, MS + "input-$1")] })], et) }return "" }) } }, defaultStylisPlugins = [prefixer], createCache = function _(j) { var $ = j.key; if ($ === "css") { var _e = document.querySelectorAll("style[data-emotion]:not([data-s])"); Array.prototype.forEach.call(_e, function (ht) { var xt = ht.getAttribute("data-emotion"); xt.indexOf(" ") !== -1 && (document.head.appendChild(ht), ht.setAttribute("data-s", "")) }) } var et = j.stylisPlugins || defaultStylisPlugins, tt = {}, rt, nt = []; rt = j.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + $ + ' "]'), function (ht) { for (var xt = ht.getAttribute("data-emotion").split(" "), ct = 1; ct < xt.length; ct++)tt[xt[ct]] = !0; nt.push(ht) }); var it, st = [compat, removeLabel]; { var ot, ft = [stringify, rulesheet(function (ht) { ot.insert(ht) })], at = middleware(st.concat(et, ft)), dt = function (xt) { return serialize(compile(xt), at) }; it = function (xt, ct, ut, lt) { ot = ut, dt(xt ? xt + "{" + ct.styles + "}" : ct.styles), lt && (pt.inserted[ct.name] = !0) } } var pt = { key: $, sheet: new StyleSheet({ key: $, container: rt, nonce: j.nonce, speedy: j.speedy, prepend: j.prepend, insertionPoint: j.insertionPoint }), nonce: j.nonce, inserted: tt, registered: {}, insert: it }; return pt.sheet.hydrate(nt), pt }, reactIs$2 = { exports: {} }, reactIs_production_min$1 = {};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b$2 = typeof Symbol == "function" && Symbol.for, c$2 = b$2 ? Symbol.for("react.element") : 60103, d$2 = b$2 ? Symbol.for("react.portal") : 60106, e$1 = b$2 ? Symbol.for("react.fragment") : 60107, f$2 = b$2 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$2 ? Symbol.for("react.profiler") : 60114, h$3 = b$2 ? Symbol.for("react.provider") : 60109, k$1 = b$2 ? Symbol.for("react.context") : 60110, l$2 = b$2 ? Symbol.for("react.async_mode") : 60111, m$2 = b$2 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$2 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$2 ? Symbol.for("react.suspense") : 60113, q$1 = b$2 ? Symbol.for("react.suspense_list") : 60120, r = b$2 ? Symbol.for("react.memo") : 60115, t$1 = b$2 ? Symbol.for("react.lazy") : 60116, v$3 = b$2 ? Symbol.for("react.block") : 60121, w$1 = b$2 ? Symbol.for("react.fundamental") : 60117, x = b$2 ? Symbol.for("react.responder") : 60118, y$1 = b$2 ? Symbol.for("react.scope") : 60119; function z(_) { if (typeof _ == "object" && _ !== null) { var j = _.$$typeof; switch (j) { case c$2: switch (_ = _.type, _) { case l$2: case m$2: case e$1: case g$1: case f$2: case p$2: return _; default: switch (_ = _ && _.$$typeof, _) { case k$1: case n$1: case t$1: case r: case h$3: return _; default: return j } }case d$2: return j } } } function A(_) { return z(_) === m$2 } reactIs_production_min$1.AsyncMode = l$2; reactIs_production_min$1.ConcurrentMode = m$2; reactIs_production_min$1.ContextConsumer = k$1; reactIs_production_min$1.ContextProvider = h$3; reactIs_production_min$1.Element = c$2; reactIs_production_min$1.ForwardRef = n$1; reactIs_production_min$1.Fragment = e$1; reactIs_production_min$1.Lazy = t$1; reactIs_production_min$1.Memo = r; reactIs_production_min$1.Portal = d$2; reactIs_production_min$1.Profiler = g$1; reactIs_production_min$1.StrictMode = f$2; reactIs_production_min$1.Suspense = p$2; reactIs_production_min$1.isAsyncMode = function (_) { return A(_) || z(_) === l$2 }; reactIs_production_min$1.isConcurrentMode = A; reactIs_production_min$1.isContextConsumer = function (_) { return z(_) === k$1 }; reactIs_production_min$1.isContextProvider = function (_) { return z(_) === h$3 }; reactIs_production_min$1.isElement = function (_) { return typeof _ == "object" && _ !== null && _.$$typeof === c$2 }; reactIs_production_min$1.isForwardRef = function (_) { return z(_) === n$1 }; reactIs_production_min$1.isFragment = function (_) { return z(_) === e$1 }; reactIs_production_min$1.isLazy = function (_) { return z(_) === t$1 }; reactIs_production_min$1.isMemo = function (_) { return z(_) === r }; reactIs_production_min$1.isPortal = function (_) { return z(_) === d$2 }; reactIs_production_min$1.isProfiler = function (_) { return z(_) === g$1 }; reactIs_production_min$1.isStrictMode = function (_) { return z(_) === f$2 }; reactIs_production_min$1.isSuspense = function (_) { return z(_) === p$2 }; reactIs_production_min$1.isValidElementType = function (_) { return typeof _ == "string" || typeof _ == "function" || _ === e$1 || _ === m$2 || _ === g$1 || _ === f$2 || _ === p$2 || _ === q$1 || typeof _ == "object" && _ !== null && (_.$$typeof === t$1 || _.$$typeof === r || _.$$typeof === h$3 || _.$$typeof === k$1 || _.$$typeof === n$1 || _.$$typeof === w$1 || _.$$typeof === x || _.$$typeof === y$1 || _.$$typeof === v$3) }; reactIs_production_min$1.typeOf = z; reactIs$2.exports = reactIs_production_min$1; var reactIsExports$1 = reactIs$2.exports, reactIs$1 = reactIsExports$1, FORWARD_REF_STATICS = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, MEMO_STATICS = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, TYPE_STATICS = {}; TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS; TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS; var isBrowser = !0; function getRegisteredStyles(_, j, $) { var _e = ""; return $.split(" ").forEach(function (et) { _[et] !== void 0 ? j.push(_[et] + ";") : _e += et + " " }), _e } var registerStyles = function _(j, $, _e) { var et = j.key + "-" + $.name; (_e === !1 || isBrowser === !1) && j.registered[et] === void 0 && (j.registered[et] = $.styles) }, insertStyles = function _(j, $, _e) { registerStyles(j, $, _e); var et = j.key + "-" + $.name; if (j.inserted[$.name] === void 0) { var tt = $; do j.insert($ === tt ? "." + et : "", tt, j.sheet, !0), tt = tt.next; while (tt !== void 0) } }; function murmur2(_) { for (var j = 0, $, _e = 0, et = _.length; et >= 4; ++_e, et -= 4)$ = _.charCodeAt(_e) & 255 | (_.charCodeAt(++_e) & 255) << 8 | (_.charCodeAt(++_e) & 255) << 16 | (_.charCodeAt(++_e) & 255) << 24, $ = ($ & 65535) * 1540483477 + (($ >>> 16) * 59797 << 16), $ ^= $ >>> 24, j = ($ & 65535) * 1540483477 + (($ >>> 16) * 59797 << 16) ^ (j & 65535) * 1540483477 + ((j >>> 16) * 59797 << 16); switch (et) { case 3: j ^= (_.charCodeAt(_e + 2) & 255) << 16; case 2: j ^= (_.charCodeAt(_e + 1) & 255) << 8; case 1: j ^= _.charCodeAt(_e) & 255, j = (j & 65535) * 1540483477 + ((j >>> 16) * 59797 << 16) }return j ^= j >>> 13, j = (j & 65535) * 1540483477 + ((j >>> 16) * 59797 << 16), ((j ^ j >>> 15) >>> 0).toString(36) } var unitlessKeys = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, hyphenateRegex = /[A-Z]|^ms/g, animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g, isCustomProperty = function _(j) { return j.charCodeAt(1) === 45 }, isProcessableValue = function _(j) { return j != null && typeof j != "boolean" }, processStyleName = memoize(function (_) { return isCustomProperty(_) ? _ : _.replace(hyphenateRegex, "-$&").toLowerCase() }), processStyleValue = function _(j, $) { switch (j) { case "animation": case "animationName": if (typeof $ == "string") return $.replace(animationRegex, function (_e, et, tt) { return cursor = { name: et, styles: tt, next: cursor }, et }) }return unitlessKeys[j] !== 1 && !isCustomProperty(j) && typeof $ == "number" && $ !== 0 ? $ + "px" : $ }, noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform."; function handleInterpolation(_, j, $) { if ($ == null) return ""; if ($.__emotion_styles !== void 0) return $; switch (typeof $) { case "boolean": return ""; case "object": { if ($.anim === 1) return cursor = { name: $.name, styles: $.styles, next: cursor }, $.name; if ($.styles !== void 0) { var _e = $.next; if (_e !== void 0) for (; _e !== void 0;)cursor = { name: _e.name, styles: _e.styles, next: cursor }, _e = _e.next; var et = $.styles + ";"; return et } return createStringFromObject(_, j, $) } case "function": { if (_ !== void 0) { var tt = cursor, rt = $(_); return cursor = tt, handleInterpolation(_, j, rt) } break } }if (j == null) return $; var nt = j[$]; return nt !== void 0 ? nt : $ } function createStringFromObject(_, j, $) { var _e = ""; if (Array.isArray($)) for (var et = 0; et < $.length; et++)_e += handleInterpolation(_, j, $[et]) + ";"; else for (var tt in $) { var rt = $[tt]; if (typeof rt != "object") j != null && j[rt] !== void 0 ? _e += tt + "{" + j[rt] + "}" : isProcessableValue(rt) && (_e += processStyleName(tt) + ":" + processStyleValue(tt, rt) + ";"); else if (Array.isArray(rt) && typeof rt[0] == "string" && (j == null || j[rt[0]] === void 0)) for (var nt = 0; nt < rt.length; nt++)isProcessableValue(rt[nt]) && (_e += processStyleName(tt) + ":" + processStyleValue(tt, rt[nt]) + ";"); else { var it = handleInterpolation(_, j, rt); switch (tt) { case "animation": case "animationName": { _e += processStyleName(tt) + ":" + it + ";"; break } default: _e += tt + "{" + it + "}" } } } return _e } var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cursor, serializeStyles = function _(j, $, _e) { if (j.length === 1 && typeof j[0] == "object" && j[0] !== null && j[0].styles !== void 0) return j[0]; var et = !0, tt = ""; cursor = void 0; var rt = j[0]; rt == null || rt.raw === void 0 ? (et = !1, tt += handleInterpolation(_e, $, rt)) : tt += rt[0]; for (var nt = 1; nt < j.length; nt++)tt += handleInterpolation(_e, $, j[nt]), et && (tt += rt[nt]); labelPattern.lastIndex = 0; for (var it = "", st; (st = labelPattern.exec(tt)) !== null;)it += "-" + st[1]; var ot = murmur2(tt) + it; return { name: ot, styles: tt, next: cursor } }, syncFallback = function _(j) { return j() }, useInsertionEffect = React$2.useInsertionEffect ? React$2.useInsertionEffect : !1, useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback, hasOwn = {}.hasOwnProperty, EmotionCacheContext = reactExports.createContext(typeof HTMLElement < "u" ? createCache({ key: "css" }) : null); EmotionCacheContext.Provider; var withEmotionCache = function _(j) { return reactExports.forwardRef(function ($, _e) { var et = reactExports.useContext(EmotionCacheContext); return j($, et, _e) }) }, ThemeContext = reactExports.createContext({}), typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", createEmotionProps = function _(j, $) { var _e = {}; for (var et in $) hasOwn.call($, et) && (_e[et] = $[et]); return _e[typePropName] = j, _e }, Insertion$1 = function _(j) { var $ = j.cache, _e = j.serialized, et = j.isStringTag; return registerStyles($, _e, et), useInsertionEffectAlwaysWithSyncFallback(function () { return insertStyles($, _e, et) }), null }, Emotion = withEmotionCache(function (_, j, $) { var _e = _.css; typeof _e == "string" && j.registered[_e] !== void 0 && (_e = j.registered[_e]); var et = _[typePropName], tt = [_e], rt = ""; typeof _.className == "string" ? rt = getRegisteredStyles(j.registered, tt, _.className) : _.className != null && (rt = _.className + " "); var nt = serializeStyles(tt, void 0, reactExports.useContext(ThemeContext)); rt += j.key + "-" + nt.name; var it = {}; for (var st in _) hasOwn.call(_, st) && st !== "css" && st !== typePropName && (it[st] = _[st]); return it.ref = $, it.className = rt, reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion$1, { cache: j, serialized: nt, isStringTag: typeof et == "string" }), reactExports.createElement(et, it)) }), Emotion$1 = Emotion, Fragment = jsxRuntimeExports.Fragment; function jsx(_, j, $) { return hasOwn.call(j, "css") ? jsxRuntimeExports.jsx(Emotion$1, createEmotionProps(_, j), $) : jsxRuntimeExports.jsx(_, j, $) } function css() { for (var _ = arguments.length, j = new Array(_), $ = 0; $ < _; $++)j[$] = arguments[$]; return serializeStyles(j) } var keyframes = function _() { var j = css.apply(void 0, arguments), $ = "animation-" + j.name; return { name: $, styles: "@keyframes " + $ + "{" + j.styles + "}", anim: 1, toString: function () { return "_EMO_" + this.name + "_" + this.styles + "_EMO_" } } }, classnames = function _(j) { for (var $ = j.length, _e = 0, et = ""; _e < $; _e++) { var tt = j[_e]; if (tt != null) { var rt = void 0; switch (typeof tt) { case "boolean": break; case "object": { if (Array.isArray(tt)) rt = _(tt); else { rt = ""; for (var nt in tt) tt[nt] && nt && (rt && (rt += " "), rt += nt) } break } default: rt = tt }rt && (et && (et += " "), et += rt) } } return et }; function merge(_, j, $) { var _e = [], et = getRegisteredStyles(_, _e, $); return _e.length < 2 ? $ : et + j(_e) } var Insertion = function _(j) { var $ = j.cache, _e = j.serializedArr; return useInsertionEffectAlwaysWithSyncFallback(function () { for (var et = 0; et < _e.length; et++)insertStyles($, _e[et], !1) }), null }, ClassNames = withEmotionCache(function (_, j) { var $ = !1, _e = [], et = function () { for (var st = arguments.length, ot = new Array(st), ft = 0; ft < st; ft++)ot[ft] = arguments[ft]; var at = serializeStyles(ot, j.registered); return _e.push(at), registerStyles(j, at, !1), j.key + "-" + at.name }, tt = function () { for (var st = arguments.length, ot = new Array(st), ft = 0; ft < st; ft++)ot[ft] = arguments[ft]; return merge(j.registered, et, classnames(ot)) }, rt = { css: et, cx: tt, theme: reactExports.useContext(ThemeContext) }, nt = _.children(rt); return $ = !0, reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion, { cache: j, serializedArr: _e }), nt) }), __defProp = Object.defineProperty, __defNormalProp = (_, j, $) => j in _ ? __defProp(_, j, { enumerable: !0, configurable: !0, writable: !0, value: $ }) : _[j] = $, __publicField = (_, j, $) => (__defNormalProp(_, typeof j != "symbol" ? j + "" : j, $), $), observerMap = new Map, RootIds = new WeakMap, rootId = 0, unsupportedValue = void 0; function getRootId(_) { return _ ? (RootIds.has(_) || (rootId += 1, RootIds.set(_, rootId.toString())), RootIds.get(_)) : "0" } function optionsToId(_) { return Object.keys(_).sort().filter(j => _[j] !== void 0).map(j => `${j}_${j === "root" ? getRootId(_.root) : _[j]}`).toString() } function createObserver(_) { const j = optionsToId(_); let $ = observerMap.get(j); if (!$) { const _e = new Map; let et; const tt = new IntersectionObserver(rt => { rt.forEach(nt => { var it; const st = nt.isIntersecting && et.some(ot => nt.intersectionRatio >= ot); _.trackVisibility && typeof nt.isVisible > "u" && (nt.isVisible = st), (it = _e.get(nt.target)) == null || it.forEach(ot => { ot(st, nt) }) }) }, _); et = tt.thresholds || (Array.isArray(_.threshold) ? _.threshold : [_.threshold || 0]), $ = { id: j, observer: tt, elements: _e }, observerMap.set(j, $) } return $ } function observe(_, j, $ = {}, _e = unsupportedValue) { if (typeof window.IntersectionObserver > "u" && _e !== void 0) { const it = _.getBoundingClientRect(); return j(_e, { isIntersecting: _e, target: _, intersectionRatio: typeof $.threshold == "number" ? $.threshold : 0, time: 0, boundingClientRect: it, intersectionRect: it, rootBounds: it }), () => { } } const { id: et, observer: tt, elements: rt } = createObserver($), nt = rt.get(_) || []; return rt.has(_) || rt.set(_, nt), nt.push(j), tt.observe(_), function () { nt.splice(nt.indexOf(j), 1), nt.length === 0 && (rt.delete(_), tt.unobserve(_)), rt.size === 0 && (tt.disconnect(), observerMap.delete(et)) } } function isPlainChildren(_) { return typeof _.children != "function" } var InView = class extends reactExports.Component { constructor(_) { super(_), __publicField(this, "node", null), __publicField(this, "_unobserveCb", null), __publicField(this, "handleNode", j => { this.node && (this.unobserve(), !j && !this.props.triggerOnce && !this.props.skip && this.setState({ inView: !!this.props.initialInView, entry: void 0 })), this.node = j || null, this.observeNode() }), __publicField(this, "handleChange", (j, $) => { j && this.props.triggerOnce && this.unobserve(), isPlainChildren(this.props) || this.setState({ inView: j, entry: $ }), this.props.onChange && this.props.onChange(j, $) }), this.state = { inView: !!_.initialInView, entry: void 0 } } componentDidMount() { this.unobserve(), this.observeNode() } componentDidUpdate(_) { (_.rootMargin !== this.props.rootMargin || _.root !== this.props.root || _.threshold !== this.props.threshold || _.skip !== this.props.skip || _.trackVisibility !== this.props.trackVisibility || _.delay !== this.props.delay) && (this.unobserve(), this.observeNode()) } componentWillUnmount() { this.unobserve() } observeNode() { if (!this.node || this.props.skip) return; const { threshold: _, root: j, rootMargin: $, trackVisibility: _e, delay: et, fallbackInView: tt } = this.props; this._unobserveCb = observe(this.node, this.handleChange, { threshold: _, root: j, rootMargin: $, trackVisibility: _e, delay: et }, tt) } unobserve() { this._unobserveCb && (this._unobserveCb(), this._unobserveCb = null) } render() { const { children: _ } = this.props; if (typeof _ == "function") { const { inView: dt, entry: pt } = this.state; return _({ inView: dt, entry: pt, ref: this.handleNode }) } const { as: j, triggerOnce: $, threshold: _e, root: et, rootMargin: tt, onChange: rt, skip: nt, trackVisibility: it, delay: st, initialInView: ot, fallbackInView: ft, ...at } = this.props; return reactExports.createElement(j || "div", { ref: this.handleNode, ...at }, _) } }; function useInView({ threshold: _, delay: j, trackVisibility: $, rootMargin: _e, root: et, triggerOnce: tt, skip: rt, initialInView: nt, fallbackInView: it, onChange: st } = {}) { var ot; const [ft, at] = reactExports.useState(null), dt = reactExports.useRef(), [pt, ht] = reactExports.useState({ inView: !!nt, entry: void 0 }); dt.current = st, reactExports.useEffect(() => { if (rt || !ft) return; let lt; return lt = observe(ft, (mt, yt) => { ht({ inView: mt, entry: yt }), dt.current && dt.current(mt, yt), yt.isIntersecting && tt && lt && (lt(), lt = void 0) }, { root: et, rootMargin: _e, threshold: _, trackVisibility: $, delay: j }, it), () => { lt && lt() } }, [Array.isArray(_) ? _.toString() : _, ft, et, _e, tt, rt, $, it, j]); const xt = (ot = pt.entry) == null ? void 0 : ot.target, ct = reactExports.useRef(); !ft && xt && !tt && !rt && ct.current !== xt && (ct.current = xt, ht({ inView: !!nt, entry: void 0 })); const ut = [at, pt.inView, pt.entry]; return ut.ref = ut[0], ut.inView = ut[1], ut.entry = ut[2], ut } var reactIs = { exports: {} }, reactIs_production_min = {};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b$1 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$1 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h$2 = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u$1; u$1 = Symbol.for("react.module.reference"); function v$2(_) { if (typeof _ == "object" && _ !== null) { var j = _.$$typeof; switch (j) { case b$1: switch (_ = _.type, _) { case d$1: case f$1: case e: case m$1: case n: return _; default: switch (_ = _ && _.$$typeof, _) { case k: case h$2: case l$1: case q: case p$1: case g: return _; default: return j } }case c$1: return j } } } reactIs_production_min.ContextConsumer = h$2; reactIs_production_min.ContextProvider = g; reactIs_production_min.Element = b$1; reactIs_production_min.ForwardRef = l$1; reactIs_production_min.Fragment = d$1; reactIs_production_min.Lazy = q; reactIs_production_min.Memo = p$1; reactIs_production_min.Portal = c$1; reactIs_production_min.Profiler = f$1; reactIs_production_min.StrictMode = e; reactIs_production_min.Suspense = m$1; reactIs_production_min.SuspenseList = n; reactIs_production_min.isAsyncMode = function () { return !1 }; reactIs_production_min.isConcurrentMode = function () { return !1 }; reactIs_production_min.isContextConsumer = function (_) { return v$2(_) === h$2 }; reactIs_production_min.isContextProvider = function (_) { return v$2(_) === g }; reactIs_production_min.isElement = function (_) { return typeof _ == "object" && _ !== null && _.$$typeof === b$1 }; reactIs_production_min.isForwardRef = function (_) { return v$2(_) === l$1 }; reactIs_production_min.isFragment = function (_) { return v$2(_) === d$1 }; reactIs_production_min.isLazy = function (_) { return v$2(_) === q }; reactIs_production_min.isMemo = function (_) { return v$2(_) === p$1 }; reactIs_production_min.isPortal = function (_) { return v$2(_) === c$1 }; reactIs_production_min.isProfiler = function (_) { return v$2(_) === f$1 }; reactIs_production_min.isStrictMode = function (_) { return v$2(_) === e }; reactIs_production_min.isSuspense = function (_) { return v$2(_) === m$1 }; reactIs_production_min.isSuspenseList = function (_) { return v$2(_) === n }; reactIs_production_min.isValidElementType = function (_) { return typeof _ == "string" || typeof _ == "function" || _ === d$1 || _ === f$1 || _ === e || _ === m$1 || _ === n || _ === t || typeof _ == "object" && _ !== null && (_.$$typeof === q || _.$$typeof === p$1 || _.$$typeof === g || _.$$typeof === h$2 || _.$$typeof === l$1 || _.$$typeof === u$1 || _.getModuleId !== void 0) }; reactIs_production_min.typeOf = v$2; reactIs.exports = reactIs_production_min; var reactIsExports = reactIs.exports; keyframes`
  from,
  20%,
  53%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    transform: translate3d(0, 0, 0);
  }

  40%,
  43% {
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    transform: translate3d(0, -30px, 0) scaleY(1.1);
  }

  70% {
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    transform: translate3d(0, -15px, 0) scaleY(1.05);
  }

  80% {
    transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    transform: translate3d(0, 0, 0) scaleY(0.95);
  }

  90% {
    transform: translate3d(0, -4px, 0) scaleY(1.02);
  }
`; keyframes`
  from,
  50%,
  to {
    opacity: 1;
  }

  25%,
  75% {
    opacity: 0;
  }
`; keyframes`
  0% {
    transform: translateX(0);
  }

  6.5% {
    transform: translateX(-6px) rotateY(-9deg);
  }

  18.5% {
    transform: translateX(5px) rotateY(7deg);
  }

  31.5% {
    transform: translateX(-3px) rotateY(-5deg);
  }

  43.5% {
    transform: translateX(2px) rotateY(3deg);
  }

  50% {
    transform: translateX(0);
  }
`; keyframes`
  0% {
    transform: scale(1);
  }

  14% {
    transform: scale(1.3);
  }

  28% {
    transform: scale(1);
  }

  42% {
    transform: scale(1.3);
  }

  70% {
    transform: scale(1);
  }
`; keyframes`
  from,
  11.1%,
  to {
    transform: translate3d(0, 0, 0);
  }

  22.2% {
    transform: skewX(-12.5deg) skewY(-12.5deg);
  }

  33.3% {
    transform: skewX(6.25deg) skewY(6.25deg);
  }

  44.4% {
    transform: skewX(-3.125deg) skewY(-3.125deg);
  }

  55.5% {
    transform: skewX(1.5625deg) skewY(1.5625deg);
  }

  66.6% {
    transform: skewX(-0.78125deg) skewY(-0.78125deg);
  }

  77.7% {
    transform: skewX(0.390625deg) skewY(0.390625deg);
  }

  88.8% {
    transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
  }
`; keyframes`
  from {
    transform: scale3d(1, 1, 1);
  }

  50% {
    transform: scale3d(1.05, 1.05, 1.05);
  }

  to {
    transform: scale3d(1, 1, 1);
  }
`; keyframes`
  from {
    transform: scale3d(1, 1, 1);
  }

  30% {
    transform: scale3d(1.25, 0.75, 1);
  }

  40% {
    transform: scale3d(0.75, 1.25, 1);
  }

  50% {
    transform: scale3d(1.15, 0.85, 1);
  }

  65% {
    transform: scale3d(0.95, 1.05, 1);
  }

  75% {
    transform: scale3d(1.05, 0.95, 1);
  }

  to {
    transform: scale3d(1, 1, 1);
  }
`; keyframes`
  from,
  to {
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    transform: translate3d(-10px, 0, 0);
  }

  20%,
  40%,
  60%,
  80% {
    transform: translate3d(10px, 0, 0);
  }
`; keyframes`
  from,
  to {
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    transform: translate3d(-10px, 0, 0);
  }

  20%,
  40%,
  60%,
  80% {
    transform: translate3d(10px, 0, 0);
  }
`; keyframes`
  from,
  to {
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    transform: translate3d(0, -10px, 0);
  }

  20%,
  40%,
  60%,
  80% {
    transform: translate3d(0, 10px, 0);
  }
`; keyframes`
  20% {
    transform: rotate3d(0, 0, 1, 15deg);
  }

  40% {
    transform: rotate3d(0, 0, 1, -10deg);
  }

  60% {
    transform: rotate3d(0, 0, 1, 5deg);
  }

  80% {
    transform: rotate3d(0, 0, 1, -5deg);
  }

  to {
    transform: rotate3d(0, 0, 1, 0deg);
  }
`; keyframes`
  from {
    transform: scale3d(1, 1, 1);
  }

  10%,
  20% {
    transform: scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg);
  }

  30%,
  50%,
  70%,
  90% {
    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
  }

  40%,
  60%,
  80% {
    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
  }

  to {
    transform: scale3d(1, 1, 1);
  }
`; keyframes`
  from {
    transform: translate3d(0, 0, 0);
  }

  15% {
    transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
  }

  30% {
    transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
  }

  45% {
    transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
  }

  60% {
    transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
  }

  75% {
    transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(-100%, 100%, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(100%, 100%, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(0, -100%, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(0, -2000px, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; const fadeInLeft = keyframes`
  from {
    opacity: 0;
    transform: translate3d(-100%, 0, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(-2000px, 0, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(100%, 0, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(2000px, 0, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(-100%, -100%, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(100%, -100%, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(0, 100%, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(0, 2000px, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; function getAnimationCss({ duration: _ = 1e3, delay: j = 0, timingFunction: $ = "ease", keyframes: _e = fadeInLeft, iterationCount: et = 1 }) {
  return css`
    animation-duration: ${_}ms;
    animation-timing-function: ${$};
    animation-delay: ${j}ms;
    animation-name: ${_e};
    animation-direction: normal;
    animation-fill-mode: both;
    animation-iteration-count: ${et};

    @media (prefers-reduced-motion: reduce) {
      animation: none;
    }
  `} function isNullable(_) { return _ == null } function isStringLike(_) { return typeof _ == "string" || typeof _ == "number" || typeof _ == "boolean" } function matchIf(_, j) { return $ => $ ? _() : j() } function matchIfOrNull(_) { return matchIf(_, () => null) } function hideWhen(_) { return matchIfOrNull(() => ({ opacity: 0 }))(_) } const Reveal = _ => { const { cascade: j = !1, damping: $ = .5, delay: _e = 0, duration: et = 1e3, fraction: tt = 0, keyframes: rt = fadeInLeft, triggerOnce: nt = !1, className: it, style: st, childClassName: ot, childStyle: ft, children: at, onVisibilityChange: dt } = _, pt = reactExports.useMemo(() => getAnimationCss({ keyframes: rt, duration: et }), [et, rt]); return isNullable(at) ? null : isStringLike(at) ? jsx(TextReveal, { ..._, animationStyles: pt, children: String(at) }) : reactIsExports.isFragment(at) ? jsx(FragmentReveal, { ..._, animationStyles: pt }) : jsx(Fragment, { children: reactExports.Children.map(at, (ht, xt) => { if (!reactExports.isValidElement(ht)) return null; const ct = _e + (j ? xt * et * $ : 0); switch (ht.type) { case "ol": case "ul": return jsx(ClassNames, { children: ({ cx: ut }) => jsx(ht.type, { ...ht.props, className: ut(it, ht.props.className), style: Object.assign({}, st, ht.props.style), children: jsx(Reveal, { ..._, children: ht.props.children }) }) }); case "li": return jsx(InView, { threshold: tt, triggerOnce: nt, onChange: dt, children: ({ inView: ut, ref: lt }) => jsx(ClassNames, { children: ({ cx: mt }) => jsx(ht.type, { ...ht.props, ref: lt, className: mt(ot, ht.props.className), css: matchIfOrNull(() => pt)(ut), style: Object.assign({}, ft, ht.props.style, hideWhen(!ut), { animationDelay: ct + "ms" }) }) }) }); default: return jsx(InView, { threshold: tt, triggerOnce: nt, onChange: dt, children: ({ inView: ut, ref: lt }) => jsx("div", { ref: lt, className: it, css: matchIfOrNull(() => pt)(ut), style: Object.assign({}, st, hideWhen(!ut), { animationDelay: ct + "ms" }), children: jsx(ClassNames, { children: ({ cx: mt }) => jsx(ht.type, { ...ht.props, className: mt(ot, ht.props.className), style: Object.assign({}, ft, ht.props.style) }) }) }) }) } }) }) }, textBaseStyles = { display: "inline-block", whiteSpace: "pre" }, TextReveal = _ => { const { animationStyles: j, cascade: $ = !1, damping: _e = .5, delay: et = 0, duration: tt = 1e3, fraction: rt = 0, triggerOnce: nt = !1, className: it, style: st, children: ot, onVisibilityChange: ft } = _, { ref: at, inView: dt } = useInView({ triggerOnce: nt, threshold: rt, onChange: ft }); return matchIf(() => jsx("div", { ref: at, className: it, style: Object.assign({}, st, textBaseStyles), children: ot.split("").map((pt, ht) => jsx("span", { css: matchIfOrNull(() => j)(dt), style: { animationDelay: et + ht * tt * _e + "ms" }, children: pt }, ht)) }), () => jsx(FragmentReveal, { ..._, children: ot }))($) }, FragmentReveal = _ => { const { animationStyles: j, fraction: $ = 0, triggerOnce: _e = !1, className: et, style: tt, children: rt, onVisibilityChange: nt } = _, { ref: it, inView: st } = useInView({ triggerOnce: _e, threshold: $, onChange: nt }); return jsx("div", { ref: it, className: et, css: matchIfOrNull(() => j)(st), style: Object.assign({}, tt, hideWhen(!st)), children: rt }) }, bounceIn = keyframes`
  from,
  20%,
  40%,
  60%,
  80%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    transform: scale3d(0.3, 0.3, 0.3);
  }

  20% {
    transform: scale3d(1.1, 1.1, 1.1);
  }

  40% {
    transform: scale3d(0.9, 0.9, 0.9);
  }

  60% {
    opacity: 1;
    transform: scale3d(1.03, 1.03, 1.03);
  }

  80% {
    transform: scale3d(0.97, 0.97, 0.97);
  }

  to {
    opacity: 1;
    transform: scale3d(1, 1, 1);
  }
`, bounceInDown = keyframes`
  from,
  60%,
  75%,
  90%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    transform: translate3d(0, -3000px, 0) scaleY(3);
  }

  60% {
    opacity: 1;
    transform: translate3d(0, 25px, 0) scaleY(0.9);
  }

  75% {
    transform: translate3d(0, -10px, 0) scaleY(0.95);
  }

  90% {
    transform: translate3d(0, 5px, 0) scaleY(0.985);
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`, bounceInLeft = keyframes`
  from,
  60%,
  75%,
  90%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    transform: translate3d(-3000px, 0, 0) scaleX(3);
  }

  60% {
    opacity: 1;
    transform: translate3d(25px, 0, 0) scaleX(1);
  }

  75% {
    transform: translate3d(-10px, 0, 0) scaleX(0.98);
  }

  90% {
    transform: translate3d(5px, 0, 0) scaleX(0.995);
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`, bounceInRight = keyframes`
  from,
  60%,
  75%,
  90%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  from {
    opacity: 0;
    transform: translate3d(3000px, 0, 0) scaleX(3);
  }

  60% {
    opacity: 1;
    transform: translate3d(-25px, 0, 0) scaleX(1);
  }

  75% {
    transform: translate3d(10px, 0, 0) scaleX(0.98);
  }

  90% {
    transform: translate3d(-5px, 0, 0) scaleX(0.995);
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`, bounceInUp = keyframes`
  from,
  60%,
  75%,
  90%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  from {
    opacity: 0;
    transform: translate3d(0, 3000px, 0) scaleY(5);
  }

  60% {
    opacity: 1;
    transform: translate3d(0, -20px, 0) scaleY(0.9);
  }

  75% {
    transform: translate3d(0, 10px, 0) scaleY(0.95);
  }

  90% {
    transform: translate3d(0, -5px, 0) scaleY(0.985);
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`, bounceOut = keyframes`
  20% {
    transform: scale3d(0.9, 0.9, 0.9);
  }

  50%,
  55% {
    opacity: 1;
    transform: scale3d(1.1, 1.1, 1.1);
  }

  to {
    opacity: 0;
    transform: scale3d(0.3, 0.3, 0.3);
  }
`, bounceOutDown = keyframes`
  20% {
    transform: translate3d(0, 10px, 0) scaleY(0.985);
  }

  40%,
  45% {
    opacity: 1;
    transform: translate3d(0, -20px, 0) scaleY(0.9);
  }

  to {
    opacity: 0;
    transform: translate3d(0, 2000px, 0) scaleY(3);
  }
`, bounceOutLeft = keyframes`
  20% {
    opacity: 1;
    transform: translate3d(20px, 0, 0) scaleX(0.9);
  }

  to {
    opacity: 0;
    transform: translate3d(-2000px, 0, 0) scaleX(2);
  }
`, bounceOutRight = keyframes`
  20% {
    opacity: 1;
    transform: translate3d(-20px, 0, 0) scaleX(0.9);
  }

  to {
    opacity: 0;
    transform: translate3d(2000px, 0, 0) scaleX(2);
  }
`, bounceOutUp = keyframes`
  20% {
    transform: translate3d(0, -10px, 0) scaleY(0.985);
  }

  40%,
  45% {
    opacity: 1;
    transform: translate3d(0, 20px, 0) scaleY(0.9);
  }

  to {
    opacity: 0;
    transform: translate3d(0, -2000px, 0) scaleY(3);
  }
`; function getStyles$6(_, j) { switch (j) { case "down": return _ ? bounceOutDown : bounceInDown; case "left": return _ ? bounceOutLeft : bounceInLeft; case "right": return _ ? bounceOutRight : bounceInRight; case "up": return _ ? bounceOutUp : bounceInUp; default: return _ ? bounceOut : bounceIn } } const Bounce = _ => { const { direction: j, reverse: $ = !1, ..._e } = _, et = reactExports.useMemo(() => getStyles$6($, j), [j, $]); return jsx(Reveal, { keyframes: et, ..._e }) }; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
  }
`; keyframes`
  from {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }

  to {
    opacity: 0;
    transform: translate3d(-100%, 100%, 0);
  }
`; keyframes`
  from {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }

  to {
    opacity: 0;
    transform: translate3d(100%, 100%, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(0, 100%, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(0, 2000px, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(-100%, 0, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(-2000px, 0, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(100%, 0, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(2000px, 0, 0);
  }
`; keyframes`
  from {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }

  to {
    opacity: 0;
    transform: translate3d(-100%, -100%, 0);
  }
`; keyframes`
  from {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }

  to {
    opacity: 0;
    transform: translate3d(100%, -100%, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(0, -100%, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(0, -2000px, 0);
  }
`; keyframes`
  from {
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg);
    animation-timing-function: ease-out;
  }

  40% {
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg);
    animation-timing-function: ease-out;
  }

  50% {
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg);
    animation-timing-function: ease-in;
  }

  80% {
    transform: perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg);
    animation-timing-function: ease-in;
  }

  to {
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg);
    animation-timing-function: ease-in;
  }
`; keyframes`
  from {
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    animation-timing-function: ease-in;
    opacity: 0;
  }

  40% {
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    animation-timing-function: ease-in;
  }

  60% {
    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    opacity: 1;
  }

  80% {
    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
  }

  to {
    transform: perspective(400px);
  }
`; keyframes`
  from {
    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    animation-timing-function: ease-in;
    opacity: 0;
  }

  40% {
    transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    animation-timing-function: ease-in;
  }

  60% {
    transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    opacity: 1;
  }

  80% {
    transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
  }

  to {
    transform: perspective(400px);
  }
`; keyframes`
  from {
    transform: perspective(400px);
  }

  30% {
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    opacity: 1;
  }

  to {
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    opacity: 0;
  }
`; keyframes`
  from {
    transform: perspective(400px);
  }

  30% {
    transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    opacity: 1;
  }

  to {
    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    opacity: 0;
  }
`; keyframes`
  0% {
    animation-timing-function: ease-in-out;
  }

  20%,
  60% {
    transform: rotate3d(0, 0, 1, 80deg);
    animation-timing-function: ease-in-out;
  }

  40%,
  80% {
    transform: rotate3d(0, 0, 1, 60deg);
    animation-timing-function: ease-in-out;
    opacity: 1;
  }

  to {
    transform: translate3d(0, 700px, 0);
    opacity: 0;
  }
`; keyframes`
  from {
    opacity: 0;
    transform: scale(0.1) rotate(30deg);
    transform-origin: center bottom;
  }

  50% {
    transform: rotate(-10deg);
  }

  70% {
    transform: rotate(3deg);
  }

  to {
    opacity: 1;
    transform: scale(1);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
  }
`; keyframes`
  from {
    transform: rotate3d(0, 0, 1, -200deg);
    opacity: 0;
  }

  to {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
`; keyframes`
  from {
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }

  to {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
`; keyframes`
  from {
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }

  to {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
`; keyframes`
  from {
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }

  to {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
`; keyframes`
  from {
    transform: rotate3d(0, 0, 1, -90deg);
    opacity: 0;
  }

  to {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    transform: rotate3d(0, 0, 1, 200deg);
    opacity: 0;
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }
`; keyframes`
  from {
    opacity: 1;
  }

  to {
    transform: rotate3d(0, 0, 1, 90deg);
    opacity: 0;
  }
`; keyframes`
  from {
    transform: translate3d(0, -100%, 0);
    visibility: visible;
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    transform: translate3d(-100%, 0, 0);
    visibility: visible;
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    transform: translate3d(100%, 0, 0);
    visibility: visible;
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    transform: translate3d(0, 100%, 0);
    visibility: visible;
  }

  to {
    transform: translate3d(0, 0, 0);
  }
`; keyframes`
  from {
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    transform: translate3d(0, 100%, 0);
  }
`; keyframes`
  from {
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    transform: translate3d(-100%, 0, 0);
  }
`; keyframes`
  from {
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    transform: translate3d(100%, 0, 0);
  }
`; keyframes`
  from {
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    transform: translate3d(0, -100%, 0);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: scale3d(0.3, 0.3, 0.3);
  }

  50% {
    opacity: 1;
  }
`; keyframes`
  from {
    opacity: 0;
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
`; keyframes`
  from {
    opacity: 0;
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
`; keyframes`
  from {
    opacity: 1;
  }

  50% {
    opacity: 0;
    transform: scale3d(0.3, 0.3, 0.3);
  }

  to {
    opacity: 0;
  }
`; keyframes`
  40% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  to {
    opacity: 0;
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
`; keyframes`
  40% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0);
  }

  to {
    opacity: 0;
    transform: scale(0.1) translate3d(-2000px, 0, 0);
  }
`; keyframes`
  40% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0);
  }

  to {
    opacity: 0;
    transform: scale(0.1) translate3d(2000px, 0, 0);
  }
`; keyframes`
  40% {
    opacity: 1;
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  to {
    opacity: 0;
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
`; const About = () => jsxRuntimeExports.jsxs("div", { className: "about", children: [jsxRuntimeExports.jsx("div", { style: { fontFamily: "VT323", textAlign: "left", fontSize: 50, marginLeft: 20 }, children: "About me" }), jsxRuntimeExports.jsx(Bounce, { style: { padding: 20, borderRadius: 20 }, children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, children: jsxRuntimeExports.jsx("div", { className: "text-center", children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsx(Image$2, { src: profile, style: { width: 500, borderRadius: 20 } }) }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, className: "d-flex align-items-center justify-content-center", children: jsxRuntimeExports.jsxs("div", { children: ["I'm a Software Engineer with a passion for ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "web and mobile development." }), jsxRuntimeExports.jsx("br", {}), "I have experience in both ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "frontend and backend" }), " development, and I'm always looking for new challenges.", jsxRuntimeExports.jsx("br", {}), "I'm currently pursuing my MSc in Software Engineering at ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "Polytechnic University of Turin" }), ", Italy."] }) })] }) }), jsxRuntimeExports.jsx(Bounce, { className: "d-none d-lg-block", children: jsxRuntimeExports.jsxs(Row$1, { style: { fontSize: 18, textAlign: "center", marginTop: 70 }, children: [jsxRuntimeExports.jsx(Col$1, { md: { span: 6, offset: 0 }, children: jsxRuntimeExports.jsx("a", { href: "https://scamporrinoandrea.github.io/Resume/Resume_Andrea_Scamporrino.pdf", target: "_blank", rel: "noopener noreferrer", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 20, borderRadius: 10, minWidth: 250, fontSize: 20 }, children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "60", height: "60", fill: "currentColor", className: "bi bi-file-earmark-person-fill", viewBox: "0 0 16 16", children: jsxRuntimeExports.jsx("path", { d: "M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 .293A1 1 0 0 0 9.293 0M9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1M11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0m2 5.755V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-.245S4 12 8 12s5 1.755 5 1.755" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, className: "d-flex align-items-center justify-content-center", children: "View my resume" })] }) }) }) }) }), jsxRuntimeExports.jsx(Col$1, { md: { span: 6 }, children: jsxRuntimeExports.jsx("a", { href: "mailto:scamporrino.andrea@gmail.com", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 20, borderRadius: 10, minWidth: 250, fontSize: 20 }, children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "60", height: "60", fill: "currentColor", className: "bi bi-envelope-open", viewBox: "0 0 16 16", children: jsxRuntimeExports.jsx("path", { d: "M8.47 1.318a1 1 0 0 0-.94 0l-6 3.2A1 1 0 0 0 1 5.4v.817l5.75 3.45L8 8.917l1.25.75L15 6.217V5.4a1 1 0 0 0-.53-.882zM15 7.383l-4.778 2.867L15 13.117zm-.035 6.88L8 10.082l-6.965 4.18A1 1 0 0 0 2 15h12a1 1 0 0 0 .965-.738ZM1 13.116l4.778-2.867L1 7.383v5.734ZM7.059.435a2 2 0 0 1 1.882 0l6 3.2A2 2 0 0 1 16 5.4V14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5.4a2 2 0 0 1 1.059-1.765z" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, md: 12, className: "d-flex align-items-center justify-content-center", children: "Contact me" })] }) }) }) }) })] }) })] }), v$1 = "5.5.6", fr = 29.9700012207031, ip = 0, op = 89.0000036250443, w = 51, h$1 = 130, nm = "Scroll_icon_white", ddd = 0, assets = [], layers = [{ ddd: 0, ind: 1, ty: 4, nm: "ÃÂ¡ÃÂ»ÃÂ¾ÃÂ¹ 6 Outlines", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 1, k: [{ i: { x: .433, y: 1 }, o: { x: .717, y: .009 }, t: 0, s: [25.179, 30.476, 0], to: [0, 3.604, 0], ti: [0, -3.604, 0] }, { t: 59.0000024031193, s: [25.179, 52.101, 0] }], ix: 2 }, a: { a: 0, k: [.763, 3.624, 0], ix: 1 }, s: { a: 1, k: [{ i: { x: [.667, .667, .667], y: [1, 1, 1] }, o: { x: [.333, .333, .333], y: [0, 0, 0] }, t: 0, s: [100, 0, 100] }, { i: { x: [.667, .667, .667], y: [1, 1, 1] }, o: { x: [.333, .333, .333], y: [0, 0, 0] }, t: 30, s: [100, 100, 100] }, { t: 59.0000024031193, s: [100, 0, 100] }], ix: 6 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0]], o: [[0, 0], [0, 0]], v: [[.763, .763], [.763, 6.485]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1.526, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Group 1", np: 2, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 900.000036657751, st: 0, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "ÃÂ¡ÃÂ»ÃÂ¾ÃÂ¹ 10 Outlines", sr: 1, ks: { o: { a: 1, k: [{ i: { x: [.667], y: [1] }, o: { x: [.333], y: [0] }, t: 34, s: [0] }, { i: { x: [.667], y: [1] }, o: { x: [.333], y: [0] }, t: 51, s: [100] }, { t: 68.0000027696968, s: [0] }], ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [25.179, 119.784, 0], ix: 2 }, a: { a: 0, k: [12.971, 7.248, 0], ix: 1 }, s: { a: 0, k: [100, 100, 100], ix: 6 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0]], o: [[0, 0], [0, 0], [0, 0]], v: [[-11.445, -5.722], [0, 5.722], [11.445, -5.722]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1.526, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [12.971, 7.248], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Group 1", np: 2, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 34.0000013848484, op: 934.0000380426, st: 34.0000013848484, bm: 0 }, { ddd: 0, ind: 3, ty: 4, nm: "ÃÂ¡ÃÂ»ÃÂ¾ÃÂ¹ 9 Outlines", sr: 1, ks: { o: { a: 1, k: [{ i: { x: [.667], y: [1] }, o: { x: [.333], y: [0] }, t: 17, s: [0] }, { i: { x: [.667], y: [1] }, o: { x: [.333], y: [0] }, t: 34, s: [100] }, { t: 51.0000020772726, s: [0] }], ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [25.179, 102.284, 0], ix: 2 }, a: { a: 0, k: [12.971, 7.248, 0], ix: 1 }, s: { a: 0, k: [100, 100, 100], ix: 6 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0]], o: [[0, 0], [0, 0], [0, 0]], v: [[-11.445, -5.722], [0, 5.722], [11.445, -5.722]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1.526, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [12.971, 7.248], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Group 1", np: 2, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 17.0000006924242, op: 917.000037350176, st: 17.0000006924242, bm: 0 }, { ddd: 0, ind: 4, ty: 4, nm: "ÃÂ¡ÃÂ»ÃÂ¾ÃÂ¹ 4 Outlines", sr: 1, ks: { o: { a: 1, k: [{ i: { x: [.667], y: [1] }, o: { x: [.333], y: [0] }, t: 0, s: [0] }, { i: { x: [.667], y: [1] }, o: { x: [.333], y: [0] }, t: 17, s: [100] }, { t: 34.0000013848484, s: [0] }], ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [25.179, 82.784, 0], ix: 2 }, a: { a: 0, k: [12.971, 7.248, 0], ix: 1 }, s: { a: 0, k: [100, 100, 100], ix: 6 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0]], o: [[0, 0], [0, 0], [0, 0]], v: [[-11.445, -5.722], [0, 5.722], [11.445, -5.722]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1.526, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [12.971, 7.248], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Group 1", np: 2, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 900.000036657751, st: 0, bm: 0 }, { ddd: 0, ind: 5, ty: 4, nm: "ÃÂ¡ÃÂ»ÃÂ¾ÃÂ¹ 5 Outlines", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [25.179, 46.542, 0], ix: 2 }, a: { a: 0, k: [12.208, 22.127, 0], ix: 1 }, s: { a: 0, k: [100, 100, 100], ix: 6 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-5.899, 0], [0, 0], [0, -5.899], [0, 0], [5.899, 0], [0, 5.899], [0, 0]], o: [[0, 0], [5.899, 0], [0, 0], [0, 5.899], [-5.899, 0], [0, 0], [0, -5.899]], v: [[0, -20.6], [0, -20.6], [10.682, -9.918], [10.682, 9.92], [0, 20.6], [-10.682, 9.92], [-10.682, -9.918]], c: !0 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1.526, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [12.208, 22.127], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Group 1", np: 2, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 900.000036657751, st: 0, bm: 0 }], markers = [], scroll = { v: v$1, fr, ip, op, w, h: h$1, nm, ddd, assets, layers, markers }, Projects = () => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("div", { id: "projects", style: { color: "white", width: "100vw", height: "100vh", display: "flex", justifyContent: "center", alignItems: "center" }, children: jsxRuntimeExports.jsxs("div", { style: { color: "white", fontFamily: "VT323", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "left" }, children: [jsxRuntimeExports.jsx("div", { style: { textAlign: "center", fontSize: 100 }, children: "Projects" }), jsxRuntimeExports.jsxs("div", { style: { textAlign: "center" }, children: ["Still scrolling to see more projects", jsxRuntimeExports.jsx(Lottie, { animationData: scroll, style: { height: 150, color: "white" } })] })] }) }) }), toyotaVideo = "./assets/toyotaVideo-7C3MiGOV.mp4"; var DefaultContext = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, IconContext = React$1.createContext && React$1.createContext(DefaultContext), _excluded = ["attr", "size", "title"]; function _objectWithoutProperties(_, j) { if (_ == null) return {}; var $ = _objectWithoutPropertiesLoose(_, j), _e, et; if (Object.getOwnPropertySymbols) { var tt = Object.getOwnPropertySymbols(_); for (et = 0; et < tt.length; et++)_e = tt[et], !(j.indexOf(_e) >= 0) && Object.prototype.propertyIsEnumerable.call(_, _e) && ($[_e] = _[_e]) } return $ } function _objectWithoutPropertiesLoose(_, j) { if (_ == null) return {}; var $ = {}, _e = Object.keys(_), et, tt; for (tt = 0; tt < _e.length; tt++)et = _e[tt], !(j.indexOf(et) >= 0) && ($[et] = _[et]); return $ } function _extends$6() { return _extends$6 = Object.assign ? Object.assign.bind() : function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _extends$6.apply(this, arguments) } function ownKeys(_, j) { var $ = Object.keys(_); if (Object.getOwnPropertySymbols) { var _e = Object.getOwnPropertySymbols(_); j && (_e = _e.filter(function (et) { return Object.getOwnPropertyDescriptor(_, et).enumerable })), $.push.apply($, _e) } return $ } function _objectSpread(_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j] != null ? arguments[j] : {}; j % 2 ? ownKeys(Object($), !0).forEach(function (_e) { _defineProperty(_, _e, $[_e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors($)) : ownKeys(Object($)).forEach(function (_e) { Object.defineProperty(_, _e, Object.getOwnPropertyDescriptor($, _e)) }) } return _ } function _defineProperty(_, j, $) { return j = _toPropertyKey(j), j in _ ? Object.defineProperty(_, j, { value: $, enumerable: !0, configurable: !0, writable: !0 }) : _[j] = $, _ } function _toPropertyKey(_) { var j = _toPrimitive(_, "string"); return typeof j == "symbol" ? j : String(j) } function _toPrimitive(_, j) { if (typeof _ != "object" || _ === null) return _; var $ = _[Symbol.toPrimitive]; if ($ !== void 0) { var _e = $.call(_, j || "default"); if (typeof _e != "object") return _e; throw new TypeError("@@toPrimitive must return a primitive value.") } return (j === "string" ? String : Number)(_) } function Tree2Element(_) { return _ && _.map((j, $) => React$1.createElement(j.tag, _objectSpread({ key: $ }, j.attr), Tree2Element(j.child))) } function GenIcon(_) { return j => React$1.createElement(IconBase, _extends$6({ attr: _objectSpread({}, _.attr) }, j), Tree2Element(_.child)) } function IconBase(_) { var j = $ => { var { attr: _e, size: et, title: tt } = _, rt = _objectWithoutProperties(_, _excluded), nt = et || $.size || "1em", it; return $.className && (it = $.className), _.className && (it = (it ? it + " " : "") + _.className), React$1.createElement("svg", _extends$6({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, $.attr, _e, rt, { className: it, style: _objectSpread(_objectSpread({ color: _.color || $.color }, $.style), _.style), height: nt, width: nt, xmlns: "http://www.w3.org/2000/svg" }), tt && React$1.createElement("title", null, tt), _.children) }; return IconContext !== void 0 ? React$1.createElement(IconContext.Consumer, null, $ => j($)) : j(DefaultContext) } function SiPostgresql(_) { return GenIcon({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M23.5594 14.7228a.5269.5269 0 0 0-.0563-.1191c-.139-.2632-.4768-.3418-1.0074-.2321-1.6533.3411-2.2935.1312-2.5256-.0191 1.342-2.0482 2.445-4.522 3.0411-6.8297.2714-1.0507.7982-3.5237.1222-4.7316a1.5641 1.5641 0 0 0-.1509-.235C21.6931.9086 19.8007.0248 17.5099.0005c-1.4947-.0158-2.7705.3461-3.1161.4794a9.449 9.449 0 0 0-.5159-.0816 8.044 8.044 0 0 0-1.3114-.1278c-1.1822-.0184-2.2038.2642-3.0498.8406-.8573-.3211-4.7888-1.645-7.2219.0788C.9359 2.1526.3086 3.8733.4302 6.3043c.0409.818.5069 3.334 1.2423 5.7436.4598 1.5065.9387 2.7019 1.4334 3.582.553.9942 1.1259 1.5933 1.7143 1.7895.4474.1491 1.1327.1441 1.8581-.7279.8012-.9635 1.5903-1.8258 1.9446-2.2069.4351.2355.9064.3625 1.39.3772a.0569.0569 0 0 0 .0004.0041 11.0312 11.0312 0 0 0-.2472.3054c-.3389.4302-.4094.5197-1.5002.7443-.3102.064-1.1344.2339-1.1464.8115-.0025.1224.0329.2309.0919.3268.2269.4231.9216.6097 1.015.6331 1.3345.3335 2.5044.092 3.3714-.6787-.017 2.231.0775 4.4174.3454 5.0874.2212.5529.7618 1.9045 2.4692 1.9043.2505 0 .5263-.0291.8296-.0941 1.7819-.3821 2.5557-1.1696 2.855-2.9059.1503-.8707.4016-2.8753.5388-4.1012.0169-.0703.0357-.1207.057-.1362.0007-.0005.0697-.0471.4272.0307a.3673.3673 0 0 0 .0443.0068l.2539.0223.0149.001c.8468.0384 1.9114-.1426 2.5312-.4308.6438-.2988 1.8057-1.0323 1.5951-1.6698zM2.371 11.8765c-.7435-2.4358-1.1779-4.8851-1.2123-5.5719-.1086-2.1714.4171-3.6829 1.5623-4.4927 1.8367-1.2986 4.8398-.5408 6.108-.13-.0032.0032-.0066.0061-.0098.0094-2.0238 2.044-1.9758 5.536-1.9708 5.7495-.0002.0823.0066.1989.0162.3593.0348.5873.0996 1.6804-.0735 2.9184-.1609 1.1504.1937 2.2764.9728 3.0892.0806.0841.1648.1631.2518.2374-.3468.3714-1.1004 1.1926-1.9025 2.1576-.5677.6825-.9597.5517-1.0886.5087-.3919-.1307-.813-.5871-1.2381-1.3223-.4796-.839-.9635-2.0317-1.4155-3.5126zm6.0072 5.0871c-.1711-.0428-.3271-.1132-.4322-.1772.0889-.0394.2374-.0902.4833-.1409 1.2833-.2641 1.4815-.4506 1.9143-1.0002.0992-.126.2116-.2687.3673-.4426a.3549.3549 0 0 0 .0737-.1298c.1708-.1513.2724-.1099.4369-.0417.156.0646.3078.26.3695.4752.0291.1016.0619.2945-.0452.4444-.9043 1.2658-2.2216 1.2494-3.1676 1.0128zm2.094-3.988-.0525.141c-.133.3566-.2567.6881-.3334 1.003-.6674-.0021-1.3168-.2872-1.8105-.8024-.6279-.6551-.9131-1.5664-.7825-2.5004.1828-1.3079.1153-2.4468.079-3.0586-.005-.0857-.0095-.1607-.0122-.2199.2957-.2621 1.6659-.9962 2.6429-.7724.4459.1022.7176.4057.8305.928.5846 2.7038.0774 3.8307-.3302 4.7363-.084.1866-.1633.3629-.2311.5454zm7.3637 4.5725c-.0169.1768-.0358.376-.0618.5959l-.146.4383a.3547.3547 0 0 0-.0182.1077c-.0059.4747-.054.6489-.115.8693-.0634.2292-.1353.4891-.1794 1.0575-.11 1.4143-.8782 2.2267-2.4172 2.5565-1.5155.3251-1.7843-.4968-2.0212-1.2217a6.5824 6.5824 0 0 0-.0769-.2266c-.2154-.5858-.1911-1.4119-.1574-2.5551.0165-.5612-.0249-1.9013-.3302-2.6462.0044-.2932.0106-.5909.019-.8918a.3529.3529 0 0 0-.0153-.1126 1.4927 1.4927 0 0 0-.0439-.208c-.1226-.4283-.4213-.7866-.7797-.9351-.1424-.059-.4038-.1672-.7178-.0869.067-.276.1831-.5875.309-.9249l.0529-.142c.0595-.16.134-.3257.213-.5012.4265-.9476 1.0106-2.2453.3766-5.1772-.2374-1.0981-1.0304-1.6343-2.2324-1.5098-.7207.0746-1.3799.3654-1.7088.5321a5.6716 5.6716 0 0 0-.1958.1041c.0918-1.1064.4386-3.1741 1.7357-4.4823a4.0306 4.0306 0 0 1 .3033-.276.3532.3532 0 0 0 .1447-.0644c.7524-.5706 1.6945-.8506 2.802-.8325.4091.0067.8017.0339 1.1742.081 1.939.3544 3.2439 1.4468 4.0359 2.3827.8143.9623 1.2552 1.9315 1.4312 2.4543-1.3232-.1346-2.2234.1268-2.6797.779-.9926 1.4189.543 4.1729 1.2811 5.4964.1353.2426.2522.4522.2889.5413.2403.5825.5515.9713.7787 1.2552.0696.087.1372.1714.1885.245-.4008.1155-1.1208.3825-1.0552 1.717-.0123.1563-.0423.4469-.0834.8148-.0461.2077-.0702.4603-.0994.7662zm.8905-1.6211c-.0405-.8316.2691-.9185.5967-1.0105a2.8566 2.8566 0 0 0 .135-.0406 1.202 1.202 0 0 0 .1342.103c.5703.3765 1.5823.4213 3.0068.1344-.2016.1769-.5189.3994-.9533.6011-.4098.1903-1.0957.333-1.7473.3636-.7197.0336-1.0859-.0807-1.1721-.151zm.5695-9.2712c-.0059.3508-.0542.6692-.1054 1.0017-.055.3576-.112.7274-.1264 1.1762-.0142.4368.0404.8909.0932 1.3301.1066.887.216 1.8003-.2075 2.7014a3.5272 3.5272 0 0 1-.1876-.3856c-.0527-.1276-.1669-.3326-.3251-.6162-.6156-1.1041-2.0574-3.6896-1.3193-4.7446.3795-.5427 1.3408-.5661 2.1781-.463zm.2284 7.0137a12.3762 12.3762 0 0 0-.0853-.1074l-.0355-.0444c.7262-1.1995.5842-2.3862.4578-3.4385-.0519-.4318-.1009-.8396-.0885-1.2226.0129-.4061.0666-.7543.1185-1.0911.0639-.415.1288-.8443.1109-1.3505.0134-.0531.0188-.1158.0118-.1902-.0457-.4855-.5999-1.938-1.7294-3.253-.6076-.7073-1.4896-1.4972-2.6889-2.0395.5251-.1066 1.2328-.2035 2.0244-.1859 2.0515.0456 3.6746.8135 4.8242 2.2824a.908.908 0 0 1 .0667.1002c.7231 1.3556-.2762 6.2751-2.9867 10.5405zm-8.8166-6.1162c-.025.1794-.3089.4225-.6211.4225a.5821.5821 0 0 1-.0809-.0056c-.1873-.026-.3765-.144-.5059-.3156-.0458-.0605-.1203-.178-.1055-.2844.0055-.0401.0261-.0985.0925-.1488.1182-.0894.3518-.1226.6096-.0867.3163.0441.6426.1938.6113.4186zm7.9305-.4114c.0111.0792-.049.201-.1531.3102-.0683.0717-.212.1961-.4079.2232a.5456.5456 0 0 1-.075.0052c-.2935 0-.5414-.2344-.5607-.3717-.024-.1765.2641-.3106.5611-.352.297-.0414.6111.0088.6356.1851z" }, child: [] }] })(_) } function SiSpringboot(_) { return GenIcon({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "m23.693 10.7058-4.73-8.1844c-.4094-.7106-1.4166-1.2942-2.2402-1.2942H7.2725c-.819 0-1.8308.5836-2.2402 1.2942L.307 10.7058c-.4095.7106-.4095 1.873 0 2.5837l4.7252 8.189c.4094.7107 1.4166 1.2943 2.2402 1.2943h9.455c.819 0 1.826-.5836 2.2402-1.2942l4.7252-8.189c.4095-.7107.4095-1.8732 0-2.5838zM10.9763 5.7547c0-.5365.4377-.9742.9742-.9742s.9742.4377.9742.9742v5.8217c0 .5366-.4377.9742-.9742.9742s-.9742-.4376-.9742-.9742zm.9742 12.4294c-3.6427 0-6.6077-2.965-6.6077-6.6077.0047-2.0896.993-4.0521 2.6685-5.304a.8657.8657 0 0 1 1.2142.1788.8657.8657 0 0 1-.1788 1.2143c-2.1602 1.6048-2.612 4.6592-1.0072 6.8194 1.6049 2.1603 4.6593 2.612 6.8195 1.0072 1.2378-.9177 1.9673-2.372 1.9673-3.9157a4.8972 4.8972 0 0 0-1.9861-3.925c-.386-.2824-.466-.8284-.1836-1.2143.2824-.386.8283-.466 1.2143-.1835 1.6895 1.2471 2.6826 3.2238 2.6873 5.3228 0 3.6474-2.965 6.6077-6.6077 6.6077z" }, child: [] }] })(_) } function SiToyota(_) { return GenIcon({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M12 3.848C5.223 3.848 0 7.298 0 12c0 4.702 5.224 8.152 12 8.152S24 16.702 24 12c0-4.702-5.223-8.152-12-8.152zm7.334 3.839c0 1.08-1.725 1.913-4.488 2.246-.26-2.58-1.005-4.279-1.963-4.913 2.948.184 6.45 1.227 6.45 2.667zM12 16.401c-.96 0-1.746-1.5-1.808-4.389.577.047 1.18.072 1.808.072.628 0 1.23-.025 1.807-.072-.061 2.89-.847 4.389-1.807 4.389zm0-6.308c-.59 0-1.155-.019-1.69-.054.261-1.728.92-3.15 1.69-3.15.77 0 1.428 1.422 1.689 3.15-.535.034-1.099.054-1.689.054zm-.882-5.075c-.956.633-1.706 2.333-1.964 4.915C6.391 9.6 4.665 8.767 4.665 7.687c0-1.44 3.504-2.49 6.453-2.669zM2.037 11.68a5.265 5.265 0 011.048-3.164c.27 1.547 2.522 2.881 5.972 3.37V12c0 3.772.879 6.203 2.087 6.97-5.107-.321-9.107-3.48-9.107-7.29zm10.823 7.29c1.207-.767 2.087-3.198 2.087-6.97v-.115c3.447-.488 5.704-1.826 5.972-3.37a5.26 5.26 0 011.049 3.165c-.004 3.81-4.008 6.969-9.109 7.29z" }, child: [] }] })(_) } const ToyotaExperience = () => { const { scrollYProgress: _ } = useScroll(), [j, $] = reactExports.useState(0); reactExports.useEffect(() => { const et = () => { const tt = document.getElementById("toyota-exp"), rt = document.getElementById("second-text"); if (tt && rt) { const nt = tt.getBoundingClientRect(), it = rt.getBoundingClientRect(), st = nt.width - it.width; $(st) } }; return et(), window.addEventListener("resize", et), () => window.removeEventListener("resize", et) }, []); const _e = useTransform(_, [.154, .2265], [0, j]); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: "flex flex-col", style: { fontFamily: "VT323", color: "white" }, children: [jsxRuntimeExports.jsxs(motion.div, { style: { fontSize: "50px", x: _e, display: "flex", alignItems: "center", gap: "10px", marginTop: 10 }, children: [jsxRuntimeExports.jsx("span", { children: "Internship at Toyota" }), jsxRuntimeExports.jsx(SiToyota, {})] }), jsxRuntimeExports.jsxs("div", { className: "flex flex-row", children: [jsxRuntimeExports.jsxs("div", { id: "target", style: { width: "100vw", fontSize: "25px", marginRight: "25vw" }, children: ["I completed a ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "six-month internship" }), " at Toyota Motor Europe as a Software Engineer in Belgium. ", jsxRuntimeExports.jsx("br", {}), "I developed a custom internal", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: " application" }), " from scratch using Microsoft Power Platform.", jsxRuntimeExports.jsx("br", {}), "The application was designed to manage vehicle testing, optimizing workflows and improving data management efficiency across teams."] }), jsxRuntimeExports.jsxs("div", { id: "second-text", style: { width: "100vw", fontSize: "25px" }, children: ["I designed the system architecture and UI/UX in Figma, implementing both the ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "frontend and backend" }), " while integrating SharePoint, PowerApps, and Power Automate. ", jsxRuntimeExports.jsx("br", {}), "Through iterative development and ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "collaboration with stakeholders" }), ", I deployed a fully operational solution that reduces processing time by an estimated 199 hours per year, delivering a business value of €22,000 annually."] })] })] }), jsxRuntimeExports.jsx("div", { style: { textAlign: "center", marginBottom: 40, marginTop: 15 }, children: jsxRuntimeExports.jsxs(motion.video, { autoPlay: !0, loop: !0, muted: !0, style: { maxWidth: "62vw", height: "auto", maxHeight: "50vh", borderRadius: 20, objectFit: "contain", x: _e }, children: [jsxRuntimeExports.jsx("source", { src: toyotaVideo, type: "video/mp4" }), "Your browser does not support the video tag."] }) })] }) }; function i(_, j, $, _e) { return new ($ || ($ = Promise))(function (et, tt) { function rt(st) { try { it(_e.next(st)) } catch (ot) { tt(ot) } } function nt(st) { try { it(_e.throw(st)) } catch (ot) { tt(ot) } } function it(st) { var ot; st.done ? et(st.value) : (ot = st.value, ot instanceof $ ? ot : new $(function (ft) { ft(ot) })).then(rt, nt) } it((_e = _e.apply(_, j || [])).next()) }) } function u(_, j) { var $, _e, et, tt, rt = { label: 0, sent: function () { if (1 & et[0]) throw et[1]; return et[1] }, trys: [], ops: [] }; return tt = { next: nt(0), throw: nt(1), return: nt(2) }, typeof Symbol == "function" && (tt[Symbol.iterator] = function () { return this }), tt; function nt(it) { return function (st) { return function (ot) { if ($) throw new TypeError("Generator is already executing."); for (; rt;)try { if ($ = 1, _e && (et = 2 & ot[0] ? _e.return : ot[0] ? _e.throw || ((et = _e.return) && et.call(_e), 0) : _e.next) && !(et = et.call(_e, ot[1])).done) return et; switch (_e = 0, et && (ot = [2 & ot[0], et.value]), ot[0]) { case 0: case 1: et = ot; break; case 4: return rt.label++, { value: ot[1], done: !1 }; case 5: rt.label++, _e = ot[1], ot = [0]; continue; case 7: ot = rt.ops.pop(), rt.trys.pop(); continue; default: if (et = rt.trys, !((et = et.length > 0 && et[et.length - 1]) || ot[0] !== 6 && ot[0] !== 2)) { rt = 0; continue } if (ot[0] === 3 && (!et || ot[1] > et[0] && ot[1] < et[3])) { rt.label = ot[1]; break } if (ot[0] === 6 && rt.label < et[1]) { rt.label = et[1], et = ot; break } if (et && rt.label < et[2]) { rt.label = et[2], rt.ops.push(ot); break } et[2] && rt.ops.pop(), rt.trys.pop(); continue }ot = j.call(_, rt) } catch (ft) { ot = [6, ft], _e = 0 } finally { $ = et = 0 } if (5 & ot[0]) throw ot[1]; return { value: ot[0] ? ot[1] : void 0, done: !0 } }([it, st]) } } } function c(_) { var j = typeof Symbol == "function" && Symbol.iterator, $ = j && _[j], _e = 0; if ($) return $.call(_); if (_ && typeof _.length == "number") return { next: function () { return _ && _e >= _.length && (_ = void 0), { value: _ && _[_e++], done: !_ } } }; throw new TypeError(j ? "Object is not iterable." : "Symbol.iterator is not defined.") } function l(_, j) { var $ = typeof Symbol == "function" && _[Symbol.iterator]; if (!$) return _; var _e, et, tt = $.call(_), rt = []; try { for (; (j === void 0 || j-- > 0) && !(_e = tt.next()).done;)rt.push(_e.value) } catch (nt) { et = { error: nt } } finally { try { _e && !_e.done && ($ = tt.return) && $.call(tt) } finally { if (et) throw et.error } } return rt } function s(_, j, $) { if ($ || arguments.length === 2) for (var _e, et = 0, tt = j.length; et < tt; et++)!_e && et in j || (_e || (_e = Array.prototype.slice.call(j, 0, et)), _e[et] = j[et]); return _.concat(_e || Array.prototype.slice.call(j)) } function f(_, j, $, _e, et) { for (var tt = [], rt = 5; rt < arguments.length; rt++)tt[rt - 5] = arguments[rt]; return i(this, void 0, void 0, function () { var nt, it, st, ot, ft, at; return u(this, function (dt) { switch (dt.label) { case 0: dt.trys.push([0, 12, 13, 14]), nt = c(tt), it = nt.next(), dt.label = 1; case 1: if (it.done) return [3, 11]; switch (st = it.value, typeof st) { case "string": return [3, 2]; case "number": return [3, 4]; case "function": return [3, 6] }return [3, 8]; case 2: return [4, d(_, j, st, $, _e, et)]; case 3: return dt.sent(), [3, 10]; case 4: return [4, p(st)]; case 5: return dt.sent(), [3, 10]; case 6: return [4, st.apply(void 0, s([_, j, $, _e, et], l(tt), !1))]; case 7: return dt.sent(), [3, 10]; case 8: return [4, st]; case 9: dt.sent(), dt.label = 10; case 10: return it = nt.next(), [3, 1]; case 11: return [3, 14]; case 12: return ot = dt.sent(), ft = { error: ot }, [3, 14]; case 13: try { it && !it.done && (at = nt.return) && at.call(nt) } finally { if (ft) throw ft.error } return [7]; case 14: return [2] } }) }) } function d(_, j, $, _e, et, tt) { return i(this, void 0, void 0, function () { var rt, nt; return u(this, function (it) { switch (it.label) { case 0: return rt = _.textContent || "", nt = function (st, ot) { var ft = l(ot).slice(0); return s(s([], l(st), !1), [NaN], !1).findIndex(function (at, dt) { return ft[dt] !== at }) }(rt, $), [4, h(_, s(s([], l(v(rt, j, nt)), !1), l(y($, j, nt)), !1), _e, et, tt)]; case 1: return it.sent(), [2] } }) }) } function p(_) { return i(this, void 0, void 0, function () { return u(this, function (j) { switch (j.label) { case 0: return [4, new Promise(function ($) { return setTimeout($, _) })]; case 1: return j.sent(), [2] } }) }) } function h(_, j, $, _e, et) { return i(this, void 0, void 0, function () { var tt, rt, nt, it, st, ot, ft, at, dt, pt, ht, xt, ct; return u(this, function (ut) { switch (ut.label) { case 0: if (tt = j, et) { for (rt = 0, nt = 1; nt < j.length; nt++)if (it = l([j[nt - 1], j[nt]], 2), st = it[0], (ot = it[1]).length > st.length || ot === "") { rt = nt; break } tt = j.slice(rt, j.length) } ut.label = 1; case 1: ut.trys.push([1, 6, 7, 8]), ft = c(function (lt) { var mt, yt, gt, St, bt, _t, Mt; return u(this, function (It) { switch (It.label) { case 0: mt = function (Rt) { return u(this, function (Lt) { switch (Lt.label) { case 0: return [4, { op: function (Vt) { return requestAnimationFrame(function () { return Vt.textContent = Rt }) }, opCode: function (Vt) { var At = Vt.textContent || ""; return Rt === "" || At.length > Rt.length ? "DELETE" : "WRITING" } }]; case 1: return Lt.sent(), [2] } }) }, It.label = 1; case 1: It.trys.push([1, 6, 7, 8]), yt = c(lt), gt = yt.next(), It.label = 2; case 2: return gt.done ? [3, 5] : (St = gt.value, [5, mt(St)]); case 3: It.sent(), It.label = 4; case 4: return gt = yt.next(), [3, 2]; case 5: return [3, 8]; case 6: return bt = It.sent(), _t = { error: bt }, [3, 8]; case 7: try { gt && !gt.done && (Mt = yt.return) && Mt.call(yt) } finally { if (_t) throw _t.error } return [7]; case 8: return [2] } }) }(tt)), at = ft.next(), ut.label = 2; case 2: return at.done ? [3, 5] : (dt = at.value, pt = dt.opCode(_) === "WRITING" ? $ + $ * (Math.random() - .5) : _e + _e * (Math.random() - .5), dt.op(_), [4, p(pt)]); case 3: ut.sent(), ut.label = 4; case 4: return at = ft.next(), [3, 2]; case 5: return [3, 8]; case 6: return ht = ut.sent(), xt = { error: ht }, [3, 8]; case 7: try { at && !at.done && (ct = ft.return) && ct.call(ft) } finally { if (xt) throw xt.error } return [7]; case 8: return [2] } }) }) } function y(_, j, $) { var _e, et; return $ === void 0 && ($ = 0), u(this, function (tt) { switch (tt.label) { case 0: _e = j(_), et = _e.length, tt.label = 1; case 1: return $ < et ? [4, _e.slice(0, ++$).join("")] : [3, 3]; case 2: return tt.sent(), [3, 1]; case 3: return [2] } }) } function v(_, j, $) { var _e, et; return $ === void 0 && ($ = 0), u(this, function (tt) { switch (tt.label) { case 0: _e = j(_), et = _e.length, tt.label = 1; case 1: return et > $ ? [4, _e.slice(0, --et).join("")] : [3, 3]; case 2: return tt.sent(), [3, 1]; case 3: return [2] } }) } var b = "index-module_type__E-SaG"; (function (_, j) { j === void 0 && (j = {}); var $ = j.insertAt; if (_ && typeof document < "u") { var _e = document.head || document.getElementsByTagName("head")[0], et = document.createElement("style"); et.type = "text/css", $ === "top" && _e.firstChild ? _e.insertBefore(et, _e.firstChild) : _e.appendChild(et), et.styleSheet ? et.styleSheet.cssText = _ : et.appendChild(document.createTextNode(_)) } })(`.index-module_type__E-SaG::after {
  content: '|';
  animation: index-module_cursor__PQg0P 1.1s infinite step-start;
}

@keyframes index-module_cursor__PQg0P {
  50% {
    opacity: 0;
  }
}
`); var m = reactExports.memo(reactExports.forwardRef(function (_, j) { var $ = _.sequence, _e = _.repeat, et = _.className, tt = _.speed, rt = tt === void 0 ? 40 : tt, nt = _.deletionSpeed, it = _.omitDeletionAnimation, st = it !== void 0 && it, ot = _.preRenderFirstString, ft = ot !== void 0 && ot, at = _.wrapper, dt = at === void 0 ? "span" : at, pt = _.splitter, ht = pt === void 0 ? function (Ct) { return s([], l(Ct), !1) } : pt, xt = _.cursor, ct = xt === void 0 || xt, ut = _.style, lt = function (Ct, wt) { var Tt = {}; for (var jt in Ct) Object.prototype.hasOwnProperty.call(Ct, jt) && wt.indexOf(jt) < 0 && (Tt[jt] = Ct[jt]); if (Ct != null && typeof Object.getOwnPropertySymbols == "function") { var Ft = 0; for (jt = Object.getOwnPropertySymbols(Ct); Ft < jt.length; Ft++)wt.indexOf(jt[Ft]) < 0 && Object.prototype.propertyIsEnumerable.call(Ct, jt[Ft]) && (Tt[jt[Ft]] = Ct[jt[Ft]]) } return Tt }(_, ["sequence", "repeat", "className", "speed", "deletionSpeed", "omitDeletionAnimation", "preRenderFirstString", "wrapper", "splitter", "cursor", "style"]), mt = lt["aria-label"], yt = lt["aria-hidden"], gt = lt.role; nt || (nt = rt); var St = new Array(2).fill(40);[rt, nt].forEach(function (Ct, wt) { switch (typeof Ct) { case "number": St[wt] = Math.abs(Ct - 100); break; case "object": var Tt = Ct.type, jt = Ct.value; if (typeof jt != "number") break; Tt === "keyStrokeDelayInMs" && (St[wt] = jt) } }); var bt, _t, Mt, It, Rt, Lt, Vt = St[0], At = St[1], Pt = function (Ct, wt) { wt === void 0 && (wt = null); var Tt = reactExports.useRef(wt); return reactExports.useEffect(function () { Ct && (typeof Ct == "function" ? Ct(Tt.current) : Ct.current = Tt.current) }, [Ct]), Tt }(j), kt = b; bt = et ? "".concat(ct ? kt + " " : "").concat(et) : ct ? kt : "", _t = reactExports.useRef(function () { var Ct, wt = $; _e === 1 / 0 ? Ct = f : typeof _e == "number" && (wt = Array(1 + _e).fill($).flat()); var Tt = Ct ? s(s([], l(wt), !1), [Ct], !1) : s([], l(wt), !1); return f.apply(void 0, s([Pt.current, ht, Vt, At, st], l(Tt), !1)), function () { Pt.current } }), Mt = reactExports.useRef(), It = reactExports.useRef(!1), Rt = reactExports.useRef(!1), Lt = l(reactExports.useState(0), 2)[1], It.current && (Rt.current = !0), reactExports.useEffect(function () { return It.current || (Mt.current = _t.current(), It.current = !0), Lt(function (Ct) { return Ct + 1 }), function () { Rt.current && Mt.current && Mt.current() } }, []); var vt = dt, Et = ft ? $.find(function (Ct) { return typeof Ct == "string" }) || "" : null; return React$1.createElement(vt, { "aria-hidden": yt, "aria-label": mt, role: gt, style: ut, className: bt, children: mt ? React$1.createElement("span", { "aria-hidden": "true", ref: Pt, children: Et }) : Et, ref: mt ? void 0 : Pt }) }), function (_, j) { return !0 }); const CardProject = _ => jsxRuntimeExports.jsxs("div", { style: { height: "100%", fontFamily: "VT323" }, className: "d-flex flex-column", children: [jsxRuntimeExports.jsx("div", { style: { display: "block", marginLeft: "auto", marginRight: "auto" }, children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsx(Image$2, { src: _.image, fluid: !0, style: { borderRadius: 10, maxHeight: "50vh" } }) }) }), jsxRuntimeExports.jsxs("div", { style: { padding: 10 }, className: "d-flex flex-column", children: [jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", fontFamily: "VT323", fontSize: 40 }, children: [jsxRuntimeExports.jsx("div", { children: _.title }), jsxRuntimeExports.jsx("div", { children: _.icon })] }), jsxRuntimeExports.jsx("div", { style: { fontFamily: "VT323", fontSize: 20 }, children: _.description }), jsxRuntimeExports.jsx("div", { style: { width: "100%", textAlign: "center", marginTop: 30 }, children: jsxRuntimeExports.jsx("a", { href: _.github, target: "_blank", rel: "noopener noreferrer", className: "text-decoration-none", style: { color: "white" }, children: _.title === "Gino Panino Website" ? jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-globe", viewBox: "0 0 16 16", style: { marginRight: 10 }, children: jsxRuntimeExports.jsx("path", { d: "M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m7.5-6.923c-.67.204-1.335.82-1.887 1.855A8 8 0 0 0 5.145 4H7.5zM4.09 4a9.3 9.3 0 0 1 .64-1.539 7 7 0 0 1 .597-.933A7.03 7.03 0 0 0 2.255 4zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a7 7 0 0 0-.656 2.5zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5zM8.5 5v2.5h2.99a12.5 12.5 0 0 0-.337-2.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5zM5.145 12q.208.58.468 1.068c.552 1.035 1.218 1.65 1.887 1.855V12zm.182 2.472a7 7 0 0 1-.597-.933A9.3 9.3 0 0 1 4.09 12H2.255a7 7 0 0 0 3.072 2.472M3.82 11a13.7 13.7 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5zm6.853 3.472A7 7 0 0 0 13.745 12H11.91a9.3 9.3 0 0 1-.64 1.539 7 7 0 0 1-.597.933M8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855q.26-.487.468-1.068zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.7 13.7 0 0 1-.312 2.5m2.802-3.5a7 7 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7 7 0 0 0-3.072-2.472c.218.284.418.598.597.933M10.855 4a8 8 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4z" }) }), "Check the website"] }) }) }) : jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-github", viewBox: "0 0 16 16", style: { marginRight: 10 }, children: jsxRuntimeExports.jsx("path", { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" }) }), "View on GitHub"] }) }) }) }) })] })] }), ProjectList = ({ projects: _ }) => { const j = reactExports.useRef([]); j.current = _.map((et, tt) => j.current[tt] || React$1.createRef()); const [$, _e] = reactExports.useState(Array(_.length - 1).fill(!1)); return reactExports.useEffect(() => { const et = new IntersectionObserver(([tt]) => { const rt = j.current.findIndex(nt => nt.current === tt.target); rt > 0 && _e(nt => { const it = [...nt]; return it[rt - 1] = tt.isIntersecting, it }) }, { threshold: .1 }); return j.current.forEach(tt => { tt.current && et.observe(tt.current) }), () => { j.current.forEach(tt => { tt.current && et.unobserve(tt.current) }) } }, []), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("div", { id: "scrollableContent", style: { backgroundColor: "rgba(38,38,38)", padddingLeft: "100px" }, children: _.map((et, tt) => jsxRuntimeExports.jsx("div", { ref: j.current[tt], style: { overflow: "hidden", height: "100vh", position: "sticky", top: "10vh", borderRadius: 20, backgroundColor: "rgba(38,38,38)", color: "white", width: "50vw", marginLeft: "25vw", filter: $[tt] ? "blur(5px)" : "blur(0px)", transform: $[tt] ? "scale(0.8)" : "scale(1)", transition: "filter 0.7s, transform 0.7s" }, children: jsxRuntimeExports.jsx(CardProject, { index: tt, title: et.title, description: et.description, image: et.image, icon: et.icon, github: et.github }) }, tt)) }), jsxRuntimeExports.jsx("div", { className: "d-none d-lg-block", style: { backgroundColor: "rgba(38,38,38)", padddingLeft: "100px", fontFamily: "VT323", overflow: "hidden" }, children: jsxRuntimeExports.jsxs(Row$1, { style: { fontSize: 18, textAlign: "center", paddingBottom: 50 }, children: [jsxRuntimeExports.jsx(Col$1, { md: { span: 4, offset: 2 }, children: jsxRuntimeExports.jsx("a", { href: "https://github.com/ScamporrinoAndrea", target: "_blank", rel: "noopener noreferrer", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 20, borderRadius: 10, fontSize: 20, width: 250 }, children: jsxRuntimeExports.jsx(Bounce, { children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "60", height: "60", fill: "currentColor", className: "bi bi-github", viewBox: "0 0 16 16", style: { marginRight: 10 }, children: jsxRuntimeExports.jsx("path", { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, className: "d-flex align-items-center justify-content-center", children: "More projects" })] }) }) }) }) }) }), jsxRuntimeExports.jsx(Col$1, { md: { span: 4 }, children: jsxRuntimeExports.jsx("a", { href: "mailto:scamporrino.andrea@gmail.com", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 20, borderRadius: 10, fontSize: 20, width: 250 }, children: jsxRuntimeExports.jsx(Bounce, { children: jsxRuntimeExports.jsx(o, { children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "60", height: "60", fill: "currentColor", className: "bi bi-envelope-open", viewBox: "0 0 16 16", children: jsxRuntimeExports.jsx("path", { d: "M8.47 1.318a1 1 0 0 0-.94 0l-6 3.2A1 1 0 0 0 1 5.4v.817l5.75 3.45L8 8.917l1.25.75L15 6.217V5.4a1 1 0 0 0-.53-.882zM15 7.383l-4.778 2.867L15 13.117zm-.035 6.88L8 10.082l-6.965 4.18A1 1 0 0 0 2 15h12a1 1 0 0 0 .965-.738ZM1 13.116l4.778-2.867L1 7.383v5.734ZM7.059.435a2 2 0 0 1 1.882 0l6 3.2A2 2 0 0 1 16 5.4V14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5.4a2 2 0 0 1 1.059-1.765z" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, md: 12, className: "d-flex align-items-center justify-content-center", children: "Contact me" })] }) }) }) }) }) })] }) })] }) }, ProgressBar = () => { const [_, j] = reactExports.useState(0), { scrollYProgress: $ } = useScroll(); return reactExports.useEffect(() => { const _e = () => { window.innerWidth > 991 && j($.get() * 100) }; return _e(), window.addEventListener("scroll", _e), () => { window.removeEventListener("scroll", _e) } }, []), jsxRuntimeExports.jsx("div", { style: { position: "fixed", top: 0, left: 100, height: "100vh", width: 5, backgroundColor: "transparent", zIndex: 100 }, children: jsxRuntimeExports.jsx("div", { style: { height: `${_}%`, width: 5, backgroundColor: "rgb(0, 255, 10)" } }) }) }; var modules = {}, Link$1 = {}, scrollLink = {}, scrollSpy$2 = {}, FUNC_ERROR_TEXT = "Expected a function", NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), objectProto = Object.prototype, objectToString = objectProto.toString, nativeMax = Math.max, nativeMin = Math.min, now = function () { return root.Date.now() }; function debounce(_, j, $) { var _e, et, tt, rt, nt, it, st = 0, ot = !1, ft = !1, at = !0; if (typeof _ != "function") throw new TypeError(FUNC_ERROR_TEXT); j = toNumber(j) || 0, isObject($) && (ot = !!$.leading, ft = "maxWait" in $, tt = ft ? nativeMax(toNumber($.maxWait) || 0, j) : tt, at = "trailing" in $ ? !!$.trailing : at); function dt(gt) { var St = _e, bt = et; return _e = et = void 0, st = gt, rt = _.apply(bt, St), rt } function pt(gt) { return st = gt, nt = setTimeout(ct, j), ot ? dt(gt) : rt } function ht(gt) { var St = gt - it, bt = gt - st, _t = j - St; return ft ? nativeMin(_t, tt - bt) : _t } function xt(gt) { var St = gt - it, bt = gt - st; return it === void 0 || St >= j || St < 0 || ft && bt >= tt } function ct() { var gt = now(); if (xt(gt)) return ut(gt); nt = setTimeout(ct, ht(gt)) } function ut(gt) { return nt = void 0, at && _e ? dt(gt) : (_e = et = void 0, rt) } function lt() { nt !== void 0 && clearTimeout(nt), st = 0, _e = it = et = nt = void 0 } function mt() { return nt === void 0 ? rt : ut(now()) } function yt() { var gt = now(), St = xt(gt); if (_e = arguments, et = this, it = gt, St) { if (nt === void 0) return pt(it); if (ft) return nt = setTimeout(ct, j), dt(it) } return nt === void 0 && (nt = setTimeout(ct, j)), rt } return yt.cancel = lt, yt.flush = mt, yt } function throttle(_, j, $) { var _e = !0, et = !0; if (typeof _ != "function") throw new TypeError(FUNC_ERROR_TEXT); return isObject($) && (_e = "leading" in $ ? !!$.leading : _e, et = "trailing" in $ ? !!$.trailing : et), debounce(_, j, { leading: _e, maxWait: j, trailing: et }) } function isObject(_) { var j = typeof _; return !!_ && (j == "object" || j == "function") } function isObjectLike(_) { return !!_ && typeof _ == "object" } function isSymbol(_) { return typeof _ == "symbol" || isObjectLike(_) && objectToString.call(_) == symbolTag } function toNumber(_) { if (typeof _ == "number") return _; if (isSymbol(_)) return NAN; if (isObject(_)) { var j = typeof _.valueOf == "function" ? _.valueOf() : _; _ = isObject(j) ? j + "" : j } if (typeof _ != "string") return _ === 0 ? _ : +_; _ = _.replace(reTrim, ""); var $ = reIsBinary.test(_); return $ || reIsOctal.test(_) ? freeParseInt(_.slice(2), $ ? 2 : 8) : reIsBadHex.test(_) ? NAN : +_ } var lodash_throttle = throttle, passiveEventListeners = {}; Object.defineProperty(passiveEventListeners, "__esModule", { value: !0 }); passiveEventListeners.addPassiveEventListener = function _(j, $, _e) { var et = _e.name; et || (et = $, console.warn("Listener must be a named function.")), attachedListeners.has($) || attachedListeners.set($, new Set); var tt = attachedListeners.get($); if (!tt.has(et)) { var rt = function () { var nt = !1; try { var it = Object.defineProperty({}, "passive", { get: function () { nt = !0 } }); window.addEventListener("test", null, it) } catch { } return nt }(); j.addEventListener($, _e, rt ? { passive: !0 } : !1), tt.add(et) } }; passiveEventListeners.removePassiveEventListener = function _(j, $, _e) { j.removeEventListener($, _e), attachedListeners.get($).delete(_e.name || $) }; var attachedListeners = new Map; Object.defineProperty(scrollSpy$2, "__esModule", { value: !0 }); var _lodash = lodash_throttle, _lodash2 = _interopRequireDefault$9(_lodash), _passiveEventListeners$1 = passiveEventListeners; function _interopRequireDefault$9(_) { return _ && _.__esModule ? _ : { default: _ } } var eventThrottler = function _(j) { var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66; return (0, _lodash2.default)(j, $) }, scrollSpy$1 = { spyCallbacks: [], spySetState: [], scrollSpyContainers: [], mount: function _(j, $) { if (j) { var _e = eventThrottler(function (et) { scrollSpy$1.scrollHandler(j) }, $); scrollSpy$1.scrollSpyContainers.push(j), (0, _passiveEventListeners$1.addPassiveEventListener)(j, "scroll", _e) } }, isMounted: function _(j) { return scrollSpy$1.scrollSpyContainers.indexOf(j) !== -1 }, currentPositionX: function _(j) { if (j === document) { var $ = window.pageYOffset !== void 0, _e = (document.compatMode || "") === "CSS1Compat"; return $ ? window.pageXOffset : _e ? document.documentElement.scrollLeft : document.body.scrollLeft } else return j.scrollLeft }, currentPositionY: function _(j) { if (j === document) { var $ = window.pageXOffset !== void 0, _e = (document.compatMode || "") === "CSS1Compat"; return $ ? window.pageYOffset : _e ? document.documentElement.scrollTop : document.body.scrollTop } else return j.scrollTop }, scrollHandler: function _(j) { var $ = scrollSpy$1.scrollSpyContainers[scrollSpy$1.scrollSpyContainers.indexOf(j)].spyCallbacks || []; $.forEach(function (_e) { return _e(scrollSpy$1.currentPositionX(j), scrollSpy$1.currentPositionY(j)) }) }, addStateHandler: function _(j) { scrollSpy$1.spySetState.push(j) }, addSpyHandler: function _(j, $) { var _e = scrollSpy$1.scrollSpyContainers[scrollSpy$1.scrollSpyContainers.indexOf($)]; _e.spyCallbacks || (_e.spyCallbacks = []), _e.spyCallbacks.push(j), j(scrollSpy$1.currentPositionX($), scrollSpy$1.currentPositionY($)) }, updateStates: function _() { scrollSpy$1.spySetState.forEach(function (j) { return j() }) }, unmount: function _(j, $) { scrollSpy$1.scrollSpyContainers.forEach(function (_e) { return _e.spyCallbacks && _e.spyCallbacks.length && _e.spyCallbacks.indexOf($) > -1 && _e.spyCallbacks.splice(_e.spyCallbacks.indexOf($), 1) }), scrollSpy$1.spySetState && scrollSpy$1.spySetState.length && scrollSpy$1.spySetState.indexOf(j) > -1 && scrollSpy$1.spySetState.splice(scrollSpy$1.spySetState.indexOf(j), 1), document.removeEventListener("scroll", scrollSpy$1.scrollHandler) }, update: function _() { return scrollSpy$1.scrollSpyContainers.forEach(function (j) { return scrollSpy$1.scrollHandler(j) }) } }; scrollSpy$2.default = scrollSpy$1; var scroller = {}, utils = {}; Object.defineProperty(utils, "__esModule", { value: !0 }); var updateHash = function _(j, $) { var _e = j.indexOf("#") === 0 ? j.substring(1) : j, et = _e ? "#" + _e : "", tt = window && window.location, rt = et ? tt.pathname + tt.search + et : tt.pathname + tt.search; $ ? history.pushState(history.state, "", rt) : history.replaceState(history.state, "", rt) }, getHash = function _() { return window.location.hash.replace(/^#/, "") }, filterElementInContainer = function _(j) { return function ($) { return j.contains ? j != $ && j.contains($) : !!(j.compareDocumentPosition($) & 16) } }, isPositioned = function _(j) { return getComputedStyle(j).position !== "static" }, getElementOffsetInfoUntil = function _(j, $) { for (var _e = j.offsetTop, et = j.offsetParent; et && !$(et);)_e += et.offsetTop, et = et.offsetParent; return { offsetTop: _e, offsetParent: et } }, scrollOffset = function _(j, $, _e) { if (_e) return j === document ? $.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(j).position !== "static" ? $.offsetLeft : $.offsetLeft - j.offsetLeft; if (j === document) return $.getBoundingClientRect().top + (window.scrollY || window.pageYOffset); if (isPositioned(j)) { if ($.offsetParent !== j) { var et = function (ot) { return ot === j || ot === document }, tt = getElementOffsetInfoUntil($, et), rt = tt.offsetTop, nt = tt.offsetParent; if (nt !== j) throw new Error("Seems containerElement is not an ancestor of the Element"); return rt } return $.offsetTop } if ($.offsetParent === j.offsetParent) return $.offsetTop - j.offsetTop; var it = function (ot) { return ot === document }; return getElementOffsetInfoUntil($, it).offsetTop - getElementOffsetInfoUntil(j, it).offsetTop }; utils.default = { updateHash, getHash, filterElementInContainer, scrollOffset }; var animateScroll$2 = {}, smooth = {}; Object.defineProperty(smooth, "__esModule", { value: !0 }); smooth.default = { defaultEasing: function _(j) { return j < .5 ? Math.pow(j * 2, 2) / 2 : 1 - Math.pow((1 - j) * 2, 2) / 2 }, linear: function _(j) { return j }, easeInQuad: function _(j) { return j * j }, easeOutQuad: function _(j) { return j * (2 - j) }, easeInOutQuad: function _(j) { return j < .5 ? 2 * j * j : -1 + (4 - 2 * j) * j }, easeInCubic: function _(j) { return j * j * j }, easeOutCubic: function _(j) { return --j * j * j + 1 }, easeInOutCubic: function _(j) { return j < .5 ? 4 * j * j * j : (j - 1) * (2 * j - 2) * (2 * j - 2) + 1 }, easeInQuart: function _(j) { return j * j * j * j }, easeOutQuart: function _(j) { return 1 - --j * j * j * j }, easeInOutQuart: function _(j) { return j < .5 ? 8 * j * j * j * j : 1 - 8 * --j * j * j * j }, easeInQuint: function _(j) { return j * j * j * j * j }, easeOutQuint: function _(j) { return 1 + --j * j * j * j * j }, easeInOutQuint: function _(j) { return j < .5 ? 16 * j * j * j * j * j : 1 + 16 * --j * j * j * j * j } }; var cancelEvents = {}; Object.defineProperty(cancelEvents, "__esModule", { value: !0 }); var _passiveEventListeners = passiveEventListeners, events = ["mousedown", "mousewheel", "touchmove", "keydown"]; cancelEvents.default = { subscribe: function _(j) { return typeof document < "u" && events.forEach(function ($) { return (0, _passiveEventListeners.addPassiveEventListener)(document, $, j) }) } }; var scrollEvents = {}; Object.defineProperty(scrollEvents, "__esModule", { value: !0 }); var Events = { registered: {}, scrollEvent: { register: function _(j, $) { Events.registered[j] = $ }, remove: function _(j) { Events.registered[j] = null } } }; scrollEvents.default = Events; Object.defineProperty(animateScroll$2, "__esModule", { value: !0 }); var _extends$5 = Object.assign || function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _utils$2 = utils; _interopRequireDefault$8(_utils$2); var _smooth = smooth, _smooth2 = _interopRequireDefault$8(_smooth), _cancelEvents = cancelEvents, _cancelEvents2 = _interopRequireDefault$8(_cancelEvents), _scrollEvents$2 = scrollEvents, _scrollEvents2$2 = _interopRequireDefault$8(_scrollEvents$2); function _interopRequireDefault$8(_) { return _ && _.__esModule ? _ : { default: _ } } var getAnimationType = function _(j) { return _smooth2.default[j.smooth] || _smooth2.default.defaultEasing }, functionWrapper = function _(j) { return typeof j == "function" ? j : function () { return j } }, currentWindowProperties = function _() { if (typeof window < "u") return window.requestAnimationFrame || window.webkitRequestAnimationFrame }, requestAnimationFrameHelper = function () { return currentWindowProperties() || function (_, j, $) { window.setTimeout(_, $ || 1e3 / 60, new Date().getTime()) } }(), makeData = function _() { return { currentPosition: 0, startPosition: 0, targetPosition: 0, progress: 0, duration: 0, cancel: !1, target: null, containerElement: null, to: null, start: null, delta: null, percent: null, delayTimeout: null } }, currentPositionX = function _(j) { var $ = j.data.containerElement; if ($ && $ !== document && $ !== document.body) return $.scrollLeft; var _e = window.pageXOffset !== void 0, et = (document.compatMode || "") === "CSS1Compat"; return _e ? window.pageXOffset : et ? document.documentElement.scrollLeft : document.body.scrollLeft }, currentPositionY = function _(j) { var $ = j.data.containerElement; if ($ && $ !== document && $ !== document.body) return $.scrollTop; var _e = window.pageXOffset !== void 0, et = (document.compatMode || "") === "CSS1Compat"; return _e ? window.pageYOffset : et ? document.documentElement.scrollTop : document.body.scrollTop }, scrollContainerWidth = function _(j) { var $ = j.data.containerElement; if ($ && $ !== document && $ !== document.body) return $.scrollWidth - $.offsetWidth; var _e = document.body, et = document.documentElement; return Math.max(_e.scrollWidth, _e.offsetWidth, et.clientWidth, et.scrollWidth, et.offsetWidth) }, scrollContainerHeight = function _(j) { var $ = j.data.containerElement; if ($ && $ !== document && $ !== document.body) return $.scrollHeight - $.offsetHeight; var _e = document.body, et = document.documentElement; return Math.max(_e.scrollHeight, _e.offsetHeight, et.clientHeight, et.scrollHeight, et.offsetHeight) }, animateScroll$1 = function _(j, $, _e) { var et = $.data; if (!$.ignoreCancelEvents && et.cancel) { _scrollEvents2$2.default.registered.end && _scrollEvents2$2.default.registered.end(et.to, et.target, et.currentPositionY); return } if (et.delta = Math.round(et.targetPosition - et.startPosition), et.start === null && (et.start = _e), et.progress = _e - et.start, et.percent = et.progress >= et.duration ? 1 : j(et.progress / et.duration), et.currentPosition = et.startPosition + Math.ceil(et.delta * et.percent), et.containerElement && et.containerElement !== document && et.containerElement !== document.body ? $.horizontal ? et.containerElement.scrollLeft = et.currentPosition : et.containerElement.scrollTop = et.currentPosition : $.horizontal ? window.scrollTo(et.currentPosition, 0) : window.scrollTo(0, et.currentPosition), et.percent < 1) { var tt = _.bind(null, j, $); requestAnimationFrameHelper.call(window, tt); return } _scrollEvents2$2.default.registered.end && _scrollEvents2$2.default.registered.end(et.to, et.target, et.currentPosition) }, setContainer = function _(j) { j.data.containerElement = j ? j.containerId ? document.getElementById(j.containerId) : j.container && j.container.nodeType ? j.container : document : null }, animateTopScroll = function _(j, $, _e, et) { $.data = $.data || makeData(), window.clearTimeout($.data.delayTimeout); var tt = function () { $.data.cancel = !0 }; if (_cancelEvents2.default.subscribe(tt), setContainer($), $.data.start = null, $.data.cancel = !1, $.data.startPosition = $.horizontal ? currentPositionX($) : currentPositionY($), $.data.targetPosition = $.absolute ? j : j + $.data.startPosition, $.data.startPosition === $.data.targetPosition) { _scrollEvents2$2.default.registered.end && _scrollEvents2$2.default.registered.end($.data.to, $.data.target, $.data.currentPosition); return } $.data.delta = Math.round($.data.targetPosition - $.data.startPosition), $.data.duration = functionWrapper($.duration)($.data.delta), $.data.duration = isNaN(parseFloat($.data.duration)) ? 1e3 : parseFloat($.data.duration), $.data.to = _e, $.data.target = et; var rt = getAnimationType($), nt = animateScroll$1.bind(null, rt, $); if ($ && $.delay > 0) { $.data.delayTimeout = window.setTimeout(function () { _scrollEvents2$2.default.registered.begin && _scrollEvents2$2.default.registered.begin($.data.to, $.data.target), requestAnimationFrameHelper.call(window, nt) }, $.delay); return } _scrollEvents2$2.default.registered.begin && _scrollEvents2$2.default.registered.begin($.data.to, $.data.target), requestAnimationFrameHelper.call(window, nt) }, proceedOptions = function _(j) { return j = _extends$5({}, j), j.data = j.data || makeData(), j.absolute = !0, j }, scrollToTop = function _(j) { animateTopScroll(0, proceedOptions(j)) }, scrollTo = function _(j, $) { animateTopScroll(j, proceedOptions($)) }, scrollToBottom = function _(j) { j = proceedOptions(j), setContainer(j), animateTopScroll(j.horizontal ? scrollContainerWidth(j) : scrollContainerHeight(j), j) }, scrollMore = function _(j, $) { $ = proceedOptions($), setContainer($); var _e = $.horizontal ? currentPositionX($) : currentPositionY($); animateTopScroll(j + _e, $) }; animateScroll$2.default = { animateTopScroll, getAnimationType, scrollToTop, scrollToBottom, scrollTo, scrollMore }; Object.defineProperty(scroller, "__esModule", { value: !0 }); var _extends$4 = Object.assign || function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _utils$1 = utils, _utils2$1 = _interopRequireDefault$7(_utils$1), _animateScroll$1 = animateScroll$2, _animateScroll2$1 = _interopRequireDefault$7(_animateScroll$1), _scrollEvents$1 = scrollEvents, _scrollEvents2$1 = _interopRequireDefault$7(_scrollEvents$1); function _interopRequireDefault$7(_) { return _ && _.__esModule ? _ : { default: _ } } var __mapped = {}, __activeLink = void 0; scroller.default = { unmount: function _() { __mapped = {} }, register: function _(j, $) { __mapped[j] = $ }, unregister: function _(j) { delete __mapped[j] }, get: function _(j) { return __mapped[j] || document.getElementById(j) || document.getElementsByName(j)[0] || document.getElementsByClassName(j)[0] }, setActiveLink: function _(j) { return __activeLink = j }, getActiveLink: function _() { return __activeLink }, scrollTo: function _(j, $) { var _e = this.get(j); if (!_e) { console.warn("target Element not found"); return } $ = _extends$4({}, $, { absolute: !1 }); var et = $.containerId, tt = $.container, rt = void 0; et ? rt = document.getElementById(et) : tt && tt.nodeType ? rt = tt : rt = document, $.absolute = !0; var nt = $.horizontal, it = _utils2$1.default.scrollOffset(rt, _e, nt) + ($.offset || 0); if (!$.smooth) { _scrollEvents2$1.default.registered.begin && _scrollEvents2$1.default.registered.begin(j, _e), rt === document ? $.horizontal ? window.scrollTo(it, 0) : window.scrollTo(0, it) : rt.scrollTop = it, _scrollEvents2$1.default.registered.end && _scrollEvents2$1.default.registered.end(j, _e); return } _animateScroll2$1.default.animateTopScroll(it, $, j, _e) } }; var scrollHash$2 = {}; Object.defineProperty(scrollHash$2, "__esModule", { value: !0 }); var _utils = utils, _utils2 = _interopRequireDefault$6(_utils); function _interopRequireDefault$6(_) { return _ && _.__esModule ? _ : { default: _ } } var scrollHash$1 = { mountFlag: !1, initialized: !1, scroller: null, containers: {}, mount: function _(j) { this.scroller = j, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0 }, mapContainer: function _(j, $) { this.containers[j] = $ }, isMounted: function _() { return this.mountFlag }, isInitialized: function _() { return this.initialized }, initStateFromHash: function _() { var j = this, $ = this.getHash(); $ ? window.setTimeout(function () { j.scrollTo($, !0), j.initialized = !0 }, 10) : this.initialized = !0 }, scrollTo: function _(j, $) { var _e = this.scroller, et = _e.get(j); if (et && ($ || j !== _e.getActiveLink())) { var tt = this.containers[j] || document; _e.scrollTo(j, { container: tt }) } }, getHash: function _() { return _utils2.default.getHash() }, changeHash: function _(j, $) { this.isInitialized() && _utils2.default.getHash() !== j && _utils2.default.updateHash(j, $) }, handleHashChange: function _() { this.scrollTo(this.getHash()) }, unmount: function _() { this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange) } }; scrollHash$2.default = scrollHash$1; Object.defineProperty(scrollLink, "__esModule", { value: !0 }); var _extends$3 = Object.assign || function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _createClass$4 = function () { function _(j, $) { for (var _e = 0; _e < $.length; _e++) { var et = $[_e]; et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(j, et.key, et) } } return function (j, $, _e) { return $ && _(j.prototype, $), _e && _(j, _e), j } }(), _react$4 = reactExports, _react2$4 = _interopRequireDefault$5(_react$4), _scrollSpy$1 = scrollSpy$2, _scrollSpy2$1 = _interopRequireDefault$5(_scrollSpy$1), _scroller$2 = scroller, _scroller2$2 = _interopRequireDefault$5(_scroller$2), _propTypes$2 = propTypesExports, _propTypes2$2 = _interopRequireDefault$5(_propTypes$2), _scrollHash = scrollHash$2, _scrollHash2 = _interopRequireDefault$5(_scrollHash); function _interopRequireDefault$5(_) { return _ && _.__esModule ? _ : { default: _ } } function _classCallCheck$5(_, j) { if (!(_ instanceof j)) throw new TypeError("Cannot call a class as a function") } function _possibleConstructorReturn$5(_, j) { if (!_) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j && (typeof j == "object" || typeof j == "function") ? j : _ } function _inherits$5(_, j) { if (typeof j != "function" && j !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof j); _.prototype = Object.create(j && j.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(_, j) : _.__proto__ = j) } var protoTypes$1 = { to: _propTypes2$2.default.string.isRequired, containerId: _propTypes2$2.default.string, container: _propTypes2$2.default.object, activeClass: _propTypes2$2.default.string, activeStyle: _propTypes2$2.default.object, spy: _propTypes2$2.default.bool, horizontal: _propTypes2$2.default.bool, smooth: _propTypes2$2.default.oneOfType([_propTypes2$2.default.bool, _propTypes2$2.default.string]), offset: _propTypes2$2.default.number, delay: _propTypes2$2.default.number, isDynamic: _propTypes2$2.default.bool, onClick: _propTypes2$2.default.func, duration: _propTypes2$2.default.oneOfType([_propTypes2$2.default.number, _propTypes2$2.default.func]), absolute: _propTypes2$2.default.bool, onSetActive: _propTypes2$2.default.func, onSetInactive: _propTypes2$2.default.func, ignoreCancelEvents: _propTypes2$2.default.bool, hashSpy: _propTypes2$2.default.bool, saveHashHistory: _propTypes2$2.default.bool, spyThrottle: _propTypes2$2.default.number }; scrollLink.default = function (_, j) { var $ = j || _scroller2$2.default, _e = function (tt) { _inherits$5(rt, tt); function rt(nt) { _classCallCheck$5(this, rt); var it = _possibleConstructorReturn$5(this, (rt.__proto__ || Object.getPrototypeOf(rt)).call(this, nt)); return et.call(it), it.state = { active: !1 }, it } return _createClass$4(rt, [{ key: "getScrollSpyContainer", value: function () { var it = this.props.containerId, st = this.props.container; return it && !st ? document.getElementById(it) : st && st.nodeType ? st : document } }, { key: "componentDidMount", value: function () { if (this.props.spy || this.props.hashSpy) { var it = this.getScrollSpyContainer(); _scrollSpy2$1.default.isMounted(it) || _scrollSpy2$1.default.mount(it, this.props.spyThrottle), this.props.hashSpy && (_scrollHash2.default.isMounted() || _scrollHash2.default.mount($), _scrollHash2.default.mapContainer(this.props.to, it)), _scrollSpy2$1.default.addSpyHandler(this.spyHandler, it), this.setState({ container: it }) } } }, { key: "componentWillUnmount", value: function () { _scrollSpy2$1.default.unmount(this.stateHandler, this.spyHandler) } }, { key: "render", value: function () { var it = ""; this.state && this.state.active ? it = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : it = this.props.className; var st = {}; this.state && this.state.active ? st = _extends$3({}, this.props.style, this.props.activeStyle) : st = _extends$3({}, this.props.style); var ot = _extends$3({}, this.props); for (var ft in protoTypes$1) ot.hasOwnProperty(ft) && delete ot[ft]; return ot.className = it, ot.style = st, ot.onClick = this.handleClick, _react2$4.default.createElement(_, ot) } }]), rt }(_react2$4.default.PureComponent), et = function () { var rt = this; this.scrollTo = function (nt, it) { $.scrollTo(nt, _extends$3({}, rt.state, it)) }, this.handleClick = function (nt) { rt.props.onClick && rt.props.onClick(nt), nt.stopPropagation && nt.stopPropagation(), nt.preventDefault && nt.preventDefault(), rt.scrollTo(rt.props.to, rt.props) }, this.spyHandler = function (nt, it) { var st = rt.getScrollSpyContainer(); if (!(_scrollHash2.default.isMounted() && !_scrollHash2.default.isInitialized())) { var ot = rt.props.horizontal, ft = rt.props.to, at = null, dt = void 0, pt = void 0; if (ot) { var ht = 0, xt = 0, ct = 0; if (st.getBoundingClientRect) { var ut = st.getBoundingClientRect(); ct = ut.left } if (!at || rt.props.isDynamic) { if (at = $.get(ft), !at) return; var lt = at.getBoundingClientRect(); ht = lt.left - ct + nt, xt = ht + lt.width } var mt = nt - rt.props.offset; dt = mt >= Math.floor(ht) && mt < Math.floor(xt), pt = mt < Math.floor(ht) || mt >= Math.floor(xt) } else { var yt = 0, gt = 0, St = 0; if (st.getBoundingClientRect) { var bt = st.getBoundingClientRect(); St = bt.top } if (!at || rt.props.isDynamic) { if (at = $.get(ft), !at) return; var _t = at.getBoundingClientRect(); yt = _t.top - St + it, gt = yt + _t.height } var Mt = it - rt.props.offset; dt = Mt >= Math.floor(yt) && Mt < Math.floor(gt), pt = Mt < Math.floor(yt) || Mt >= Math.floor(gt) } var It = $.getActiveLink(); if (pt) { if (ft === It && $.setActiveLink(void 0), rt.props.hashSpy && _scrollHash2.default.getHash() === ft) { var Rt = rt.props.saveHashHistory, Lt = Rt === void 0 ? !1 : Rt; _scrollHash2.default.changeHash("", Lt) } rt.props.spy && rt.state.active && (rt.setState({ active: !1 }), rt.props.onSetInactive && rt.props.onSetInactive(ft, at)) } if (dt && (It !== ft || rt.state.active === !1)) { $.setActiveLink(ft); var Vt = rt.props.saveHashHistory, At = Vt === void 0 ? !1 : Vt; rt.props.hashSpy && _scrollHash2.default.changeHash(ft, At), rt.props.spy && (rt.setState({ active: !0 }), rt.props.onSetActive && rt.props.onSetActive(ft, at)) } } } }; return _e.propTypes = protoTypes$1, _e.defaultProps = { offset: 0 }, _e }; Object.defineProperty(Link$1, "__esModule", { value: !0 }); var _react$3 = reactExports, _react2$3 = _interopRequireDefault$4(_react$3), _scrollLink$2 = scrollLink, _scrollLink2$2 = _interopRequireDefault$4(_scrollLink$2); function _interopRequireDefault$4(_) { return _ && _.__esModule ? _ : { default: _ } } function _classCallCheck$4(_, j) { if (!(_ instanceof j)) throw new TypeError("Cannot call a class as a function") } function _possibleConstructorReturn$4(_, j) { if (!_) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j && (typeof j == "object" || typeof j == "function") ? j : _ } function _inherits$4(_, j) { if (typeof j != "function" && j !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof j); _.prototype = Object.create(j && j.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(_, j) : _.__proto__ = j) } var LinkElement = function (_) { _inherits$4(j, _); function j() { var $, _e, et, tt; _classCallCheck$4(this, j); for (var rt = arguments.length, nt = Array(rt), it = 0; it < rt; it++)nt[it] = arguments[it]; return tt = (_e = (et = _possibleConstructorReturn$4(this, ($ = j.__proto__ || Object.getPrototypeOf(j)).call.apply($, [this].concat(nt))), et), et.render = function () { return _react2$3.default.createElement("a", et.props, et.props.children) }, _e), _possibleConstructorReturn$4(et, tt) } return j }(_react2$3.default.Component); Link$1.default = (0, _scrollLink2$2.default)(LinkElement); var Button = {}; Object.defineProperty(Button, "__esModule", { value: !0 }); var _createClass$3 = function () { function _(j, $) { for (var _e = 0; _e < $.length; _e++) { var et = $[_e]; et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(j, et.key, et) } } return function (j, $, _e) { return $ && _(j.prototype, $), _e && _(j, _e), j } }(), _react$2 = reactExports, _react2$2 = _interopRequireDefault$3(_react$2), _scrollLink$1 = scrollLink, _scrollLink2$1 = _interopRequireDefault$3(_scrollLink$1); function _interopRequireDefault$3(_) { return _ && _.__esModule ? _ : { default: _ } } function _classCallCheck$3(_, j) { if (!(_ instanceof j)) throw new TypeError("Cannot call a class as a function") } function _possibleConstructorReturn$3(_, j) { if (!_) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j && (typeof j == "object" || typeof j == "function") ? j : _ } function _inherits$3(_, j) { if (typeof j != "function" && j !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof j); _.prototype = Object.create(j && j.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(_, j) : _.__proto__ = j) } var ButtonElement = function (_) { _inherits$3(j, _); function j() { return _classCallCheck$3(this, j), _possibleConstructorReturn$3(this, (j.__proto__ || Object.getPrototypeOf(j)).apply(this, arguments)) } return _createClass$3(j, [{ key: "render", value: function () { return _react2$2.default.createElement("button", this.props, this.props.children) } }]), j }(_react2$2.default.Component); Button.default = (0, _scrollLink2$1.default)(ButtonElement); var Element$1 = {}, scrollElement = {}; Object.defineProperty(scrollElement, "__esModule", { value: !0 }); var _extends$2 = Object.assign || function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _createClass$2 = function () { function _(j, $) { for (var _e = 0; _e < $.length; _e++) { var et = $[_e]; et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(j, et.key, et) } } return function (j, $, _e) { return $ && _(j.prototype, $), _e && _(j, _e), j } }(), _react$1 = reactExports, _react2$1 = _interopRequireDefault$2(_react$1), _reactDom = reactDomExports; _interopRequireDefault$2(_reactDom); var _scroller$1 = scroller, _scroller2$1 = _interopRequireDefault$2(_scroller$1), _propTypes$1 = propTypesExports, _propTypes2$1 = _interopRequireDefault$2(_propTypes$1); function _interopRequireDefault$2(_) { return _ && _.__esModule ? _ : { default: _ } } function _classCallCheck$2(_, j) { if (!(_ instanceof j)) throw new TypeError("Cannot call a class as a function") } function _possibleConstructorReturn$2(_, j) { if (!_) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j && (typeof j == "object" || typeof j == "function") ? j : _ } function _inherits$2(_, j) { if (typeof j != "function" && j !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof j); _.prototype = Object.create(j && j.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(_, j) : _.__proto__ = j) } scrollElement.default = function (_) { var j = function ($) { _inherits$2(_e, $); function _e(et) { _classCallCheck$2(this, _e); var tt = _possibleConstructorReturn$2(this, (_e.__proto__ || Object.getPrototypeOf(_e)).call(this, et)); return tt.childBindings = { domNode: null }, tt } return _createClass$2(_e, [{ key: "componentDidMount", value: function () { if (typeof window > "u") return !1; this.registerElems(this.props.name) } }, { key: "componentDidUpdate", value: function (tt) { this.props.name !== tt.name && this.registerElems(this.props.name) } }, { key: "componentWillUnmount", value: function () { if (typeof window > "u") return !1; _scroller2$1.default.unregister(this.props.name) } }, { key: "registerElems", value: function (tt) { _scroller2$1.default.register(tt, this.childBindings.domNode) } }, { key: "render", value: function () { return _react2$1.default.createElement(_, _extends$2({}, this.props, { parentBindings: this.childBindings })) } }]), _e }(_react2$1.default.Component); return j.propTypes = { name: _propTypes2$1.default.string, id: _propTypes2$1.default.string }, j }; Object.defineProperty(Element$1, "__esModule", { value: !0 }); var _extends$1 = Object.assign || function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _createClass$1 = function () { function _(j, $) { for (var _e = 0; _e < $.length; _e++) { var et = $[_e]; et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(j, et.key, et) } } return function (j, $, _e) { return $ && _(j.prototype, $), _e && _(j, _e), j } }(), _react = reactExports, _react2 = _interopRequireDefault$1(_react), _scrollElement$1 = scrollElement, _scrollElement2$1 = _interopRequireDefault$1(_scrollElement$1), _propTypes = propTypesExports, _propTypes2 = _interopRequireDefault$1(_propTypes); function _interopRequireDefault$1(_) { return _ && _.__esModule ? _ : { default: _ } } function _classCallCheck$1(_, j) { if (!(_ instanceof j)) throw new TypeError("Cannot call a class as a function") } function _possibleConstructorReturn$1(_, j) { if (!_) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j && (typeof j == "object" || typeof j == "function") ? j : _ } function _inherits$1(_, j) { if (typeof j != "function" && j !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof j); _.prototype = Object.create(j && j.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(_, j) : _.__proto__ = j) } var ElementWrapper = function (_) { _inherits$1(j, _); function j() { return _classCallCheck$1(this, j), _possibleConstructorReturn$1(this, (j.__proto__ || Object.getPrototypeOf(j)).apply(this, arguments)) } return _createClass$1(j, [{ key: "render", value: function () { var _e = this, et = _extends$1({}, this.props); return delete et.name, et.parentBindings && delete et.parentBindings, _react2.default.createElement("div", _extends$1({}, et, { ref: function (rt) { _e.props.parentBindings.domNode = rt } }), this.props.children) } }]), j }(_react2.default.Component); ElementWrapper.propTypes = { name: _propTypes2.default.string, id: _propTypes2.default.string }; Element$1.default = (0, _scrollElement2$1.default)(ElementWrapper); var _extends = Object.assign || function (_) { for (var j = 1; j < arguments.length; j++) { var $ = arguments[j]; for (var _e in $) Object.prototype.hasOwnProperty.call($, _e) && (_[_e] = $[_e]) } return _ }, _createClass = function () { function _(j, $) { for (var _e = 0; _e < $.length; _e++) { var et = $[_e]; et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(j, et.key, et) } } return function (j, $, _e) { return $ && _(j.prototype, $), _e && _(j, _e), j } }(); function _classCallCheck(_, j) { if (!(_ instanceof j)) throw new TypeError("Cannot call a class as a function") } function _possibleConstructorReturn(_, j) { if (!_) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j && (typeof j == "object" || typeof j == "function") ? j : _ } function _inherits(_, j) { if (typeof j != "function" && j !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof j); _.prototype = Object.create(j && j.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(_, j) : _.__proto__ = j) } var React = reactExports, scrollSpy = scrollSpy$2, defaultScroller = scroller, PropTypes = propTypesExports, scrollHash = scrollHash$2, protoTypes = { to: PropTypes.string.isRequired, containerId: PropTypes.string, container: PropTypes.object, activeClass: PropTypes.string, spy: PropTypes.bool, smooth: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]), offset: PropTypes.number, delay: PropTypes.number, isDynamic: PropTypes.bool, onClick: PropTypes.func, duration: PropTypes.oneOfType([PropTypes.number, PropTypes.func]), absolute: PropTypes.bool, onSetActive: PropTypes.func, onSetInactive: PropTypes.func, ignoreCancelEvents: PropTypes.bool, hashSpy: PropTypes.bool, spyThrottle: PropTypes.number }, Helpers = { Scroll: function _(j, $) { console.warn("Helpers.Scroll is deprecated since v1.7.0"); var _e = $ || defaultScroller, et = function (rt) { _inherits(nt, rt); function nt(it) { _classCallCheck(this, nt); var st = _possibleConstructorReturn(this, (nt.__proto__ || Object.getPrototypeOf(nt)).call(this, it)); return tt.call(st), st.state = { active: !1 }, st } return _createClass(nt, [{ key: "getScrollSpyContainer", value: function () { var st = this.props.containerId, ot = this.props.container; return st ? document.getElementById(st) : ot && ot.nodeType ? ot : document } }, { key: "componentDidMount", value: function () { if (this.props.spy || this.props.hashSpy) { var st = this.getScrollSpyContainer(); scrollSpy.isMounted(st) || scrollSpy.mount(st, this.props.spyThrottle), this.props.hashSpy && (scrollHash.isMounted() || scrollHash.mount(_e), scrollHash.mapContainer(this.props.to, st)), this.props.spy && scrollSpy.addStateHandler(this.stateHandler), scrollSpy.addSpyHandler(this.spyHandler, st), this.setState({ container: st }) } } }, { key: "componentWillUnmount", value: function () { scrollSpy.unmount(this.stateHandler, this.spyHandler) } }, { key: "render", value: function () { var st = ""; this.state && this.state.active ? st = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : st = this.props.className; var ot = _extends({}, this.props); for (var ft in protoTypes) ot.hasOwnProperty(ft) && delete ot[ft]; return ot.className = st, ot.onClick = this.handleClick, React.createElement(j, ot) } }]), nt }(React.Component), tt = function () { var nt = this; this.scrollTo = function (it, st) { _e.scrollTo(it, _extends({}, nt.state, st)) }, this.handleClick = function (it) { nt.props.onClick && nt.props.onClick(it), it.stopPropagation && it.stopPropagation(), it.preventDefault && it.preventDefault(), nt.scrollTo(nt.props.to, nt.props) }, this.stateHandler = function () { _e.getActiveLink() !== nt.props.to && (nt.state !== null && nt.state.active && nt.props.onSetInactive && nt.props.onSetInactive(), nt.setState({ active: !1 })) }, this.spyHandler = function (it) { var st = nt.getScrollSpyContainer(); if (!(scrollHash.isMounted() && !scrollHash.isInitialized())) { var ot = nt.props.to, ft = null, at = 0, dt = 0, pt = 0; if (st.getBoundingClientRect) { var ht = st.getBoundingClientRect(); pt = ht.top } if (!ft || nt.props.isDynamic) { if (ft = _e.get(ot), !ft) return; var xt = ft.getBoundingClientRect(); at = xt.top - pt + it, dt = at + xt.height } var ct = it - nt.props.offset, ut = ct >= Math.floor(at) && ct < Math.floor(dt), lt = ct < Math.floor(at) || ct >= Math.floor(dt), mt = _e.getActiveLink(); if (lt) return ot === mt && _e.setActiveLink(void 0), nt.props.hashSpy && scrollHash.getHash() === ot && scrollHash.changeHash(), nt.props.spy && nt.state.active && (nt.setState({ active: !1 }), nt.props.onSetInactive && nt.props.onSetInactive()), scrollSpy.updateStates(); if (ut && mt !== ot) return _e.setActiveLink(ot), nt.props.hashSpy && scrollHash.changeHash(ot), nt.props.spy && (nt.setState({ active: !0 }), nt.props.onSetActive && nt.props.onSetActive(ot)), scrollSpy.updateStates() } } }; return et.propTypes = protoTypes, et.defaultProps = { offset: 0 }, et }, Element: function _(j) { console.warn("Helpers.Element is deprecated since v1.7.0"); var $ = function (_e) { _inherits(et, _e); function et(tt) { _classCallCheck(this, et); var rt = _possibleConstructorReturn(this, (et.__proto__ || Object.getPrototypeOf(et)).call(this, tt)); return rt.childBindings = { domNode: null }, rt } return _createClass(et, [{ key: "componentDidMount", value: function () { if (typeof window > "u") return !1; this.registerElems(this.props.name) } }, { key: "componentDidUpdate", value: function (rt) { this.props.name !== rt.name && this.registerElems(this.props.name) } }, { key: "componentWillUnmount", value: function () { if (typeof window > "u") return !1; defaultScroller.unregister(this.props.name) } }, { key: "registerElems", value: function (rt) { defaultScroller.register(rt, this.childBindings.domNode) } }, { key: "render", value: function () { return React.createElement(j, _extends({}, this.props, { parentBindings: this.childBindings })) } }]), et }(React.Component); return $.propTypes = { name: PropTypes.string, id: PropTypes.string }, $ } }, Helpers_1 = Helpers; Object.defineProperty(modules, "__esModule", { value: !0 }); modules.Helpers = modules.ScrollElement = modules.ScrollLink = animateScroll = modules.animateScroll = modules.scrollSpy = modules.Events = modules.scroller = modules.Element = modules.Button = Link = modules.Link = void 0; var _Link = Link$1, _Link2 = _interopRequireDefault(_Link), _Button = Button, _Button2 = _interopRequireDefault(_Button), _Element = Element$1, _Element2 = _interopRequireDefault(_Element), _scroller = scroller, _scroller2 = _interopRequireDefault(_scroller), _scrollEvents = scrollEvents, _scrollEvents2 = _interopRequireDefault(_scrollEvents), _scrollSpy = scrollSpy$2, _scrollSpy2 = _interopRequireDefault(_scrollSpy), _animateScroll = animateScroll$2, _animateScroll2 = _interopRequireDefault(_animateScroll), _scrollLink = scrollLink, _scrollLink2 = _interopRequireDefault(_scrollLink), _scrollElement = scrollElement, _scrollElement2 = _interopRequireDefault(_scrollElement), _Helpers = Helpers_1, _Helpers2 = _interopRequireDefault(_Helpers); function _interopRequireDefault(_) { return _ && _.__esModule ? _ : { default: _ } } var Link = modules.Link = _Link2.default; modules.Button = _Button2.default; modules.Element = _Element2.default; modules.scroller = _scroller2.default; modules.Events = _scrollEvents2.default; modules.scrollSpy = _scrollSpy2.default; var animateScroll = modules.animateScroll = _animateScroll2.default; modules.ScrollLink = _scrollLink2.default; modules.ScrollElement = _scrollElement2.default; modules.Helpers = _Helpers2.default; modules.default = { Link: _Link2.default, Button: _Button2.default, Element: _Element2.default, scroller: _scroller2.default, Events: _scrollEvents2.default, scrollSpy: _scrollSpy2.default, animateScroll: _animateScroll2.default, ScrollLink: _scrollLink2.default, ScrollElement: _scrollElement2.default, Helpers: _Helpers2.default }; const MyNavbar$1 = () => { const [_, j] = reactExports.useState(!1), $ = { duration: 100, smooth: !0 }; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: "navbar", children: [jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: 20, left: 0, right: 0, display: "flex", justifyContent: "center" }, children: _ ? jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "40", height: "40", fill: "currentColor", className: "bi bi-x-lg", viewBox: "0 0 16 16", style: { color: "white", transition: "all 1s" }, onClick: () => j(!1), children: jsxRuntimeExports.jsx("path", { d: "M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z" }) }) : jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "50", height: "50", fill: "currentColor", className: "bi bi-list", viewBox: "0 0 16 16", style: { color: "white", transition: "all 1s" }, onClick: () => j(!0), children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5" }) }) }), jsxRuntimeExports.jsx("div", { className: "center", children: jsxRuntimeExports.jsx("div", { style: { writingMode: "vertical-lr", color: "white", fontFamily: "VT323", fontSize: 25 }, className: "nav-title", onClick: () => { animateScroll.scrollToTop($) }, children: "Andrea Scamporrino" }) }), jsxRuntimeExports.jsx("div", { style: { position: "absolute", bottom: 0, left: 0, right: 0, display: "flex", justifyContent: "center" }, children: jsxRuntimeExports.jsx(Container$1, { children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { children: jsxRuntimeExports.jsx("a", { href: "https://www.linkedin.com/in/scamporrinoandrea/", className: "clickable", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-linkedin social-icon", viewBox: "0 0 16 16", color: "white", style: { marginBottom: 20 }, children: jsxRuntimeExports.jsx("path", { d: "M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854zm4.943 12.248V6.169H2.542v7.225zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248S2.4 3.226 2.4 3.934c0 .694.521 1.248 1.327 1.248zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016l.016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225z" }) }) }) }), jsxRuntimeExports.jsx(Col$1, { children: jsxRuntimeExports.jsx("a", { href: "https://github.com/ScamporrinoAndrea", className: "clickable", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-github social-icon", viewBox: "0 0 16 16", color: "white", style: { marginBottom: 20 }, children: jsxRuntimeExports.jsx("path", { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" }) }) }) })] }) }) })] }), jsxRuntimeExports.jsx("div", { className: "menu", style: { transform: _ ? "translateX(0)" : "translateX(-110%)", left: 100 }, children: jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center text-8xl h-[100vh] space-y-10", style: { fontFamily: "VT323", paddingRight: 50 }, children: [jsxRuntimeExports.jsx("div", { className: "nav-item", onClick: () => { j(!1), animateScroll.scrollToTop($) }, children: "Home" }), jsxRuntimeExports.jsx("div", { className: "nav-item", onClick: () => { j(!1), window.scrollTo(0, (document.documentElement.scrollHeight - 927) / 100 * 8) }, children: "About" }), jsxRuntimeExports.jsx("div", { className: "nav-item", onClick: () => { j(!1), window.scrollTo(0, (document.documentElement.scrollHeight - 927) / 100 * 15) }, children: "Internship" }), jsxRuntimeExports.jsx("div", { className: "nav-item", onClick: () => { j(!1); const _e = document.getElementById("projects"); window.scrollTo(0, _e.offsetHeight + _e.offsetHeight + _e.offsetHeight) }, children: "Projects" })] }) })] }) }, Home = ({ projects: _ }) => { const j = reactExports.useRef(null); let { scrollYProgress: $ } = useScroll({ target: j }), _e = useTransform($, [0, 1], ["1%", "-77.9%"], { clamp: !1 }); return jsxRuntimeExports.jsxs("div", { className: "d-none d-lg-block", children: [jsxRuntimeExports.jsx(MyNavbar$1, {}), jsxRuntimeExports.jsx(ProgressBar, {}), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("section", { ref: j, className: "h-[400vh] bg-neutral-800", children: jsxRuntimeExports.jsx("div", { className: "sticky top-0 flex h-screen items-center overflow-hidden", children: jsxRuntimeExports.jsxs(motion.div, { style: { x: _e }, className: "flex h-screen", children: [jsxRuntimeExports.jsxs("div", { id: "home", className: "group relative w-[100vw] overflow-hidden text-center flex flex-col items-center justify-center gap-y-20 margin-navbar", children: [jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(m, { sequence: ["Andrea Scamporrino", 2e3], cursor: !0, repeat: 1 / 0, className: "type-animation-green" }) }), jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(m, { sequence: [1200, "Portfolio", 2e3, "Software Engineer", 2e3, "Nerd", 800], cursor: !0, repeat: 1 / 0, className: "type-animation-white" }) }), jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(Lottie, { animationData: scroll2, style: { height: 40, color: "white" } }) })] }), jsxRuntimeExports.jsx("div", { id: "about", className: "group relative w-[100vw] overflow-hidden flex flex-col items-center justify-center gap-y-20", children: jsxRuntimeExports.jsx(About, {}) }), jsxRuntimeExports.jsx("div", { id: "toyota-exp", className: " relative w-[150vw] overflow-hidden flex flex-col justify-center", children: jsxRuntimeExports.jsx(ToyotaExperience, {}) }), jsxRuntimeExports.jsx(Projects, {})] }) }) }), jsxRuntimeExports.jsx(ProjectList, { projects: _ })] })] }) }, MyNavbar = () => { const [_, j] = reactExports.useState(!1), $ = { duration: 100, smooth: !0 }; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: "navbar-mobile", children: [jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: 0, left: 0 }, children: _ ? jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "40", height: "40", fill: "currentColor", className: "bi bi-x-lg", viewBox: "0 0 16 16", style: { color: "white", transition: "all 1s" }, onClick: () => j(!1), children: jsxRuntimeExports.jsx("path", { d: "M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z" }) }) : jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "50", height: "50", fill: "currentColor", className: "bi bi-list", viewBox: "0 0 16 16", style: { color: "white", transition: "all 1s" }, onClick: () => j(!0), children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5" }) }) }), jsxRuntimeExports.jsx("div", { style: { textAlign: "center", paddingTop: 10, zIndex: 310 }, children: jsxRuntimeExports.jsx("div", { style: { color: "white", fontFamily: "VT323", fontSize: 20 }, onClick: () => { animateScroll.scrollToTop($) }, children: "Andrea Scamporrino" }) }), jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: 12.5, right: 0 }, children: jsxRuntimeExports.jsx(Container$1, { children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { children: jsxRuntimeExports.jsx("a", { href: "https://www.linkedin.com/in/scamporrinoandrea/", className: "clickable", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-linkedin social-icon", viewBox: "0 0 16 16", color: "white", style: { marginBottom: 20 }, children: jsxRuntimeExports.jsx("path", { d: "M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854zm4.943 12.248V6.169H2.542v7.225zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248S2.4 3.226 2.4 3.934c0 .694.521 1.248 1.327 1.248zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016l.016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225z" }) }) }) }), jsxRuntimeExports.jsx(Col$1, { children: jsxRuntimeExports.jsx("a", { href: "https://github.com/ScamporrinoAndrea", className: "clickable", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-github social-icon", viewBox: "0 0 16 16", color: "white", style: { marginBottom: 20 }, children: jsxRuntimeExports.jsx("path", { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" }) }) }) })] }) }) })] }), jsxRuntimeExports.jsx("div", { className: "menu", style: { transform: _ ? "translateY(0)" : "translateY(-100%)" }, children: jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center text-5xl h-[100vh] space-y-10", style: { fontFamily: "VT323" }, children: [jsxRuntimeExports.jsx("div", { className: "nav-item", onClick: () => { j(!1), animateScroll.scrollToTop($) }, children: "Home" }), jsxRuntimeExports.jsx(Link, { to: "aboutMobile", className: "nav-item", style: { textDecoration: "none", color: "white" }, onClick: () => { j(!1) }, children: "About" }), jsxRuntimeExports.jsx(Link, { to: "ExperienceMobile", className: "nav-item", style: { textDecoration: "none", color: "white" }, onClick: () => { j(!1) }, children: "Internship" }), jsxRuntimeExports.jsx(Link, { to: "projectsMobile", className: "nav-item", style: { textDecoration: "none", color: "white" }, onClick: () => { j(!1) }, children: "Projects" })] }) })] }) }, HomeMobile = () => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsxs("section", { className: "h-[100vh]", children: [jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", height: "100%" }, children: [jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(m, { sequence: ["Andrea Scamporrino", 2e3], cursor: !0, repeat: 1 / 0, className: "type-animation-green-mobile" }) }), jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(m, { sequence: [1200, "Portfolio", 2e3, "Software Engineer", 2e3, "Nerd", 800], cursor: !0, repeat: 1 / 0, className: "type-animation-white-mobile" }) })] }), jsxRuntimeExports.jsx("div", { style: { position: "absolute", bottom: 40, left: "50%", transform: "translateX(-50%)" }, children: jsxRuntimeExports.jsx(Lottie, { animationData: scroll, style: { height: 80, color: "white" } }) })] }) }), AboutMobile = () => jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("div", { id: "aboutMobile", children: jsxRuntimeExports.jsx("div", { style: { color: "transparent" }, children: "invisible" }) }), jsxRuntimeExports.jsx("div", { style: { marginTop: 10 }, children: jsxRuntimeExports.jsx("div", { style: { color: "transparent" }, children: "invisible" }) }), jsxRuntimeExports.jsxs("div", { style: { fontFamily: "VT323", color: "white", overflow: "hidden" }, children: [jsxRuntimeExports.jsx("div", { style: { textAlign: "left", fontSize: 40, marginLeft: 20 }, children: "About me" }), jsxRuntimeExports.jsxs(Bounce, { style: { padding: 20 }, children: [jsxRuntimeExports.jsx("div", { className: "text-center", children: jsxRuntimeExports.jsx(Image$2, { src: profile, fluid: !0, style: { borderRadius: 20 } }) }), jsxRuntimeExports.jsxs("div", { children: ["I'm a Software Engineer with a passion for ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "web and mobile development." }), jsxRuntimeExports.jsx("br", {}), "I have experience in both ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0 255,10)" }, children: "frontend and backend" }), " development, and I'm always looking for new challenges.", jsxRuntimeExports.jsx("br", {}), "I'm currently pursuing my MSc in Software Engineering at ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0 255,10)" }, children: "Polytechnic University of Turin" }), ", Italy."] })] }), jsxRuntimeExports.jsx(Bounce, { children: jsxRuntimeExports.jsx(Container$1, { children: jsxRuntimeExports.jsxs(Row$1, { style: { fontSize: 18, textAlign: "center" }, children: [jsxRuntimeExports.jsx(Col$1, { xs: 6, children: jsxRuntimeExports.jsx("a", { href: "https://scamporrinoandrea.github.io/Resume/Resume_Andrea_Scamporrino.pdf", target: "_blank", rel: "noopener noreferrer", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 10, borderRadius: 10, fontSize: 20 }, children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, className: "d-flex align-items-center justify-content-center", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "30", height: "30", fill: "currentColor", className: "bi bi-file-earmark-person-fill", viewBox: "0 0 16 16", children: jsxRuntimeExports.jsx("path", { d: "M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 .293A1 1 0 0 0 9.293 0M9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1M11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0m2 5.755V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-.245S4 12 8 12s5 1.755 5 1.755" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, className: "d-flex align-items-center justify-content-center", children: "View my resume" })] }) }) }) }), jsxRuntimeExports.jsx(Col$1, { xs: 6, children: jsxRuntimeExports.jsx("a", { href: "mailto:scamporrino.andrea@gmail.com", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 10, borderRadius: 10, fontSize: 20 }, children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, className: "d-flex align-items-center justify-content-center", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "30", height: "30", fill: "currentColor", className: "bi bi-envelope-open", viewBox: "0 0 16 16", children: jsxRuntimeExports.jsx("path", { d: "M8.47 1.318a1 1 0 0 0-.94 0l-6 3.2A1 1 0 0 0 1 5.4v.817l5.75 3.45L8 8.917l1.25.75L15 6.217V5.4a1 1 0 0 0-.53-.882zM15 7.383l-4.778 2.867L15 13.117zm-.035 6.88L8 10.082l-6.965 4.18A1 1 0 0 0 2 15h12a1 1 0 0 0 .965-.738ZM1 13.116l4.778-2.867L1 7.383v5.734ZM7.059.435a2 2 0 0 1 1.882 0l6 3.2A2 2 0 0 1 16 5.4V14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5.4a2 2 0 0 1 1.059-1.765z" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, md: 12, className: "d-flex align-items-center justify-content-center", children: "Contact me" })] }) }) }) })] }) }) })] })] }), CardProjectMobile = _ => jsxRuntimeExports.jsxs("div", { style: { height: "100%", fontFamily: "VT323" }, className: "d-flex flex-column", children: [jsxRuntimeExports.jsx(Image$2, { src: _.image, fluid: !0, style: { borderRadius: 10, maxHeight: "50vh", display: "block", marginLeft: "auto", marginRight: "auto" } }), jsxRuntimeExports.jsxs("div", { style: { padding: 10, height: "100%" }, className: "d-flex flex-column", children: [jsxRuntimeExports.jsxs("div", { style: { fontFamily: "VT323", fontSize: 30 }, children: [jsxRuntimeExports.jsx("div", { children: _.title }), jsxRuntimeExports.jsx("div", { style: { display: "flex", justifyContent: "start" }, children: _.icon })] }), jsxRuntimeExports.jsx("div", { style: { fontFamily: "VT323", fontSize: 15 }, children: _.description }), jsxRuntimeExports.jsx("div", { style: { width: "100%", textAlign: "center", marginTop: 10 }, children: jsxRuntimeExports.jsx("a", { href: _.github, target: "_blank", rel: "noopener noreferrer", className: "text-decoration-none", style: { color: "white" }, children: _.title === "Gino Panino Website" ? jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", children: jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-globe", viewBox: "0 0 16 16", style: { marginRight: 10 }, children: jsxRuntimeExports.jsx("path", { d: "M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m7.5-6.923c-.67.204-1.335.82-1.887 1.855A8 8 0 0 0 5.145 4H7.5zM4.09 4a9.3 9.3 0 0 1 .64-1.539 7 7 0 0 1 .597-.933A7.03 7.03 0 0 0 2.255 4zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a7 7 0 0 0-.656 2.5zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5zM8.5 5v2.5h2.99a12.5 12.5 0 0 0-.337-2.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5zM5.145 12q.208.58.468 1.068c.552 1.035 1.218 1.65 1.887 1.855V12zm.182 2.472a7 7 0 0 1-.597-.933A9.3 9.3 0 0 1 4.09 12H2.255a7 7 0 0 0 3.072 2.472M3.82 11a13.7 13.7 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5zm6.853 3.472A7 7 0 0 0 13.745 12H11.91a9.3 9.3 0 0 1-.64 1.539 7 7 0 0 1-.597.933M8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855q.26-.487.468-1.068zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.7 13.7 0 0 1-.312 2.5m2.802-3.5a7 7 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7 7 0 0 0-3.072-2.472c.218.284.418.598.597.933M10.855 4a8 8 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4z" }) }), "Check the website"] }) }) : jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", children: jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "25", height: "25", fill: "currentColor", className: "bi bi-github", viewBox: "0 0 16 16", style: { marginRight: 10 }, children: jsxRuntimeExports.jsx("path", { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" }) }), "View on GitHub"] }) }) }) })] })] }), ProjectsMobile = ({ projects: _ }) => { const j = reactExports.useRef([]); j.current = _.map((et, tt) => j.current[tt] || React$1.createRef()); const [$, _e] = reactExports.useState(Array(_.length - 1).fill(!1)); return reactExports.useEffect(() => { const et = new IntersectionObserver(([tt]) => { const rt = j.current.findIndex(nt => nt.current === tt.target); rt > 0 && _e(nt => { const it = [...nt]; return it[rt - 1] = tt.isIntersecting, it }) }, { threshold: .1 }); return j.current.forEach(tt => { tt.current && et.observe(tt.current) }), () => { j.current.forEach(tt => { tt.current && et.unobserve(tt.current) }) } }, []), jsxRuntimeExports.jsxs("div", { id: "projectsMobile", children: [jsxRuntimeExports.jsx("div", { style: { fontSize: 40, paddingLeft: 20, marginTop: 60, color: "white", fontFamily: "VT323", position: "sticky", top: "50px" }, children: "Projects" }), jsxRuntimeExports.jsx("div", { className: "group relative", style: { color: "white", fontFamily: "VT323" }, children: _.map((et, tt) => jsxRuntimeExports.jsx("div", { ref: j.current[tt], style: { height: "95vh", position: "sticky", top: "100px", backgroundColor: "rgba(38,38,38)", borderRadius: 20, padding: 20, filter: $[tt] ? "blur(5px)" : "blur(0px)", transform: $[tt] ? "scale(0.8)" : "scale(1)", transition: "filter 0.7s, transform 0.7s" }, children: jsxRuntimeExports.jsx(CardProjectMobile, { index: tt, title: et.title, description: et.description, image: et.image, icon: et.icon, github: et.github }) }, tt)) }), jsxRuntimeExports.jsx("div", { style: { overflow: "hidden" }, children: jsxRuntimeExports.jsx(Bounce, { style: { marginBottom: 50, fontFamily: "VT323" }, children: jsxRuntimeExports.jsx(Container$1, { children: jsxRuntimeExports.jsxs(Row$1, { style: { fontSize: 18, textAlign: "center" }, children: [jsxRuntimeExports.jsx(Col$1, { xs: 6, children: jsxRuntimeExports.jsx("a", { href: "https://github.com/ScamporrinoAndrea", target: "_blank", rel: "noopener noreferrer", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 10, borderRadius: 10, fontSize: 20 }, children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, className: "d-flex align-items-center justify-content-center", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "30", height: "30", fill: "currentColor", className: "bi bi-github", viewBox: "0 0 16 16", style: { marginRight: 10 }, children: jsxRuntimeExports.jsx("path", { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, className: "d-flex align-items-center justify-content-center", children: "More projects" })] }) }) }) }), jsxRuntimeExports.jsx(Col$1, { xs: 6, children: jsxRuntimeExports.jsx("a", { href: "mailto:scamporrino.andrea@gmail.com", className: "text-decoration-none", style: { color: "white" }, children: jsxRuntimeExports.jsx(Button$2, { variant: "outline-light", className: "github-icon clickable", style: { padding: 10, borderRadius: 10, fontSize: 20 }, children: jsxRuntimeExports.jsxs(Row$1, { children: [jsxRuntimeExports.jsx(Col$1, { lg: 4, className: "d-flex align-items-center justify-content-center", children: jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "30", height: "30", fill: "currentColor", className: "bi bi-envelope-open", viewBox: "0 0 16 16", children: jsxRuntimeExports.jsx("path", { d: "M8.47 1.318a1 1 0 0 0-.94 0l-6 3.2A1 1 0 0 0 1 5.4v.817l5.75 3.45L8 8.917l1.25.75L15 6.217V5.4a1 1 0 0 0-.53-.882zM15 7.383l-4.778 2.867L15 13.117zm-.035 6.88L8 10.082l-6.965 4.18A1 1 0 0 0 2 15h12a1 1 0 0 0 .965-.738ZM1 13.116l4.778-2.867L1 7.383v5.734ZM7.059.435a2 2 0 0 1 1.882 0l6 3.2A2 2 0 0 1 16 5.4V14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5.4a2 2 0 0 1 1.059-1.765z" }) }) }), jsxRuntimeExports.jsx(Col$1, { lg: 8, md: 12, className: "d-flex align-items-center justify-content-center", children: "Contact me" })] }) }) }) })] }) }) }) })] }) }, ProgressBarMobile = () => { const [_, j] = reactExports.useState(0); return reactExports.useEffect(() => { const $ = () => { const _e = window.innerHeight, et = document.documentElement.scrollHeight, rt = window.scrollY / (et - _e) * 100; j(rt) }; return window.addEventListener("scroll", $), () => { window.removeEventListener("scroll", $) } }, []), jsxRuntimeExports.jsx("div", { style: { position: "fixed", top: 50, left: 0, height: 5, width: "100vw", backgroundColor: "transparent", zIndex: 100 }, children: jsxRuntimeExports.jsx("div", { style: { height: 5, width: `${_}%`, backgroundColor: "rgb(0, 255, 10)" } }) }) }, ToyotaExperienceMobile = () => jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("div", { id: "ExperienceMobile", children: jsxRuntimeExports.jsx("div", { style: { color: "transparent" }, children: "invisible" }) }), jsxRuntimeExports.jsx("div", { style: { marginTop: 10 }, children: jsxRuntimeExports.jsx("div", { style: { color: "transparent" }, children: "invisible" }) }), jsxRuntimeExports.jsxs("div", { style: { fontFamily: "VT323", color: "white", overflow: "hidden", position: "sticky", top: "50px" }, children: [jsxRuntimeExports.jsxs("div", { style: { textAlign: "left", fontSize: 40, marginLeft: 20, display: "flex", alignItems: "center", gap: "10px" }, children: [jsxRuntimeExports.jsx("span", { children: "Toyota Internship" }), jsxRuntimeExports.jsx(SiToyota, {})] }), jsxRuntimeExports.jsxs(Bounce, { style: { padding: 20 }, children: [jsxRuntimeExports.jsx("div", { className: "text-center", children: jsxRuntimeExports.jsxs("video", { autoPlay: !0, loop: !0, muted: !0, playsInline: !0, style: { borderRadius: 20 }, children: [jsxRuntimeExports.jsx("source", { src: toyotaVideo, type: "video/mp4" }), "Your browser does not support the video tag."] }) }), jsxRuntimeExports.jsxs("div", { children: ["I completed a ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "six-month internship" }), " at Toyota Motor Europe as a Software Engineer in Belgium. ", jsxRuntimeExports.jsx("br", {}), "I developed a custom internal", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: " application" }), " from scratch using Microsoft Power Platform.", jsxRuntimeExports.jsx("br", {}), "The application was designed to manage vehicle testing, optimizing workflows and improving data management efficiency across teams."] }), jsxRuntimeExports.jsxs("div", { children: ["I designed the system architecture and UI/UX in Figma, implementing both the ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "frontend and backend" }), " while integrating SharePoint, PowerApps, and Power Automate. ", jsxRuntimeExports.jsx("br", {}), "Through iterative development and ", jsxRuntimeExports.jsx("span", { style: { color: "rgb(0, 255,10)" }, children: "collaboration with stakeholders" }), ", I deployed a fully operational solution that reduces processing time by an estimated 199 hours per year, delivering a business value of €22,000 annually."] })] })] })] }), Mobile = ({ projects: _ }) => jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(MyNavbar, {}), jsxRuntimeExports.jsx(ProgressBarMobile, {}), jsxRuntimeExports.jsxs("div", { className: "bg-neutral-800", children: [jsxRuntimeExports.jsx(HomeMobile, {}), jsxRuntimeExports.jsx(AboutMobile, {}), jsxRuntimeExports.jsx(ToyotaExperienceMobile, {}), jsxRuntimeExports.jsx(ProjectsMobile, { projects: _ })] })] }), project1Image = "./assets/project1-BY0AwjJ7.jpg", RustUtility = "./assets/rust-utility-CaVENE2w.jpg", Deltaplan = "./assets/deltaPlan-DIqjT6rR.jpg", tamagotchi = "./assets/tamagotchi-CCspQZqS.jpg", teamworkApp = "./assets/teamworkApp-DgChJlJV.png", jobPlacement = "./assets/jobPlacement-IZ_IPeIb.png", ginoPanino = "./assets/ginoPanino-BdVn5fT9.png"; function FaAndroid(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M420.55,301.93a24,24,0,1,1,24-24,24,24,0,0,1-24,24m-265.1,0a24,24,0,1,1,24-24,24,24,0,0,1-24,24m273.7-144.48,47.94-83a10,10,0,1,0-17.27-10h0l-48.54,84.07a301.25,301.25,0,0,0-246.56,0L116.18,64.45a10,10,0,1,0-17.27,10h0l47.94,83C64.53,202.22,8.24,285.55,0,384H576c-8.24-98.45-64.54-181.78-146.85-226.55" }, child: [] }] })(_) } function FaBootstrap(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M333.5,201.4c0-22.1-15.6-34.3-43-34.3h-50.4v71.2h42.5C315.4,238.2,333.5,225,333.5,201.4z M517,188.6 c-9.5-30.9-10.9-68.8-9.8-98.1c1.1-30.5-22.7-58.5-54.7-58.5H123.7c-32.1,0-55.8,28.1-54.7,58.5c1,29.3-0.3,67.2-9.8,98.1 c-9.6,31-25.7,50.6-52.2,53.1v28.5c26.4,2.5,42.6,22.1,52.2,53.1c9.5,30.9,10.9,68.8,9.8,98.1c-1.1,30.5,22.7,58.5,54.7,58.5h328.7 c32.1,0,55.8-28.1,54.7-58.5c-1-29.3,0.3-67.2,9.8-98.1c9.6-31,25.7-50.6,52.1-53.1v-28.5C542.7,239.2,526.5,219.6,517,188.6z M300.2,375.1h-97.9V136.8h97.4c43.3,0,71.7,23.4,71.7,59.4c0,25.3-19.1,47.9-43.5,51.8v1.3c33.2,3.6,55.5,26.6,55.5,58.3 C383.4,349.7,352.1,375.1,300.2,375.1z M290.2,266.4h-50.1v78.4h52.3c34.2,0,52.3-13.7,52.3-39.5 C344.7,279.6,326.1,266.4,290.2,266.4z" }, child: [] }] })(_) } function FaDocker(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M349.9 236.3h-66.1v-59.4h66.1v59.4zm0-204.3h-66.1v60.7h66.1V32zm78.2 144.8H362v59.4h66.1v-59.4zm-156.3-72.1h-66.1v60.1h66.1v-60.1zm78.1 0h-66.1v60.1h66.1v-60.1zm276.8 100c-14.4-9.7-47.6-13.2-73.1-8.4-3.3-24-16.7-44.9-41.1-63.7l-14-9.3-9.3 14c-18.4 27.8-23.4 73.6-3.7 103.8-8.7 4.7-25.8 11.1-48.4 10.7H2.4c-8.7 50.8 5.8 116.8 44 162.1 37.1 43.9 92.7 66.2 165.4 66.2 157.4 0 273.9-72.5 328.4-204.2 21.4.4 67.6.1 91.3-45.2 1.5-2.5 6.6-13.2 8.5-17.1l-13.3-8.9zm-511.1-27.9h-66v59.4h66.1v-59.4zm78.1 0h-66.1v59.4h66.1v-59.4zm78.1 0h-66.1v59.4h66.1v-59.4zm-78.1-72.1h-66.1v60.1h66.1v-60.1z" }, child: [] }] })(_) } function FaFigma(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M14 95.7924C14 42.8877 56.8878 0 109.793 0H274.161C327.066 0 369.954 42.8877 369.954 95.7924C369.954 129.292 352.758 158.776 326.711 175.897C352.758 193.019 369.954 222.502 369.954 256.002C369.954 308.907 327.066 351.795 274.161 351.795H272.081C247.279 351.795 224.678 342.369 207.666 326.904V415.167C207.666 468.777 163.657 512 110.309 512C57.5361 512 14 469.243 14 416.207C14 382.709 31.1945 353.227 57.2392 336.105C31.1945 318.983 14 289.5 14 256.002C14 222.502 31.196 193.019 57.2425 175.897C31.196 158.776 14 129.292 14 95.7924ZM176.288 191.587H109.793C74.2172 191.587 45.3778 220.427 45.3778 256.002C45.3778 291.44 73.9948 320.194 109.381 320.416C109.518 320.415 109.655 320.415 109.793 320.415H176.288V191.587ZM207.666 256.002C207.666 291.577 236.505 320.417 272.081 320.417H274.161C309.737 320.417 338.576 291.577 338.576 256.002C338.576 220.427 309.737 191.587 274.161 191.587H272.081C236.505 191.587 207.666 220.427 207.666 256.002ZM109.793 351.795C109.655 351.795 109.518 351.794 109.381 351.794C73.9948 352.015 45.3778 380.769 45.3778 416.207C45.3778 451.652 74.6025 480.622 110.309 480.622C146.591 480.622 176.288 451.186 176.288 415.167V351.795H109.793ZM109.793 31.3778C74.2172 31.3778 45.3778 60.2173 45.3778 95.7924C45.3778 131.368 74.2172 160.207 109.793 160.207H176.288V31.3778H109.793ZM207.666 160.207H274.161C309.737 160.207 338.576 131.368 338.576 95.7924C338.576 60.2173 309.737 31.3778 274.161 31.3778H207.666V160.207Z" }, child: [] }] })(_) } function FaNode(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M316.3 452c-2.1 0-4.2-.6-6.1-1.6L291 439c-2.9-1.6-1.5-2.2-.5-2.5 3.8-1.3 4.6-1.6 8.7-4 .4-.2 1-.1 1.4.1l14.8 8.8c.5.3 1.3.3 1.8 0L375 408c.5-.3.9-.9.9-1.6v-66.7c0-.7-.3-1.3-.9-1.6l-57.8-33.3c-.5-.3-1.2-.3-1.8 0l-57.8 33.3c-.6.3-.9 1-.9 1.6v66.7c0 .6.4 1.2.9 1.5l15.8 9.1c8.6 4.3 13.9-.8 13.9-5.8v-65.9c0-.9.7-1.7 1.7-1.7h7.3c.9 0 1.7.7 1.7 1.7v65.9c0 11.5-6.2 18-17.1 18-3.3 0-6 0-13.3-3.6l-15.2-8.7c-3.7-2.2-6.1-6.2-6.1-10.5v-66.7c0-4.3 2.3-8.4 6.1-10.5l57.8-33.4c3.7-2.1 8.5-2.1 12.1 0l57.8 33.4c3.7 2.2 6.1 6.2 6.1 10.5v66.7c0 4.3-2.3 8.4-6.1 10.5l-57.8 33.4c-1.7 1.1-3.8 1.7-6 1.7zm46.7-65.8c0-12.5-8.4-15.8-26.2-18.2-18-2.4-19.8-3.6-19.8-7.8 0-3.5 1.5-8.1 14.8-8.1 11.9 0 16.3 2.6 18.1 10.6.2.8.8 1.3 1.6 1.3h7.5c.5 0 .9-.2 1.2-.5.3-.4.5-.8.4-1.3-1.2-13.8-10.3-20.2-28.8-20.2-16.5 0-26.3 7-26.3 18.6 0 12.7 9.8 16.1 25.6 17.7 18.9 1.9 20.4 4.6 20.4 8.3 0 6.5-5.2 9.2-17.4 9.2-15.3 0-18.7-3.8-19.8-11.4-.1-.8-.8-1.4-1.7-1.4h-7.5c-.9 0-1.7.7-1.7 1.7 0 9.7 5.3 21.3 30.6 21.3 18.5 0 29-7.2 29-19.8zm54.5-50.1c0 6.1-5 11.1-11.1 11.1s-11.1-5-11.1-11.1c0-6.3 5.2-11.1 11.1-11.1 6-.1 11.1 4.8 11.1 11.1zm-1.8 0c0-5.2-4.2-9.3-9.4-9.3-5.1 0-9.3 4.1-9.3 9.3 0 5.2 4.2 9.4 9.3 9.4 5.2-.1 9.4-4.3 9.4-9.4zm-4.5 6.2h-2.6c-.1-.6-.5-3.8-.5-3.9-.2-.7-.4-1.1-1.3-1.1h-2.2v5h-2.4v-12.5h4.3c1.5 0 4.4 0 4.4 3.3 0 2.3-1.5 2.8-2.4 3.1 1.7.1 1.8 1.2 2.1 2.8.1 1 .3 2.7.6 3.3zm-2.8-8.8c0-1.7-1.2-1.7-1.8-1.7h-2v3.5h1.9c1.6 0 1.9-1.1 1.9-1.8zM137.3 191c0-2.7-1.4-5.1-3.7-6.4l-61.3-35.3c-1-.6-2.2-.9-3.4-1h-.6c-1.2 0-2.3.4-3.4 1L3.7 184.6C1.4 185.9 0 188.4 0 191l.1 95c0 1.3.7 2.5 1.8 3.2 1.1.7 2.5.7 3.7 0L42 268.3c2.3-1.4 3.7-3.8 3.7-6.4v-44.4c0-2.6 1.4-5.1 3.7-6.4l15.5-8.9c1.2-.7 2.4-1 3.7-1 1.3 0 2.6.3 3.7 1l15.5 8.9c2.3 1.3 3.7 3.8 3.7 6.4v44.4c0 2.6 1.4 5.1 3.7 6.4l36.4 20.9c1.1.7 2.6.7 3.7 0 1.1-.6 1.8-1.9 1.8-3.2l.2-95zM472.5 87.3v176.4c0 2.6-1.4 5.1-3.7 6.4l-61.3 35.4c-2.3 1.3-5.1 1.3-7.4 0l-61.3-35.4c-2.3-1.3-3.7-3.8-3.7-6.4v-70.8c0-2.6 1.4-5.1 3.7-6.4l61.3-35.4c2.3-1.3 5.1-1.3 7.4 0l15.3 8.8c1.7 1 3.9-.3 3.9-2.2v-94c0-2.8 3-4.6 5.5-3.2l36.5 20.4c2.3 1.2 3.8 3.7 3.8 6.4zm-46 128.9c0-.7-.4-1.3-.9-1.6l-21-12.2c-.6-.3-1.3-.3-1.9 0l-21 12.2c-.6.3-.9.9-.9 1.6v24.3c0 .7.4 1.3.9 1.6l21 12.1c.6.3 1.3.3 1.8 0l21-12.1c.6-.3.9-.9.9-1.6v-24.3zm209.8-.7c2.3-1.3 3.7-3.8 3.7-6.4V192c0-2.6-1.4-5.1-3.7-6.4l-60.9-35.4c-2.3-1.3-5.1-1.3-7.4 0l-61.3 35.4c-2.3 1.3-3.7 3.8-3.7 6.4v70.8c0 2.7 1.4 5.1 3.7 6.4l60.9 34.7c2.2 1.3 5 1.3 7.3 0l36.8-20.5c2.5-1.4 2.5-5 0-6.4L550 241.6c-1.2-.7-1.9-1.9-1.9-3.2v-22.2c0-1.3.7-2.5 1.9-3.2l19.2-11.1c1.1-.7 2.6-.7 3.7 0l19.2 11.1c1.1.7 1.9 1.9 1.9 3.2v17.4c0 2.8 3.1 4.6 5.6 3.2l36.7-21.3zM559 219c-.4.3-.7.7-.7 1.2v13.6c0 .5.3 1 .7 1.2l11.8 6.8c.4.3 1 .3 1.4 0L584 235c.4-.3.7-.7.7-1.2v-13.6c0-.5-.3-1-.7-1.2l-11.8-6.8c-.4-.3-1-.3-1.4 0L559 219zm-254.2 43.5v-70.4c0-2.6-1.6-5.1-3.9-6.4l-61.1-35.2c-2.1-1.2-5-1.4-7.4 0l-61.1 35.2c-2.3 1.3-3.9 3.7-3.9 6.4v70.4c0 2.8 1.9 5.2 4 6.4l61.2 35.2c2.4 1.4 5.2 1.3 7.4 0l61-35.2c1.8-1 3.1-2.7 3.6-4.7.1-.5.2-1.1.2-1.7zm-74.3-124.9l-.8.5h1.1l-.3-.5zm76.2 130.2l-.4-.7v.9l.4-.2z" }, child: [] }] })(_) } function FaReact(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M418.2 177.2c-5.4-1.8-10.8-3.5-16.2-5.1.9-3.7 1.7-7.4 2.5-11.1 12.3-59.6 4.2-107.5-23.1-123.3-26.3-15.1-69.2.6-112.6 38.4-4.3 3.7-8.5 7.6-12.5 11.5-2.7-2.6-5.5-5.2-8.3-7.7-45.5-40.4-91.1-57.4-118.4-41.5-26.2 15.2-34 60.3-23 116.7 1.1 5.6 2.3 11.1 3.7 16.7-6.4 1.8-12.7 3.8-18.6 5.9C38.3 196.2 0 225.4 0 255.6c0 31.2 40.8 62.5 96.3 81.5 4.5 1.5 9 3 13.6 4.3-1.5 6-2.8 11.9-4 18-10.5 55.5-2.3 99.5 23.9 114.6 27 15.6 72.4-.4 116.6-39.1 3.5-3.1 7-6.3 10.5-9.7 4.4 4.3 9 8.4 13.6 12.4 42.8 36.8 85.1 51.7 111.2 36.6 27-15.6 35.8-62.9 24.4-120.5-.9-4.4-1.9-8.9-3-13.5 3.2-.9 6.3-1.9 9.4-2.9 57.7-19.1 99.5-50 99.5-81.7 0-30.3-39.4-59.7-93.8-78.4zM282.9 92.3c37.2-32.4 71.9-45.1 87.7-36 16.9 9.7 23.4 48.9 12.8 100.4-.7 3.4-1.4 6.7-2.3 10-22.2-5-44.7-8.6-67.3-10.6-13-18.6-27.2-36.4-42.6-53.1 3.9-3.7 7.7-7.2 11.7-10.7zM167.2 307.5c5.1 8.7 10.3 17.4 15.8 25.9-15.6-1.7-31.1-4.2-46.4-7.5 4.4-14.4 9.9-29.3 16.3-44.5 4.6 8.8 9.3 17.5 14.3 26.1zm-30.3-120.3c14.4-3.2 29.7-5.8 45.6-7.8-5.3 8.3-10.5 16.8-15.4 25.4-4.9 8.5-9.7 17.2-14.2 26-6.3-14.9-11.6-29.5-16-43.6zm27.4 68.9c6.6-13.8 13.8-27.3 21.4-40.6s15.8-26.2 24.4-38.9c15-1.1 30.3-1.7 45.9-1.7s31 .6 45.9 1.7c8.5 12.6 16.6 25.5 24.3 38.7s14.9 26.7 21.7 40.4c-6.7 13.8-13.9 27.4-21.6 40.8-7.6 13.3-15.7 26.2-24.2 39-14.9 1.1-30.4 1.6-46.1 1.6s-30.9-.5-45.6-1.4c-8.7-12.7-16.9-25.7-24.6-39s-14.8-26.8-21.5-40.6zm180.6 51.2c5.1-8.8 9.9-17.7 14.6-26.7 6.4 14.5 12 29.2 16.9 44.3-15.5 3.5-31.2 6.2-47 8 5.4-8.4 10.5-17 15.5-25.6zm14.4-76.5c-4.7-8.8-9.5-17.6-14.5-26.2-4.9-8.5-10-16.9-15.3-25.2 16.1 2 31.5 4.7 45.9 8-4.6 14.8-10 29.2-16.1 43.4zM256.2 118.3c10.5 11.4 20.4 23.4 29.6 35.8-19.8-.9-39.7-.9-59.5 0 9.8-12.9 19.9-24.9 29.9-35.8zM140.2 57c16.8-9.8 54.1 4.2 93.4 39 2.5 2.2 5 4.6 7.6 7-15.5 16.7-29.8 34.5-42.9 53.1-22.6 2-45 5.5-67.2 10.4-1.3-5.1-2.4-10.3-3.5-15.5-9.4-48.4-3.2-84.9 12.6-94zm-24.5 263.6c-4.2-1.2-8.3-2.5-12.4-3.9-21.3-6.7-45.5-17.3-63-31.2-10.1-7-16.9-17.8-18.8-29.9 0-18.3 31.6-41.7 77.2-57.6 5.7-2 11.5-3.8 17.3-5.5 6.8 21.7 15 43 24.5 63.6-9.6 20.9-17.9 42.5-24.8 64.5zm116.6 98c-16.5 15.1-35.6 27.1-56.4 35.3-11.1 5.3-23.9 5.8-35.3 1.3-15.9-9.2-22.5-44.5-13.5-92 1.1-5.6 2.3-11.2 3.7-16.7 22.4 4.8 45 8.1 67.9 9.8 13.2 18.7 27.7 36.6 43.2 53.4-3.2 3.1-6.4 6.1-9.6 8.9zm24.5-24.3c-10.2-11-20.4-23.2-30.3-36.3 9.6.4 19.5.6 29.5.6 10.3 0 20.4-.2 30.4-.7-9.2 12.7-19.1 24.8-29.6 36.4zm130.7 30c-.9 12.2-6.9 23.6-16.5 31.3-15.9 9.2-49.8-2.8-86.4-34.2-4.2-3.6-8.4-7.5-12.7-11.5 15.3-16.9 29.4-34.8 42.2-53.6 22.9-1.9 45.7-5.4 68.2-10.5 1 4.1 1.9 8.2 2.7 12.2 4.9 21.6 5.7 44.1 2.5 66.3zm18.2-107.5c-2.8.9-5.6 1.8-8.5 2.6-7-21.8-15.6-43.1-25.5-63.8 9.6-20.4 17.7-41.4 24.5-62.9 5.2 1.5 10.2 3.1 15 4.7 46.6 16 79.3 39.8 79.3 58 0 19.6-34.9 44.9-84.8 61.4zm-149.7-15c25.3 0 45.8-20.5 45.8-45.8s-20.5-45.8-45.8-45.8c-25.3 0-45.8 20.5-45.8 45.8s20.5 45.8 45.8 45.8z" }, child: [] }] })(_) } function FaRust(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M508.52,249.75,486.7,236.24c-.17-2-.34-3.93-.55-5.88l18.72-17.5a7.35,7.35,0,0,0-2.44-12.25l-24-9c-.54-1.88-1.08-3.78-1.67-5.64l15-20.83a7.35,7.35,0,0,0-4.79-11.54l-25.42-4.15c-.9-1.73-1.79-3.45-2.73-5.15l10.68-23.42a7.35,7.35,0,0,0-6.95-10.39l-25.82.91q-1.79-2.22-3.61-4.4L439,81.84A7.36,7.36,0,0,0,430.16,73L405,78.93q-2.17-1.83-4.4-3.61l.91-25.82a7.35,7.35,0,0,0-10.39-7L367.7,53.23c-1.7-.94-3.43-1.84-5.15-2.73L358.4,25.08a7.35,7.35,0,0,0-11.54-4.79L326,35.26c-1.86-.59-3.75-1.13-5.64-1.67l-9-24a7.35,7.35,0,0,0-12.25-2.44l-17.5,18.72c-1.95-.21-3.91-.38-5.88-.55L262.25,3.48a7.35,7.35,0,0,0-12.5,0L236.24,25.3c-2,.17-3.93.34-5.88.55L212.86,7.13a7.35,7.35,0,0,0-12.25,2.44l-9,24c-1.89.55-3.79,1.08-5.66,1.68l-20.82-15a7.35,7.35,0,0,0-11.54,4.79l-4.15,25.41c-1.73.9-3.45,1.79-5.16,2.73L120.88,42.55a7.35,7.35,0,0,0-10.39,7l.92,25.81c-1.49,1.19-3,2.39-4.42,3.61L81.84,73A7.36,7.36,0,0,0,73,81.84L78.93,107c-1.23,1.45-2.43,2.93-3.62,4.41l-25.81-.91a7.42,7.42,0,0,0-6.37,3.26,7.35,7.35,0,0,0-.57,7.13l10.66,23.41c-.94,1.7-1.83,3.43-2.73,5.16L25.08,153.6a7.35,7.35,0,0,0-4.79,11.54l15,20.82c-.59,1.87-1.13,3.77-1.68,5.66l-24,9a7.35,7.35,0,0,0-2.44,12.25l18.72,17.5c-.21,1.95-.38,3.91-.55,5.88L3.48,249.75a7.35,7.35,0,0,0,0,12.5L25.3,275.76c.17,2,.34,3.92.55,5.87L7.13,299.13a7.35,7.35,0,0,0,2.44,12.25l24,9c.55,1.89,1.08,3.78,1.68,5.65l-15,20.83a7.35,7.35,0,0,0,4.79,11.54l25.42,4.15c.9,1.72,1.79,3.45,2.73,5.14L42.56,391.12a7.35,7.35,0,0,0,.57,7.13,7.13,7.13,0,0,0,6.37,3.26l25.83-.91q1.77,2.22,3.6,4.4L73,430.16A7.36,7.36,0,0,0,81.84,439L107,433.07q2.18,1.83,4.41,3.61l-.92,25.82a7.35,7.35,0,0,0,10.39,6.95l23.43-10.68c1.69.94,3.42,1.83,5.14,2.73l4.15,25.42a7.34,7.34,0,0,0,11.54,4.78l20.83-15c1.86.6,3.76,1.13,5.65,1.68l9,24a7.36,7.36,0,0,0,12.25,2.44l17.5-18.72c1.95.21,3.92.38,5.88.55l13.51,21.82a7.35,7.35,0,0,0,12.5,0l13.51-21.82c2-.17,3.93-.34,5.88-.56l17.5,18.73a7.36,7.36,0,0,0,12.25-2.44l9-24c1.89-.55,3.78-1.08,5.65-1.68l20.82,15a7.34,7.34,0,0,0,11.54-4.78l4.15-25.42c1.72-.9,3.45-1.79,5.15-2.73l23.42,10.68a7.35,7.35,0,0,0,10.39-6.95l-.91-25.82q2.22-1.79,4.4-3.61L430.16,439a7.36,7.36,0,0,0,8.84-8.84L433.07,405q1.83-2.17,3.61-4.4l25.82.91a7.23,7.23,0,0,0,6.37-3.26,7.35,7.35,0,0,0,.58-7.13L458.77,367.7c.94-1.7,1.83-3.43,2.73-5.15l25.42-4.15a7.35,7.35,0,0,0,4.79-11.54l-15-20.83c.59-1.87,1.13-3.76,1.67-5.65l24-9a7.35,7.35,0,0,0,2.44-12.25l-18.72-17.5c.21-1.95.38-3.91.55-5.87l21.82-13.51a7.35,7.35,0,0,0,0-12.5Zm-151,129.08A13.91,13.91,0,0,0,341,389.51l-7.64,35.67A187.51,187.51,0,0,1,177,424.44l-7.64-35.66a13.87,13.87,0,0,0-16.46-10.68l-31.51,6.76a187.38,187.38,0,0,1-16.26-19.21H258.3c1.72,0,2.89-.29,2.89-1.91V309.55c0-1.57-1.17-1.91-2.89-1.91H213.47l.05-34.35H262c4.41,0,23.66,1.28,29.79,25.87,1.91,7.55,6.17,32.14,9.06,40,2.89,8.82,14.6,26.46,27.1,26.46H407a187.3,187.3,0,0,1-17.34,20.09Zm25.77,34.49A15.24,15.24,0,1,1,368,398.08h.44A15.23,15.23,0,0,1,383.24,413.32Zm-225.62-.68a15.24,15.24,0,1,1-15.25-15.25h.45A15.25,15.25,0,0,1,157.62,412.64ZM69.57,234.15l32.83-14.6a13.88,13.88,0,0,0,7.06-18.33L102.69,186h26.56V305.73H75.65A187.65,187.65,0,0,1,69.57,234.15ZM58.31,198.09a15.24,15.24,0,0,1,15.23-15.25H74a15.24,15.24,0,1,1-15.67,15.24Zm155.16,24.49.05-35.32h63.26c3.28,0,23.07,3.77,23.07,18.62,0,12.29-15.19,16.7-27.68,16.7ZM399,306.71c-9.8,1.13-20.63-4.12-22-10.09-5.78-32.49-15.39-39.4-30.57-51.4,18.86-11.95,38.46-29.64,38.46-53.26,0-25.52-17.49-41.59-29.4-49.48-16.76-11-35.28-13.23-40.27-13.23H116.32A187.49,187.49,0,0,1,221.21,70.06l23.47,24.6a13.82,13.82,0,0,0,19.6.44l26.26-25a187.51,187.51,0,0,1,128.37,91.43l-18,40.57A14,14,0,0,0,408,220.43l34.59,15.33a187.12,187.12,0,0,1,.4,32.54H423.71c-1.91,0-2.69,1.27-2.69,3.13v8.82C421,301,409.31,305.58,399,306.71ZM240,60.21A15.24,15.24,0,0,1,255.21,45h.45A15.24,15.24,0,1,1,240,60.21ZM436.84,214a15.24,15.24,0,1,1,0-30.48h.44a15.24,15.24,0,0,1-.44,30.48Z" }, child: [] }] })(_) } function FaVuejs(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M356.9 64.3H280l-56 88.6-48-88.6H0L224 448 448 64.3h-91.1zm-301.2 32h53.8L224 294.5 338.4 96.3h53.8L224 384.5 55.7 96.3z" }, child: [] }] })(_) } function RiJavascriptFill(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M6 3C4.34315 3 3 4.34315 3 6V18C3 19.6569 4.34315 21 6 21H18C19.6569 21 21 19.6569 21 18V6C21 4.34315 19.6569 3 18 3H6ZM13.3344 16.055C14.0531 16.6343 14.7717 16.9203 15.4904 16.913C15.9304 16.913 16.2677 16.8323 16.5024 16.671C16.7297 16.517 16.8434 16.297 16.8434 16.011C16.8434 15.7177 16.7297 15.4683 16.5024 15.263C16.2677 15.0577 15.8241 14.8523 15.1714 14.647C14.3867 14.4197 13.7817 14.1263 13.3564 13.767C12.9384 13.4077 12.7257 12.9053 12.7184 12.26C12.7184 11.6513 12.9824 11.1417 13.5104 10.731C14.0237 10.3203 14.6801 10.115 15.4794 10.115C16.5941 10.115 17.4887 10.3863 18.1634 10.929L17.3934 12.128C17.1221 11.9153 16.8104 11.7613 16.4584 11.666C16.1064 11.556 15.7911 11.501 15.5124 11.501C15.1311 11.501 14.8267 11.5707 14.5994 11.71C14.3721 11.8493 14.2584 12.0327 14.2584 12.26C14.2584 12.5093 14.3977 12.722 14.6764 12.898C14.9551 13.0667 15.4317 13.2537 16.1064 13.459C16.9204 13.701 17.4997 14.0237 17.8444 14.427C18.1891 14.8303 18.3614 15.3437 18.3614 15.967C18.3614 16.605 18.1157 17.155 17.6244 17.617C17.1404 18.0717 16.4364 18.31 15.5124 18.332C14.3024 18.332 13.2904 17.969 12.4764 17.243L13.3344 16.055ZM7.80405 16.693C8.03872 16.8397 8.32105 16.913 8.65105 16.913C8.99572 16.913 9.28172 16.814 9.50905 16.616C9.73639 16.4107 9.85005 16.055 9.85005 15.549V10.247H11.3351V15.835C11.3131 16.7003 11.0637 17.3237 10.5871 17.705C10.3157 17.9323 10.0187 18.0937 9.69605 18.189C9.37339 18.2843 9.06172 18.332 8.76105 18.332C8.21105 18.332 7.72339 18.2367 7.29805 18.046C6.84339 17.8407 6.46205 17.4777 6.15405 16.957L7.18805 16.11C7.37872 16.3667 7.58405 16.561 7.80405 16.693Z" }, child: [] }] })(_) } function TbBrandCoinbase(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, child: [] }, { tag: "path", attr: { d: "M12.95 22c-4.503 0 -8.445 -3.04 -9.61 -7.413c-1.165 -4.373 .737 -8.988 4.638 -11.25a9.906 9.906 0 0 1 12.008 1.598l-3.335 3.367a5.185 5.185 0 0 0 -7.354 .013a5.252 5.252 0 0 0 0 7.393a5.185 5.185 0 0 0 7.354 .013l3.349 3.367a9.887 9.887 0 0 1 -7.05 2.912z" }, child: [] }] })(_) } function TbBrandKotlin(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, child: [] }, { tag: "path", attr: { d: "M20 20h-16v-16h16" }, child: [] }, { tag: "path", attr: { d: "M4 20l16 -16" }, child: [] }, { tag: "path", attr: { d: "M4 12l8 -8" }, child: [] }, { tag: "path", attr: { d: "M12 12l8 8" }, child: [] }] })(_) } function TbBrandTypescript(_) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, child: [] }, { tag: "path", attr: { d: "M15 17.5c.32 .32 .754 .5 1.207 .5h.543c.69 0 1.25 -.56 1.25 -1.25v-.25a1.5 1.5 0 0 0 -1.5 -1.5a1.5 1.5 0 0 1 -1.5 -1.5v-.25c0 -.69 .56 -1.25 1.25 -1.25h.543c.453 0 .887 .18 1.207 .5" }, child: [] }, { tag: "path", attr: { d: "M9 12h4" }, child: [] }, { tag: "path", attr: { d: "M11 12v6" }, child: [] }, { tag: "path", attr: { d: "M21 19v-14a2 2 0 0 0 -2 -2h-14a2 2 0 0 0 -2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2 -2z" }, child: [] }] })(_) } function App() { const [_, j] = reactExports.useState(!0); reactExports.useEffect(() => { const _e = () => { window.innerWidth <= 991 ? j(!0) : j(!1) }; return _e(), window.addEventListener("resize", _e), () => { window.removeEventListener("resize", _e) } }, []); const $ = [{ title: "Teamwork Management App", image: teamworkApp, description: "Android Application designed to create teams and organize any type of activity: study groups, trips, or work projects. Users can create both individual and shared tasks and communicate in real-time among team members to coordinate effectively.", icon: jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: [jsxRuntimeExports.jsx(FaAndroid, {}), jsxRuntimeExports.jsx(TbBrandKotlin, {})] }), github: "https://github.com/ScamporrinoAndrea/TeamworkApp" }, { title: "Gino Panino Website", image: ginoPanino, description: "Website created for a sandwich restaurant in Turin, Italy. Built with Vue.js and Bootstrap, it offers a sleek, responsive design to highlight the menu and the location.", icon: jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: [jsxRuntimeExports.jsx(FaVuejs, {}), jsxRuntimeExports.jsx(RiJavascriptFill, {}), jsxRuntimeExports.jsx(FaBootstrap, {})] }), github: "https://ginopanino.it" }, { title: "DeltaPlan", image: Deltaplan, description: "Progressive web application in React that allows you to plan meals and activities and automatically synchronise a shopping list and inventory.", icon: jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: [jsxRuntimeExports.jsx(FaReact, {}), jsxRuntimeExports.jsx(RiJavascriptFill, {}), jsxRuntimeExports.jsx(FaFigma, {}), jsxRuntimeExports.jsx(FaNode, {}), jsxRuntimeExports.jsx(FaBootstrap, {})] }), github: "https://github.com/ScamporrinoAndrea/DeltaPlan" }, { title: "Job Placement ", image: jobPlacement, description: "A full-stack microservices-based system for temporary job placement services, developed using Spring Boot, Kotlin, PostgreSQL, Docker and React.", icon: jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: [jsxRuntimeExports.jsx(FaReact, {}), jsxRuntimeExports.jsx(TbBrandTypescript, {}), jsxRuntimeExports.jsx(FaFigma, {}), jsxRuntimeExports.jsx(FaDocker, {}), jsxRuntimeExports.jsx(TbBrandKotlin, {}), jsxRuntimeExports.jsx(SiSpringboot, {}), jsxRuntimeExports.jsx(SiPostgresql, {})] }), github: "https://github.com/ScamporrinoAndrea/JobPlacementSystem" }, { title: "ThesisManagement", image: project1Image, description: "Full-stack Web Application to upgrade and simplify the Polytechnic of Turin's thesis management process. Developed in a team of 7 students winning first place out of 18 teams the course competition with the possibility of replacing the current version of the thesis management system.", icon: jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: [jsxRuntimeExports.jsx(FaReact, {}), jsxRuntimeExports.jsx(RiJavascriptFill, {}), jsxRuntimeExports.jsx(FaFigma, {}), jsxRuntimeExports.jsx(FaDocker, {}), jsxRuntimeExports.jsx(FaNode, {}), jsxRuntimeExports.jsx(FaBootstrap, {})] }), github: "https://github.com/ScamporrinoAndrea/ThesisManagement" }, { title: "Tamagotchi", image: tamagotchi, description: "Tamagotchi game developed using Keil μVision for LPC1768 and LANDTIGER Board. Features include a customizable virtual pet with animations, joystick navigation, touchscreen interaction, sound effects, and volume control.", icon: jsxRuntimeExports.jsx("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: jsxRuntimeExports.jsx(TbBrandCoinbase, {}) }), github: "https://github.com/ScamporrinoAndrea/tamagotchi" }, { title: "Rust Screenshot Utility", image: RustUtility, description: "Screenshot utility for Windows and MacOS provides a seamless cross-platform experience for capturing screenshots with features such as hotkey support, annotation tools, various output formats and allows capturing screens from multiple monitors.", icon: jsxRuntimeExports.jsx("div", { style: { display: "flex", justifyContent: "space-between", gap: 3 }, children: jsxRuntimeExports.jsx(FaRust, {}) }), github: "https://github.com/ScamporrinoAndrea/rust-grab-utility" }]; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(AnimatedCursor, { innerSize: 8, outerSize: 30, color: "0, 255, 10", outerAlpha: .2, innerScale: 0, outerScale: 3, outerStyle: { border: "1px solid rgba(0, 255, 10, 1)" }, clickables: [".nav-item", ".nav-title", ".clickable"], showSystemCursor: _ }), jsxRuntimeExports.jsx(Home, { projects: $ }), jsxRuntimeExports.jsx("div", { className: "d-lg-none", children: jsxRuntimeExports.jsx(Mobile, { projects: $ }) })] }) } client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React$1.StrictMode, { children: jsxRuntimeExports.jsx(App, {}) }));
